<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programming Multiple Robots with ROS 2</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item "><a href="ros2.html"><strong aria-hidden="true">2.</strong> ROS 2</a></li><li class="chapter-item "><a href="traffic-editor.html"><strong aria-hidden="true">3.</strong> Traffic Editor</a></li><li class="chapter-item "><a href="simulation.html"><strong aria-hidden="true">4.</strong> Simulation</a></li><li class="chapter-item "><a href="rmf-core.html"><strong aria-hidden="true">5.</strong> RMF Core</a></li><li class="chapter-item "><a href="soss.html"><strong aria-hidden="true">6.</strong> SOSS</a></li><li class="chapter-item "><a href="hardware.html"><strong aria-hidden="true">7.</strong> Hardware</a></li><li class="chapter-item "><a href="ui.html"><strong aria-hidden="true">8.</strong> User Interfaces</a></li><li class="chapter-item "><a href="security.html"><strong aria-hidden="true">9.</strong> Security</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Programming Multiple Robots with ROS 2</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>In this section, we shall describe the motivation for ROS 2 and the RMF
system for integrating multiple robots.</p>
<h1><a class="header" href="#ros-2" id="ros-2">ROS 2</a></h1>
<p>(insert)</p>
<h1><a class="header" href="#robotics-middleware-framework-rmf" id="robotics-middleware-framework-rmf">Robotics Middleware Framework (RMF)</a></h1>
<h2><a class="header" href="#motivation-for-rmf" id="motivation-for-rmf">Motivation for RMF</a></h2>
<p>Imagine with us a world where the incredible robots that are available on the market are now able to co-exist in the same facility; gracefully sharing critical resources such as corridors, elevators/lifts, doors and other infrastructure to enable a more efficient overall system. Imagine integrating an elevator/lift for robots only once and this elevator/lift is now enabled to be used for any robot that needs to use the shared resource in a controlled and safe manner. Imagine a world free of robot deadlocks in a shared corridor. These ideas are achievable today using an amazing system called RMF.</p>
<p>Many companies adopt a strategy of operational efficiency and use the lever of technology, thru the deployment of robots and other smart devices, to help realize their goals. The current generation of robots in production environments today are able to provide services including both bulk and single piece flow delivery, cleaning, disinfecting, security, monitoring, and much more. The diversity in robotic use cases most likely means the best in class robots for each task will come from different robot providers or system integrators. This modern reality makes it critical for a common software framework to be in place in order to manage these heterogeneous resources and to ensure that information is being used effectively from different platforms to promote overall system efficiency.</p>
<p>Without an initial goal and plan for a holistically efficient robotics system, there can be a significant but hidden risk for end users when committing to a single system or platform provider. The hidden &quot;walled gardens&quot; are likely to force an end user to limit their selection of future solutions from that particular provider to minimize opearational risk and avoid redundant integration costs. As the scope and scale of robotic deployments increase this problem is exacerbated, leaving the customer with a perception of no good option except to stay with their current provider.</p>
<p>Beyond the increase cost risk of scaling deployment with different providers, there is also the inherent conflict over shared resources such as elevators, doorways, corridors, network bandwidth, chargers, operations-center screen “real estate,” and human resources such as IT personnel and maintenance technicians. As robotic scale increases, it would become more cumbersome for an operations team to consider managing a large, heterogeneous, multi-vendor robot environment.</p>
<p>These problem statements were the foundational motivations for the development of RMF. To unlock the end user's options and increase robotic system selection ultimately means the entire robotic ecosystem can grow. We can collectively grow the pie.</p>
<p>Historically ROS development has focused heavily on the software running on or near individual robots. RMF is designed to operate at a higher abstraction layer to create networked fleets of robots that interoperate with building infrastructure systems, enterprise services, IOT devices, and human interfaces. Unlock your facility and your future with RMF.</p>
<h1><a class="header" href="#ros-2-1" id="ros-2-1">ROS 2</a></h1>
<p>Herein we shall discuss Deep Thoughts about ROS 2</p>
<h1><a class="header" href="#traffic-editor" id="traffic-editor">Traffic Editor</a></h1>
<p>In this section, we shall describe the traffic-editor GUI.</p>
<h1><a class="header" href="#simulation" id="simulation">Simulation</a></h1>
<p>This chapter will describe how to generate building models from the
<code>traffic-editor</code> files and simulate fleets of robots in them.</p>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>Simulation environments for testing robotic solutions offer immense value across
various stages of R&amp;D and deployment. More notably, simulations provide the
following benefits.</p>
<ul>
<li>
<p><strong>Time and resource saving:</strong> While testing with hardware is indispensible,
the process can slow the pace of development with additional setup time, robot
downtime and and reset periods between trials. As the number of participants
scale, so do costs associated with purchasing hardware and consumables for
testing. This is especially true with solutions such as RMF which aim to
integrate several mobile/stationary robots, and building systems such as doors
and lifts. Simulations provide a potentially cost effective and time saving alternative
for evaluating the behavior of robot systems at scale. More importantly
simulations can help answer questions prior to deployment such as how many
participants can be supported or how the existing behavior would change with
the introduction of a new fleet, both of which can inform purchasing decisions
for facility owners. </p>
</li>
<li>
<p><strong>Robust testing:</strong> Robots in simulation neither run out of battery nor incur costs when they happen to unfortunately crash into something. Scenarios
can be tested for hours at a stretch, at faster speeds, to fine tune
algorithms and verify their robustness. One factor on how much scenario testing to run is a decision on how much compute power you want to avail for the simulation. With the introduction of cloud simulation, this limit is then a trade off of cost and speed as well. As scenarios in simulation are
repeatable, fixes for undesirable bugs encountered can be readily validated.
Reaction of the system to edge cases which are rare but have severe
consequences can also be studied through simulation. Data logged from hardware
trials can be used to recreate the scenario in simulation which may be further
helpful for debugging. Lastly, long running simulations can instill confidence
in facility owners prior to deployment.</p>
</li>
</ul>
<p>Physics-based simulators such as <code>Gazebo</code>, carry the benefit of easily
interfacing with ROS2 nodes through wrappers provided by <code>gazebo_ros_pkgs</code>.
Gazebo plugins can be developed that accurately emulate the behavior of robots,
sensors and infrastructure systems which enhance the overall fidelity of
simulations. It is worth emphasizing here that the exact same code used to run the simulations
will also be run on the physical system as well without any changes.</p>
<p>However, despite these compelling benefits, simulations are sparingly employed
by developers and system integrators citing complexity over generating
environments and configuring them with appropriate plugins. In a recent publication &quot;<em>A Study on the Challenges of Using Robotics Simulators for Testing</em>,&quot; by Afsoon Afzal, Deborah S. Katz, Claire Le Goues and Christopher S. Timperley they noted the main reasons participants gave for not using simulation for a particular project and summarized their findings as follows:</p>
<table><thead><tr><th>Reason for not using simulation</th><th>#</th><th>%</th></tr></thead><tbody>
<tr><td>Lack of time or resources</td><td>15</td><td>53.57%</td></tr>
<tr><td>Not realistic/accurate enough</td><td>15</td><td>53.57%</td></tr>
<tr><td>Lack of expertise or knowledge on how to use software-based simulation</td><td>6</td><td>21.43%</td></tr>
<tr><td>There was no simulator for the robot</td><td>4</td><td>14.29%</td></tr>
<tr><td>Not applicable</td><td>4</td><td>14.29%</td></tr>
<tr><td>Too much time or compute resources</td><td>2</td><td>7.14%</td></tr>
<tr><td>Nobody suggested it</td><td>0</td><td>0.00%</td></tr>
<tr><td>Other</td><td>2</td><td>7.14%</td></tr>
</tbody></table>
<p>The RMF project also
aims to address these hurdles by simplifying the process of setting up
simulation environments for multi-fleet traffic control as we will explain further throughout this section.</p>
<h2><a class="header" href="#building-map-generator" id="building-map-generator">Building Map Generator</a></h2>
<p>The <code>traffic_editor</code> as discussed previously is a tool to annotate building
floor plans with fleet specific traffic information in a vendor neutral manner.
This includes waypoints of interest, traffic lanes and shared resources such as
doorways and lifts. It can also be used to markup the walls and floors and add
thumbnails of artifacts in the environment. The ability to auto-generate a 3D
world using this annotated map is of significant value towards simplifying the
creation and management of simulations. To this end, the <code>building_map_tools</code>
package in <code>traffic_editor</code> contains an executable <code>building_map_generator</code>. The
executable operates in two modes 1) To generate a Gazebo/Ignition compliant
<code>.world</code> file and 2) Export the fleet specific traffic information in the form
of navigation graphs which are utilized by <code>fleet_adapters</code> for planning.</p>
<p><img src="images/building_map_generator.png" alt="" /></p>
<p>To auto-generate a Gazebo simulation world, the executable takes in the command arugment &quot;gazebo&quot; along with others described below.</p>
<pre><code class="language-bash">usage: building_map_generator gazebo [-h] [-o [OPTIONS [OPTIONS ...]]] [-n]
                                     [-m MODEL_PATH] [-c CACHE]
                                     INPUT OUTPUT_WORLD OUTPUT_MODEL_DIR

positional arguments:
  INPUT                 Input building.yaml file to process
  OUTPUT_WORLD          Name of the .world file to output
  OUTPUT_MODEL_DIR      Path to output the map model files

optional arguments:
  -h, --help            show this help message and exit
  -o [OPTIONS [OPTIONS ...]], --options [OPTIONS [OPTIONS ...]]
                        Generator options
  -n, --no_download     Do not download missing models from Fuel
  -m MODEL_PATH, --model_path MODEL_PATH
                        Gazebo model path to check for models
  -c CACHE, --cache CACHE
                        Path to pit_crew model cache
</code></pre>
<p>The script parses the <code>.building.yaml</code> file and generates meshes for the
flooring and walls for each level which are combined into a <code>model.sdf</code> file in
the <code>OUTPUT_MODEL_DIR/</code> directory. The <code>model.sdf</code> files for each level are
imported into the <code>.world</code> with filepath <code>OUTPUT_WORLD</code>. Model sub-elements for
various static objects annotated in the <code>traffic_editor</code> are included in the
<code>.world</code> as seen in the snippet below. Similar blocks for annotated robots are
generated. It is the responsibility of the user to append the environment
variable <code>$GAZEBO_MODEL_PATH</code> with the relevant paths to the models prior to
loading the <code>.world</code> file in Gazebo. This process can be simplified through ROS2
launch files and will be discussed in later sections.</p>
<pre><code class="language-xml">&lt;include&gt;
  &lt;name&gt;OfficeChairBlack_6&lt;/name&gt;
  &lt;uri&gt;model://OfficeChairBlack&lt;/uri&gt;
  &lt;pose&gt;4.26201267190027 -7.489812761393875 0 0 0 1.1212&lt;/pose&gt;
  &lt;static&gt;True&lt;/static&gt;
&lt;/include&gt;
</code></pre>
<p>The parser also includes Sdf elements for other dynamic assets such as doors and
lifts. Their mechanisms are discussed in the ensuing section. An <code>Ignition</code>
compatible world can be generated by using the &quot;command&quot; argument &quot;ignition&quot;.</p>
<p>Reconfiguring simulation environments becomes as trivial as editing the
annotations on the 2D drawing and re-running the <code>building_map_generator</code>. This
is exceedingly useful to quickly evaluate traffic flow as the spatial
configuration in the facility changes.</p>
<p>To generate navigation graphs for fleet adapters, the <code>building_map_generator</code> is executed with <code>command</code> argument &quot;nav&quot;. The navigation graph is generated as a <code>.yaml</code> file and is parsed during launch by the corresponding fleet adapter.</p>
<pre><code class="language-bash">usage: building_map_generator nav [-h] INPUT OUTPUT_DIR

positional arguments:
  INPUT       Input building.yaml file to process
  OUTPUT_DIR  Path to output the nav .yaml files

</code></pre>
<h2><a class="header" href="#rmf-assets-and-plugins" id="rmf-assets-and-plugins">RMF Assets and Plugins</a></h2>
<p>Assets play a pivotal role in recreating environments in simulation. Projects such as RMF, SubT and others have allowed developers to create and open source 3D models of robots, mechanical infrastructure systems and scene objects. They are available for download <a href="https://app.ignitionrobotics.org/OpenRobotics/fuel/collections/">here</a>.
Beyond imparting visual accuracy, assets may be dynamic and interface with rmf
core systems through the aid of plugins. </p>
<p>To simulate the behavior of hardware such as robot models and infrastructure
systems, several Gazebo plugins have been architected. These plugins are derivates of the <a href="http://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1ModelPlugin.html">ModelPlugin</a> class and tie in standard ROS2 and rmf_core messages to provide necessary functionality. The following sections briefly describe some of these plugins.</p>
<h4><a class="header" href="#robots" id="robots">Robots</a></h4>
<p>As highlighted earlier, several robot models (SESTO, MiR100, Magni, Hospi) have been
open sourced for use in simulation. For these models to emulate the behavior of
their physical counterparts which have been integrated with RMF, they need to 1)
interface with <code>rmf_fleet_adapters</code> and 2) navigate to locations in the
simulated world. These functionalities, for a &quot;<em>full control</em>&quot; robot type, are
achieved through the <code>slotcar</code> <a href="https://github.com/osrf/traffic_editor/blob/master/building_gazebo_plugins/src/slotcar.cpp">plugin</a>.
The plugin subscribes to <code>/robot_path_requests</code> and <code>/robot_mode_requests</code>
topics and responds to relevant <code>PathRequest</code> and <code>ModeRequest</code> messages
published by its <code>rmf_fleet_adapter</code>. The plugin also publishes the robot's
state to the <code>/robot_state</code> topic.</p>
<p>To navigate the robot through waypoints in a <code>PathRequest</code> message, a simple
&quot;rail-like&quot; navigation algorithm is utilized which accelerates and decelerates
the robot along a straight line from its current position to the next waypoint.
The plugin relies on these fundamental assumptions</p>
<ul>
<li>The robot model is a two-wheel differential drive robot</li>
<li>The left and right wheel joints are named  <code>joint_tire_left</code> and <code>joint_tire_right</code> respectively</li>
</ul>
<p>Other parameters, majority of which are kinematic properties of the robot are inferred from sdf parameters. </p>
<pre><code class="language-xml">&lt;plugin name=&quot;slotcar&quot; filename=&quot;libslotcar.so&quot;&gt;
  &lt;nominal_drive_speed&gt;0.5&lt;/nominal_drive_speed&gt;
  &lt;nominal_drive_acceleration&gt;0.25&lt;/nominal_drive_acceleration&gt;
  &lt;max_drive_acceleration&gt;0.75&lt;/max_drive_acceleration&gt;
  &lt;nominal_turn_speed&gt;0.6&lt;/nominal_turn_speed&gt;
  &lt;nominal_turn_acceleration&gt;1.5&lt;/nominal_turn_acceleration&gt;
  &lt;max_turn_acceleration&gt;2.0&lt;/max_turn_acceleration&gt;
  &lt;tire_radius&gt;0.1&lt;/tire_radius&gt;
  &lt;base_width&gt;0.3206&lt;/base_width&gt;
  &lt;stop_distance&gt;0.75&lt;/stop_distance&gt;
  &lt;stop_radius&gt;0.75&lt;/stop_radius&gt;
&lt;/plugin&gt;
</code></pre>
<p>During simulation, it is assumed that the robot's path is free of static
obstacles but the plugin contains logic to pause the robot's motion if an
obstacle is detected in its path. While it is possible to deploy a sensor based
navigation stack, the approach is avoided to minimize the computational load on
the system from running a navigation stack for each robot in the simulation.
Given the focus on traffic management of heterogeneous fleets and not robot
navigation, the <code>slotcar</code> plugin provides an efficiently means to simulate the
interaction between rmf core systems and robots.</p>
<p>The <code>slotcar</code> plugin is meant to serve as a generalized solution. Vendors are
encouraged to develop and distribute plugins that more accurately represent the
capabilities of their robot and the level of integration with RMF.</p>
<h4><a class="header" href="#doors" id="doors">Doors</a></h4>
<p>Unlike robot models whose geometries are fixed and hence can be directly
included in the generated <code>.world</code> file, doors are custom defined in
<code>traffic_editor</code> and have their own generation pipeline. As seen in the figure
below, an annotated door has several properties which include the location of
its ends, the type of door (hinged, double_hinged, sliding, double_sliding) and
its range of motion (for hinged doors).</p>
<p><img src="images/door_traffic_editor.png" alt="Figure X" /></p>
<p>The <code>building_map_generator gazebo</code> script parses a <code>.building.yaml</code> file for
any doors and automatically generates an sdf sub-element with links and joints
required for the door along with a configured plugin. The sdf sub-element
generated for the door in the figure above is presented below.</p>
<pre><code class="language-xml">&lt;model name=&quot;coe_door&quot;&gt;
  &lt;pose&gt;8.077686357313898 -5.898342045416362 0.0 0 0 1.1560010438234292&lt;/pose&gt;
  &lt;plugin filename=&quot;libdoor.so&quot; name=&quot;door&quot;&gt;
    &lt;v_max_door&gt;0.5&lt;/v_max_door&gt;
    &lt;a_max_door&gt;0.3&lt;/a_max_door&gt;
    &lt;a_nom_door&gt;0.15&lt;/a_nom_door&gt;
    &lt;dx_min_door&gt;0.01&lt;/dx_min_door&gt;
    &lt;f_max_door&gt;500.0&lt;/f_max_door&gt;
    &lt;door left_joint_name=&quot;left_joint&quot; name=&quot;coe_door&quot; right_joint_name=&quot;empty_joint&quot; type=&quot;SwingDoor&quot; /&gt;
  &lt;/plugin&gt;
  &lt;link name=&quot;left&quot;&gt;
    &lt;pose&gt;0 0 1.11 0 0 0&lt;/pose&gt;
    &lt;visual name=&quot;left&quot;&gt;
      &lt;material&gt;
        &lt;ambient&gt;120 60 0 0.6&lt;/ambient&gt;
        &lt;diffuse&gt;120 60 0 0.6&lt;/diffuse&gt;
      &lt;/material&gt;
      &lt;geometry&gt;
        &lt;box&gt;
          &lt;size&gt;0.8766026166317483 0.03 2.2&lt;/size&gt;
        &lt;/box&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
    &lt;collision name=&quot;left&quot;&gt;
      &lt;surface&gt;
        &lt;contact&gt;
          &lt;collide_bitmask&gt;0x02&lt;/collide_bitmask&gt;
        &lt;/contact&gt;
      &lt;/surface&gt;
      &lt;geometry&gt;
        &lt;box&gt;
          &lt;size&gt;0.8766026166317483 0.03 2.2&lt;/size&gt;
        &lt;/box&gt;
      &lt;/geometry&gt;
    &lt;/collision&gt;
    &lt;inertial&gt;
      &lt;mass&gt;50.0&lt;/mass&gt;
      &lt;inertia&gt;
        &lt;ixx&gt;20.17041666666667&lt;/ixx&gt;
        &lt;iyy&gt;23.36846728119012&lt;/iyy&gt;
        &lt;izz&gt;3.20555061452345&lt;/izz&gt;
      &lt;/inertia&gt;
    &lt;/inertial&gt;
  &lt;/link&gt;
  &lt;joint name=&quot;left_joint&quot; type=&quot;revolute&quot;&gt;
    &lt;parent&gt;world&lt;/parent&gt;
    &lt;child&gt;left&lt;/child&gt;
    &lt;axis&gt;
      &lt;xyz&gt;0 0 1&lt;/xyz&gt;
      &lt;limit&gt;
        &lt;lower&gt;-1.57&lt;/lower&gt;
        &lt;upper&gt;0&lt;/upper&gt;
      &lt;/limit&gt;
    &lt;/axis&gt;
    &lt;pose&gt;0.44330130831587417 0 0 0 0 0&lt;/pose&gt;
  &lt;/joint&gt;
&lt;/model&gt;
</code></pre>
<p>The door <a href="https://github.com/osrf/traffic_editor/blob/master/building_gazebo_plugins/src/door.cpp">plugin</a> responds to <code>DoorRequest</code> messages with <code>door_name</code> matching its <code>model name</code> sdf tag. These messages are published over the <code>/door_requests</code> topic. The plugin is agnostic of the type of door defined and relies on the <code>left_joint_name</code> and <code>right_joint_name</code> parameters to determine which joints to actuate during open and close motions. During these motions, the joints are commanded to their appropriate limits which are specified in the parent element. The joint motions adhere to kinematic constraints specified by sdf parameters while following acceleration and deceleration profiles similar to the <code>slotcar</code>. </p>
<p>To avoid situations where one robot requests a door to close on another robot, a <code>door_supervisor</code> <a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/src/door_supervisor/main.cpp">node</a> is deployed in practice. The node publishes to <code>/door_requests</code> and subscribes to <code>/adapter_door_requests</code> which the fleet adapters publish to when their robot requires access through a door. The <code>door_supervisor</code> keeps track of requests from all the fleet adapters in the system and relays the request to the door adapters while avoiding aforementioned conflicts.</p>
<h4><a class="header" href="#lifts" id="lifts">Lifts</a></h4>
<p>The ability to test lift integration is crucial as these systems are often the operational bottlenecks in facilities given their shared usage by both humans and multi robot fleets. As with annotated doors, lifts can be customized in a number of ways in the <code>traffic_editor</code> gui including the dimension &amp; orientation of the cabin and mapping cabin doors to building levels.</p>
<p>TODO: update gazebo image
<img src="images/lift_traffic_editor.png" alt="" /></p>
<p>The <code>building_map_generator gazebo</code> script parses the <code>.building.yaml</code> file for lifts definitions and auto-generates the sdf elements for the cabin, cabin doors as well as lift shaft doors. A prismatic joint is defined at the base of the cabin which is actuated by the lift plugin to move the cabin between different levels. While the cabin doors are part of the cabin structure, the shaft doors are fixed to building. Both sets of doors open/close simultaneously at a given level and are controlled by the lift plugin itself. These doors are created using the same method as other doors in the building and include the door plugin as well. The <code>building_map_generator</code> also appends a lift [plugin](todo add link) element with required parameters to the lift's model sdf block.</p>
<pre><code class="language-xml">&lt;plugin filename=&quot;liblift.so&quot; name=&quot;lift&quot;&gt;
  &lt;lift_name&gt;Lift1&lt;/lift_name&gt;
  &lt;floor elevation=&quot;0.0&quot; name=&quot;L1&quot;&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door1&quot; shaft_door=&quot;ShaftDoor_Lift1_L1_door1&quot; /&gt;
  &lt;/floor&gt;
  &lt;floor elevation=&quot;10.0&quot; name=&quot;L2&quot;&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door1&quot; shaft_door=&quot;ShaftDoor_Lift1_L2_door1&quot; /&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door2&quot; shaft_door=&quot;ShaftDoor_Lift1_L2_door2&quot; /&gt;
  &lt;/floor&gt;
  &lt;floor elevation=&quot;20.0&quot; name=&quot;L3&quot;&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door1&quot; shaft_door=&quot;ShaftDoor_Lift1_L3_door1&quot; /&gt;
  &lt;/floor&gt;
  &lt;reference_floor&gt;L1&lt;/reference_floor&gt;
  &lt;v_max_cabin&gt;2.0&lt;/v_max_cabin&gt;
  &lt;a_max_cabin&gt;1.2&lt;/a_max_cabin&gt;
  &lt;a_nom_cabin&gt;1.0&lt;/a_nom_cabin&gt;
  &lt;dx_min_cabin&gt;0.001&lt;/dx_min_cabin&gt;
  &lt;f_max_cabin&gt;25323.0&lt;/f_max_cabin&gt;
  &lt;cabin_joint_name&gt;cabin_joint&lt;/cabin_joint_name&gt;
&lt;/plugin&gt;
</code></pre>
<p>The plugin subscribes to <code>/lift_requests</code> topic and responds to <code>LiftRequest</code> messages with <code>lift_name</code> matching its <code>model name</code> sdf tag. The displacement between the cabin's current elevation and that of the <code>destination_floor</code> is computed and a suitable velocity is applied to the cabin joint. Prior to any motion, the cabin doors are closed and only opened at the <code>destination_floor</code> if specified in the LiftRequest message. As the cabin and shaft doors are configured with the <code>door</code> plugin, they are commanded through <code>DoorRequest</code> messages published by the <code>lift</code> plugin.
Analogous to the <code>door_supervisor</code>, a <code>lift_supervisor</code> <a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/src/lift_supervisor/main.cpp">node</a> is started in practice to manage requests from different robot fleets.</p>
<h4><a class="header" href="#workcells" id="workcells">Workcells</a></h4>
<p>Robots performing deliveries within facilities is a common use case and hence a <code>Delivery</code> task is configured into the <code>rmf_fleet_adapters</code>. In a delivery task, a payload is loaded onto the robot at one location and unloaded at another. The loading and unloading of the payload may be automated by a robot/workcell in a facility. To integrate these systems (generalized as &quot;dispensers&quot;) with RMF core systems, a set of dispenser messages are <a href="https://github.com/osrf/rmf_core/tree/master/rmf_dispenser_msgs/msg">defined</a>. When the robot reaches the loading station, the <code>rmf_fleet_adapter</code> publishes a <code>DispenserRequest</code> message which the dispenser receives and begins processing. When the dispensing is successful, the dispenser is required to publish a <code>DispenserResult</code> message with <code>SUCCESS</code> status. The <code>rmf_fleet_adapter</code> then instructs the robot to proceed to the unloading station where a similar set of message are exchanged with the workcell unloading the payload.</p>
<p>To replicate this delivery behavior in simulation, the <code>TeleportDispenser</code> and <code>TeleportIngestor</code> <a href="https://github.com/osrf/rmf_demos/tree/master/rmf_gazebo_plugins/src">plugins</a> are designed. These plugins are loaded into <a href="https://github.com/osrf/rmf_demos/tree/master/rmf_demo_assets/models">3D models</a> the same names. 
To setup a payload loading station:</p>
<ul>
<li>Assign a <code>workcell_name</code> attribute to the waypoint (see figure below)</li>
<li>Add a <code>TeleportDispenser</code> model beside the waypoint with <code>name</code> matching the <code>workcell_name</code></li>
<li>Add the payload model beside the <code>TeleportDispenser</code> model (Coke can in image below)</li>
</ul>
<p>To setup a payload unloading station:</p>
<ul>
<li>Assign a <code>workcell_name</code> attribute to the waypoint (see figure below)</li>
<li>Add a <code>TeleportIngestor</code> model beside the waypoint with <code>name</code> matching the <code>workcell_name</code></li>
</ul>
<p>When a <code>DispenserRequest</code> message is published with <code>target_guid</code> matching the name of the <code>TeleportDispenser</code> model, the plugin will teleport the payload onto the nearest robot model. Conversely, when the <code>target_guid</code> matches the name of the <code>TeleportIngestor</code> model, the <code>TeleportIngestor</code> plugin will teleport the payload on the robot to its location in the world. The combinations of these plugins allow for delivery requests to be simulation. In the future, this mechanism will be replaced by actual workcells or robot arms but the underlying message exchanges will remain the same.</p>
<p><img src="images/dispensers.png" alt="" /></p>
<h2><a class="header" href="#creating-simulations-and-running-scenarios" id="creating-simulations-and-running-scenarios">Creating Simulations and Running Scenarios</a></h2>
<p>The section aims to provide an overview of the various components in the <code>rmf_demos</code> <a href="https://github.com/osrf/rmf_demos">repository</a> which may serve as a reference for setting up other simulations and assigning tasks to robots. Here, will will focus on the <code>office</code> world.</p>
<h4><a class="header" href="#map-package" id="map-package">Map package</a></h4>
<p>The <code>rmf_demo_maps</code> package houses annotated <code>traffic_editor</code> files which will be used for the 3D world generation. Opening the <code>office.project.yaml</code> file in <code>traffic_editor</code> reveals a single level floorplan that has walls, floors, scale measurements, doors, lanes and models annotated. All the robot lanes are set to <code>bidirectional</code> with <code>graph_idx</code> equal to &quot;0&quot;. The later signifies that all the lanes belong to the same fleet. In the <code>airport</code> world, we have two sets of graphs with indices &quot;0&quot; and &quot;1&quot; which reflect laneways occupiable by two fleets respectively. The figures below highlights special attributes assigned to certain waypoints to indicate robot spawn locations as well as disperser workcells.</p>
<p><img src="images/rmf_demo_maps.png" alt="" /></p>
<p>To export a 3D world file along with the navigation graphs, the <code>building_map_generator</code> script is used. The <code>CMakeLists.txt</code> file of this package is configured to automatically run the generator scripts when the package is built. The outputs are installed to the <code>share/</code> directory for the package. This allows for the generated files to be easily located and used by other packages in the demo.</p>
<pre><code class="language-cmake">foreach(path ${traffic_editor_paths})

  # Get the output world name
  string(REPLACE &quot;.&quot; &quot;;&quot; list1 ${path})
  list(GET list1 0 name)
  string(REPLACE &quot;/&quot; &quot;;&quot; list2 ${name})
  list(GET list2 -1 world_name)

  set(map_path ${path})
  set(output_world_name ${world_name})
  set(output_dir ${CMAKE_CURRENT_BINARY_DIR}/maps/${output_world_name})
  set(output_world_path ${output_dir}/${output_world_name}.world)
  set(output_model_dir ${output_dir}/models)

  # first, generate the world
  add_custom_command(
    OUTPUT ${output_world_path}
    COMMAND ros2 run building_map_tools building_map_generator gazebo ${map_path} ${output_world_path} ${output_model_dir}
    DEPENDS ${map_path}
  )

  add_custom_target(generate_${output_world_name} ALL
    DEPENDS ${output_world_path}
  )

  # now, generate the nav graphs
  set(output_nav_graphs_dir ${output_dir}/nav_graphs/)
  set(output_nav_graphs_phony ${output_nav_graphs_dir}/phony)
  add_custom_command(
    OUTPUT ${output_nav_graphs_phony}
    COMMAND ros2 run building_map_tools building_map_generator nav ${map_path} ${output_nav_graphs_dir}
    DEPENDS ${map_path}
  )

  add_custom_target(generate_${output_world_name}_nav_graphs ALL
    DEPENDS ${output_nav_graphs_phony}
  )

  install(
    DIRECTORY ${output_dir}
    DESTINATION share/${PROJECT_NAME}/maps
  )

endforeach()

</code></pre>
<h4><a class="header" href="#launch-files" id="launch-files">Launch Files</a></h4>
<p>The <code>demos</code> package includes all the essential launch files required to bring up the simulation world and start various RMF services. The office simulation is launched using the <code>office.launch.xml</code> file. First, a <code>common.launch.xml</code> file is loaded which starts </p>
<ul>
<li>The <code>rmf_traffic_schedule</code> node responsible for maintaining the database of robot trajectories and monitoring traffic for conflicts. If a conflict is detected, notifications are sent to relevant fleet adapters which begin the negotiation process to find an optimal resolution.</li>
<li>The <code>building_map_server</code> which publishes a <code>BuildingMap</code> message used by UIs for visualization. The executable takes in the path to the relevant <code>.building.yaml</code> file as an argument. The <code>office.building.yaml</code> file installed by the <code>rmf_demo_maps</code> package is located using the <code>find-pkg-share</code> substitution command and is stored in the <code>config_file</code> argument.</li>
<li>The <code>rmf_schedule_visualizer</code> which is an RViz based UI to visualize the traffic lanes, actual positions of the robots, expected trajectory of robots as reflected in the <code>rmf_traffic_schedule</code> and states of building systems such as door and lifts.</li>
<li>The <code>door_supervisor</code> and <code>lift_supervisor</code> nodes to manage requests submitted by fleet adapter and UIs.</li>
</ul>
<pre><code class="language-xml">&lt;!-- Common launch --&gt;
&lt;include file=&quot;$(find-pkg-share demos)/common.launch.xml&quot;&gt;
  &lt;arg name=&quot;use_sim_time&quot; value=&quot;true&quot;/&gt;
  &lt;arg name=&quot;viz_config_file&quot; value =&quot;$(find-pkg-share demos)/include/office/office.rviz&quot;/&gt;
  &lt;arg name=&quot;config_file&quot; value=&quot;$(find-pkg-share rmf_demo_maps)/office/office.building.yaml&quot;/&gt;
&lt;/include&gt;
</code></pre>
<p>The next set of commands in <code>office.launch.xml</code> load the <code>office.world</code> in <code>Gazebo</code> after updating the relevant environment variables with paths to the models, plugins and resources directories.</p>
<pre><code class="language-xml">  &lt;group&gt;
    &lt;let name=&quot;world_path&quot; value=&quot;$(find-pkg-share rmf_demo_maps)/maps/office/office.world&quot; /&gt;
    &lt;let name=&quot;model_path&quot; value=&quot;$(find-pkg-share rmf_demo_maps)/maps/office/models:$(find-pkg-share rmf_demo_assets)/models:/usr/share/gazebo-9/models&quot; /&gt;
    &lt;let name=&quot;resource_path&quot; value=&quot;$(find-pkg-share rmf_demo_assets):/usr/share/gazebo-9&quot; /&gt;
    &lt;let name=&quot;plugin_path&quot; value=&quot;$(find-pkg-prefix rmf_gazebo_plugins)/lib:$(find-pkg-prefix building_gazebo_plugins)/lib&quot; /&gt;

    &lt;executable cmd=&quot;gzserver --verbose -s libgazebo_ros_factory.so -s libgazebo_ros_init.so $(var world_path)&quot; output=&quot;both&quot;&gt;
      &lt;env name=&quot;GAZEBO_MODEL_PATH&quot; value=&quot;$(var model_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_RESOURCE_PATH&quot; value=&quot;$(var resource_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_PLUGIN_PATH&quot; value=&quot;$(var plugin_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_MODEL_DATABASE_URI&quot; value=&quot;&quot; /&gt;
    &lt;/executable&gt;
    &lt;executable cmd=&quot;gzclient --verbose $(var world_path)&quot; output=&quot;both&quot;&gt;
      &lt;env name=&quot;GAZEBO_MODEL_PATH&quot; value=&quot;$(var model_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_RESOURCE_PATH&quot; value=&quot;$(var resource_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_PLUGIN_PATH&quot; value=&quot;$(var plugin_path)&quot; /&gt;
    &lt;/executable&gt;
  &lt;/group&gt;
</code></pre>
<p>Lastly, instances of the &quot;full control&quot; <code>rmf_fleet_adapter</code> are launched for each robot type annotated in the map. The navigation graphs for each fleet as generated by the <code>building_map_generator</code> script is passed via the <code>nav_graph_file</code> argument. For the office map, a single fleet of <code>Magni</code> robots is defined. Hence, a single <code>magni_adapter.launch.xml</code> file configured with the kinematic properties of this robot type along with spatial thresholds used for planning, is launched. Along with the fleet adapter, a <code>robot_state_aggregator</code> node is started. This node aggregates <code>RobotState</code> messages with <code>RobotState.name</code> containing the <code>robot_prefix</code> argument and publishes the aggregate to <code>/fleet_states</code> with <code>FleetState.name</code> specified by the <code>fleet_name</code> argument.</p>
<pre><code class="language-xml">&lt;group&gt;
  &lt;let name=&quot;fleet_name&quot; value=&quot;magni&quot;/&gt;
  &lt;include file=&quot;$(find-pkg-share demos)/include/adapters/magni_adapter.launch.xml&quot;&gt;
    &lt;arg name=&quot;fleet_name&quot; value=&quot;$(var fleet_name)&quot;/&gt;
    &lt;arg name=&quot;use_sim_time&quot; value=&quot;$(var use_sim_time)&quot;/&gt;
    &lt;arg name=&quot;nav_graph_file&quot; value=&quot;$(find-pkg-share rmf_demo_maps)/maps/office/nav_graphs/0.yaml&quot; /&gt;
  &lt;/include&gt;
  &lt;include file=&quot;$(find-pkg-share rmf_fleet_adapter)/robot_state_aggregator.launch.xml&quot;&gt;
    &lt;arg name=&quot;robot_prefix&quot; value=&quot;magni&quot;/&gt;
    &lt;arg name=&quot;fleet_name&quot; value=&quot;$(var fleet_name)&quot;/&gt;
    &lt;arg name=&quot;use_sim_time&quot; value=&quot;true&quot;/&gt;
  &lt;/include&gt;
&lt;/group&gt;
</code></pre>
<p>When testing RMF with hardware, the same launch files can be used with noted exception of not starting <code>Gazebo</code>. More information on running demos with hardware can be found <a href="hardware.html">here</a>.</p>
<h4><a class="header" href="#task-requests" id="task-requests">Task Requests</a></h4>
<p>With the office world launched, robots may be issued tasks to carry out. At present, the rmf_fleet_adapters are designed to fulfil two classes of tasks: 1) <code>Loop</code> requests where a robot is requested to loop between two waypoints and 2) <code>Delivery</code> requests which requires a robot to pick up a payload from a dispenser and drop it off at an unloading station. The <code>rmf_fleet_adapters</code> listen for <code>Loop</code> and <code>Delivery</code> request <a href="https://github.com/osrf/rmf_core/tree/master/rmf_task_msgs/msg">messages</a> published over <code>/loop_requests</code> and <code>delivery_requests</code> topics respectively and assign the task to an available robot in their fleet.</p>
<p>Note: the <code>perform_deliveries</code> parameter in the fleet adapter launch file must be set <code>true</code> to enable the given fleet to perform delivery requests. In the current version it is advised to have only one fleet of robots capable of fulfilling delivery requests as a &quot;task allocator&quot; is yet to be implemented.</p>
<p>The <code>rmf_demo_tasks</code> package is created with two executables, <code>request_loop.py</code> and <code>request_delivery.py</code>, which populate and publish <code>Loop</code> and <code>Delivery</code> messages with supplied arguments. Their usages are shown below. The <code>ROBOT_TYPE</code> argument in both cases should match the <code>FleetState.name</code> of the fleet to be assigned the task. For <code>request_loop</code> the <code>START</code> and <code>FINISH</code> arguments should contain valid waypoint names from the navigation graph while <code>NUM</code> specifies the number of loops between these waypoints. For <code>request_delivery</code>, the <code>PICKUP</code> and <code>DROPOFF</code> arguments must be valid waypoint names with <code>workcell_name</code> fields specified in the <code>traffic_editor</code>. </p>
<pre><code class="language-bash">ros2 run rmf_demo_tasks request_loop -h
usage: request_loop [-h] [-s START] [-f FINISH] [-n NUM] [-i TASK_ID]
                    [-r ROBOT_TYPE]

ros2 run rmf_demo_tasks request_delivery -h
usage: request_delivery [-h] [-p PICKUP] [-d DROPOFF] [-i TASK_ID]
                        [-r ROBOT_TYPE]
</code></pre>
<p>As an alternative, UIs may be developed to send out these requests. More information can be found in the <a href="ui.html">UI</a> chapter. The <code>rmf_demos</code> repository contains a <code>rmf_rviz_plugin</code> package which defines a custom Panel that can be used to send the above commands from RViz. A snapshot of the same is seen below.</p>
<p><img src="images/rmf_panel.png" alt="" /></p>
<h1><a class="header" href="#rmf-core" id="rmf-core">rmf-core</a></h1>
<p>RMF is an umbrella term for a wide range of open specifications and software
tools that aim to ease the integration and interoperability of robotic systems,
building infrastructure, and user interfaces. <code>rmf_core</code> is an implementation
of some of these core scheduling and traffic management systems.</p>
<p>Avoiding mobile robot traffic conflicts is a key functionality of <code>rmf_core</code>.
There are two levels to traffic deconfliction: (1) prevention, and (2)
resolution.</p>
<p><em>Prevention:</em> Whenever possible, it would be good to prevent traffic conflicts
from happening in the first place. To facilitate this, we have implemented a
platform agnostic Traffic Schedule Database. The traffic schedule is a living
database whose contents will change over time to reflect delays, cancelations,
or route changes. All fleet managers that are integrated into RoMi-H must
report the expected itineraries of their vehicles to the traffic schedule. With
the information available on the schedule, compliant fleet managers can plan
routes for their vehicles that avoid conflicts with any other vehicles, no
matter which fleet they belong to. <code>rmf_traffic</code> provides a Planner class to
help facilitate this for vehicles that behave like standard AGVs. In the future
we intend to provide a similar utility for AMRs.</p>
<p><em>Resolution:</em> It is not always possible to perfectly prevent traffic conflicts.
Mobile robots may experience delays because of unanticipated obstacles in their
environment, or the predicted schedule may be flawed for any number of reasons.
In cases where a conflict does arise, <code>rmf_traffic</code> has a Negotiation scheme.
When the Traffic Schedule Database detects an upcoming conflict between two or
more schedule participants, it will send a conflict notice out to the relevant
fleet managers, and a negotiation between the fleet managers will begin. Each
fleet manager will submit its preferred itineraries, and each will respond with
itineraries that can accommodate the others. A third-party judge (deployed by
the system integrator) will choose the set of proposals that is considered
preferable and notify the fleet managers about which itineraries they should
follow.</p>
<h2><a class="header" href="#schedules" id="schedules">Schedules</a></h2>
<p>The schedule is a centralized database of all the intended robot traffic
trajectories in a facility. Note that it's the intended trajectories, so it's
looking into the future. The job of the schedule is to identify conflicts in
the intentions of the different robot fleets and notify the fleets when a
conflict is noticed. It will also facilitate a procedure for the fleets to
automatically resolve their conflict. If no resolution is found in a reasonable
time, the conflict may be escalated to the attention of a human operator.</p>
<h2><a class="header" href="#frequently-asked-questions" id="frequently-asked-questions">Frequently Asked Questions</a></h2>
<h4><a class="header" href="#why-is-this-traffic-management-system-so-complicated" id="why-is-this-traffic-management-system-so-complicated">Why is this traffic management system so complicated?</a></h4>
<p>RMF has a number of system design constraints that create unique challenges for
traffic management. The core goal of RMF is to facilitate system integration
for heterogeneous mobile robot fleets that may be provided by different vendors
and may have different technical capabilities.</p>
<p>Vendors tend to want to keep their computing systems independent from other
vendors. Since vendors are often responsible for ensuring uptime and
reliability on their computing infrastructure, they may view it as an
unacceptable liability to share computing resources with another vendor. This
means that the traffic management system must be able to function while being
distributed across different machines on a network.</p>
<p>Different robot platforms may have different capabilities. Many valuable AGV
platforms that are currently deployed are not able to change their itineraries
dynamically. Some AGV platforms can change course when instructed to, as long
as they stick to a predefined navigation graph. Some AMR platforms can
dynamically navigate themselves around unanticipated obstacles in their
environment. Since RMF is meant to be an enabling technology, it is important
that we design a system that can maximize the utility of all these different
types of systems without placing detrimental constraints on any of them.</p>
<p>These considerations led to the current design of distributed conflict
prevention and distributed schedule negotiation. There is plenty of space
within the design to create simpler and more efficient subsets for categories
of mobile robots that fit certain sets of requirements, but these optimizations
can be added later, building on top of the existing completely generalized
framework.</p>
<h4><a class="header" href="#who-opens-and-closes-doors-and-operates-the-lifts-the-robot-or-rmf-or-both" id="who-opens-and-closes-doors-and-operates-the-lifts-the-robot-or-rmf-or-both">Who opens and closes doors and operates the lifts? The robot or RMF? Or both?</a></h4>
<p>The responsibility of knowing when a door needs to be opened and then sending
the command to open it belongs to the &quot;fleet adapter&quot;. The basic design is:</p>
<ul>
<li>The fleet adapter keeps track of the robot's progress</li>
<li>When the robot needs to go through a door, the fleet adapter will recognize this</li>
<li>The fleet adapter will send a signal to the door to open</li>
<li>Once the door is open, the fleet adapter will command the robot to proceed</li>
<li>Once the robot is through the door, the fleet adapter will command the robot wait until the door is closed</li>
<li>The fleet adapter will command the door to close</li>
<li>Once the door is closed, the fleet adapter will command the robot to proceed</li>
</ul>
<p>The way a fleet adapter knows about the doors is by parsing the navigation
graph that is provided to it. The navigation graph is a required parameter for
the <code>full_control</code> type of fleet adapter. <code>rmf_demos</code> shows an example of
providing a navigation graph to the fleet adapter.</p>
<p>The recommended way to construct a navigation graph is to use the
<code>traffic-editor</code> tool. The <code>rmf_demos</code> repos shows some examples of
<code>traffic-editor</code> project files.</p>
<p>However, it's entirely possible to construct your own navigation graphs. They
use a very simple yaml format.</p>
<h4><a class="header" href="#are-lifts-supported" id="are-lifts-supported">Are lifts supported?</a></h4>
<p>Proper lift support (meaning, specifying an actual lift that can move between
floors, and exporting that information into the navigation graph) is not
something that has been developed yet due to time constraints and the need to
prioritize certain features over others.</p>
<p>However, for testing and demonstration purposes, there are two special
navigation graph edge properties that can allow a RMF fleet adapter to emulate
lift usage. This is meant for demo scenarios where a &quot;mock lift&quot; has been
created that receives lift commands and transmits lift states but does not
actually move between any different floors in a building. For example, tape
on the floor of a lab to indicate the &quot;lift cabin&quot; box, to allow development
and testing without occupying the actual building lift.</p>
<p>These properties were initially included for demonstration purposes, but they
are proving useful enough that we might make them officially supported
properties. Due to the cost and scarcity of &quot;real&quot; lifts, there seems to be
broad interest in having single-floor hardware test setups that emulate
multi-floor scenarios.</p>
<p>The edge properties are:</p>
<ul>
<li><code>demo_mock_floor_name</code>: The name of the floor that the robot is on while traversing the edge</li>
<li><code>demo_mock_lift_name</code>: The name of the lift that is being entered or exited while the robot traverses the edge</li>
</ul>
<p>The idea is that if you have a single floor demonstration environment but want
to demonstrate interaction with a lift, then you can set up a mock &quot;lift&quot; and
imagine that each side of the &quot;lift&quot; opens to a different floor, and the robot
is only allowed to enter/exit that side of the &quot;lift&quot; when the &quot;lift&quot; believes
it is on that floor. This emulates lift cabins with two sets of doors.</p>
<p>To make this idea more concrete, imagine you have a single-floor hardware
testing area, and a box is drawn on the ground with an LED display next to it
that reads off pretend floor names. The mock lift will transmit lift state
messages that match up with whatever floor the LED is displaying. There is also
some indication of whether the lift doors are open or closed. You can further
imagine that entering or exiting from west side of the &quot;lift&quot; is only allowed
when the lift believes it is on floor L1 whereas entering or exiting the &quot;lift&quot;
from the east side is only allowed when it believes it is on floor L3.</p>
<p>In that setup, for a robot to &quot;correctly&quot; navigate from a waypoint on L1 to a
waypoint on L3, the robot needs to:</p>
<ul>
<li>Approach the &quot;lift&quot; from the west side</li>
<li>Call the &quot;lift&quot; down to L1</li>
<li>Wait until the lift state has it on floor L1 with the doors open</li>
<li>Move into the &quot;lift&quot; (i.e. the box drawn on the ground) and request that it &quot;moves&quot; to L3</li>
<li>Wait until the &quot;lift&quot; indicates that it has reached L3 and that its doors are open</li>
<li>Exit the &quot;lift&quot; on the east side</li>
</ul>
<p>A rough ASCII diagram would look like this (numbers are waypoints and letters
are edges):</p>
<p><code>1 &lt;---a---&gt; 2 &lt;---b---&gt; 3</code></p>
<ul>
<li>Waypoint 1 is on floor L1</li>
<li>Waypoint 2 is inside the &quot;lift&quot; named LIFT001</li>
<li>Waypoint 3 is on floor L3</li>
<li>The properties of edge a are:
<ul>
<li>bidirectional: true</li>
<li>demo_mock_floor_name: L1</li>
<li>demo_mock_lift_name: LIFT001</li>
</ul>
</li>
<li>The properties of edge b are:
<ul>
<li>bidirectional: true</li>
<li>demo_mock_floor_name: L3</li>
<li>demo_mock_lift_name: LIFT001</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#if-multiple-fleets-can-do-the-same-task-which-one-is-one-chosen" id="if-multiple-fleets-can-do-the-same-task-which-one-is-one-chosen">If multiple fleets can do the same task, which one is one chosen?</a></h4>
<p>It's not implemented yet, but there's a design worked out for a bidding system
where a task request will be converted to a bid request. The bid request will
be sent to each fleet adapter, and each fleet adapter that can perform the task
will report its best estimate for how soon it would be able to have the task
finished. The fleet adapter that offers the lowest bid will be assigned the
task.</p>
<p>The API and implementation for this is on the backburner right now as we
finalize some of the more critical components.</p>
<h4><a class="header" href="#can-some-robots-have-priority-over-other-robots" id="can-some-robots-have-priority-over-other-robots">Can some robots have priority over other robots?</a></h4>
<p>The negotiation system concept does support prioritization for which robot will
accommodate the other robot(s). Any arbitrary metric or weighting system can be
used when resolving a negotiation. But in the current implementation that we
are using, we are treating all vehicles as equal and choosing the resolution
that minimizes the net delay across all the robots, without any prioritization
or weighting.</p>
<p>Since this codebase is open source, you can easily fork the code and modify it
to use any prioritization system that you'd like. Specifically, replace
<code>rmf_traffic::schedule::QuickestFinishEvaluator()</code> your own
<code>Negotiation::Evaluator</code> class that behaves in whatever way you would like.</p>
<h4><a class="header" href="#what-distance-is-maintained-between-two-robots" id="what-distance-is-maintained-between-two-robots">What distance is maintained between two robots?</a></h4>
<p>This is configurable. There are two relevant parameters: <code>footprint_radius</code> and
<code>vicinity_radius</code>. The <code>footprint_radius</code> represents an estimate of the
vehicle's physical footprint. The <code>vicinity_radius</code> represents an estimate of
the region which the robot needs other vehicles to stay clear of. A &quot;schedule
conflict&quot; is defined as an instance where one vehicle's &quot;footprint&quot; is
scheduled to enter another vehicle's &quot;vicinity&quot;. The job of the negotiation
system is to come up with a fix to the schedule that keeps all vehicles'
&quot;footprints&quot; out of all other vehicles' &quot;vicinities&quot;.</p>
<h1><a class="header" href="#soss" id="soss">SOSS</a></h1>
<p>The system-of-systems synthesizer (SOSS) is a tool which provides protocol
translation between different subsystems. Currently, ROS 2, ROS 1, and
Websockets are supported. Such composite systems can be called The ROS-SOSS.</p>
<!-- # Requirements -->
<!-- robot, door, lift, workcell, etc. integration with RMF

    I have a door door
    I have an elevator / I have a lift arrow_up_down
    I have a workcell robot mechanical_arm
    I have a loose mobile robot and would like to use FreeFleet (F5)
        robot runs ROS 1
        robot runs ROS 2
        robot runs something that I wrote
        robot runs something somebody else wrote and I can't change
    I have some mobile robots with their own fleet manager(s)
        it has a REST API or some other formal API (XMLRPC)
        it has some other communication mechanism (SQL database, etc.) -->
<h1><a class="header" href="#hardware" id="hardware">Hardware</a></h1>
<p>In this chapter, we will describe the integration requirements and basic steps to have hardware working with RMF. These include <a href="hardware.html#mobile-robots">mobile robots</a>, <a href="hardware.html#doors">doors</a>, <a href="hardware.html#elevators">elevators</a> and <a href="hardware.html#workcells">workcells</a>. In each section, we will go through how to build the necessary ROS 2 packages and interfaces that are used by <code>rmf_core</code>, as well as possible scenarios where such interactions occur.</p>
<p>In general, all the interactions can be summed up with this system architecture diagram,</p>
<img src="https://raw.githubusercontent.com/osrf/rmf_core/master/docs/rmf_core_integration_diagram.png">
<p>RMF uses ROS 2 messages and topic interfaces. Hence, in most cases we use components called Adapters to bridge between the hardware interfaces and RMF with some exception for robot fleets which also have fleet drivers as part of the process. Robot fleets will be further elaborated in the next few sections.</p>
<h2><a class="header" href="#mobile-robots" id="mobile-robots">Mobile Robots</a></h2>
<p>We have identified a number of different scenarios where mobile robots are integrated with RMF, though preliminary focus and use cases have involved delivery service mobile robots. In this section, we will be addressing each scenario or configuration and how users can go about working with them.</p>
<p>Before all that, let us revisit the diagram and description in the <a href="hardware.html#hardware">hardware introduction section</a>. Fleet adapters serve as a bridge between the mobile robot fleet and RMF. However, an additional level of complexity also exists to address traffic monitoring, scheduling and conflict resolution between the multitude of robots and robot fleets throughout the environment. Fleet drivers are then necessary to interact with the mobile robots/fleets in order to update the adapters and relay commands via simple ROS 2 message and topic interfaces. More information about how fleet adapters work can be found in Chapter 5, rmf-core.</p>
<h3><a class="header" href="#map-data-requirements-for-integration-with-rmf" id="map-data-requirements-for-integration-with-rmf">Map data requirements for integration with RMF</a></h3>
<h4><a class="header" href="#motivation-1" id="motivation-1">Motivation</a></h4>
<p>RMF uses robot route maps to predict the navigation paths of robots working in the environment. RMF generates path predictions for all active robots in the environment which can be used to proactively avoid conflicts between the various robot path plans. This is often referred to as &quot;traffic monitoring&quot; in RMF. Along with the traffic monitoring, RMF can help enable multi-fleet visualization to building/robot operations staff, improve scheduling of resources (such as lifts and corridors), reduce robot deadlock and more.</p>
<p>Robot route maps in large buildings are complex and may evolve over time in response to customer requests and building renovations. As a result, RMF works best when scripts can automatically import robot route maps, and re-import them in the future after changes are made.</p>
<h4><a class="header" href="#minimum-map-information-required" id="minimum-map-information-required">Minimum Map Information Required</a></h4>
<ul>
<li>list of waypoints or nodes
<ul>
<li>name of waypoint</li>
<li>level name (B1, L1, L2, etc.)</li>
<li>(x, y) location in meters within the level</li>
<li>any special properties or flags, such as:
<ul>
<li>is this a dropoff/pickup parking point?</li>
<li>is this a charger?</li>
<li>is this a safe parking spot during an emergency alarm?</li>
</ul>
</li>
</ul>
</li>
<li>list of edges or &quot;travel lanes&quot; between nodes
<ul>
<li>(start, end) waypoint names</li>
<li>two-way or one-way traffic?
<ul>
<li>if one-way, identify direction of travel</li>
</ul>
</li>
<li>any other information, such as speed limit along this segment</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#format-requirements" id="format-requirements">Format requirements</a></h4>
<p>We can write import scripts to handle virtually any &quot;open&quot; file format that contains the required information. This includes, in order of preference:</p>
<ul>
<li>YAML</li>
<li>XML</li>
<li>plain text (space or comma-separated ASCII, etc.)</li>
<li>DXF</li>
<li>DWG</li>
<li>SVG</li>
</ul>
<h2><a class="header" href="#comments" id="comments">Comments</a></h2>
<p>If the map data is provided in textual form, screenshots are helpful for &quot;sanity-checking&quot; the coordinate system and alignment with building features.</p>
<h3><a class="header" href="#mobile-robot-fleets" id="mobile-robot-fleets">Mobile Robot Fleets</a></h3>
<p>Mobile robots in production settings are often controlled and monitored as a fleet, with a central fleet management system keeping things in check. For this configuration, we will focus on how we can integrate mobile robots with RMF using a Fleet Adapter to control and communicate with the mobile robots via their respective fleet manager.</p>
<p>We have identified 4 different levels of control when working with fleets of mobile robots, namely,</p>
<ul>
<li>
<p><strong>Path</strong> - RMF is provided with status and full control over the paths that each individual mobile robot uses when navigating through the environment. This control level provides the highest overall efficiency and compliance with RMF, which allows RMF to reduce stoppages and deal with unexpected scenarios gracefully.</p>
</li>
<li>
<p><strong>Traffic Light</strong> - RMF is given the status as well as pause/resume control over each mobile robot, which is useful for deconflicting traffic schedules especially when sharing resources like corridors, lifts and doors.</p>
</li>
<li>
<p><strong>Read Only</strong> - RMF is not given any control over the mobile robots, however is provided with regular status updates. This will allow other mobile robot fleets with higher control levels to avoid conflicts with this fleet. <em>Note that any environment can have a maximum of one &quot;Read Only&quot; fleet in operation. Having none is ideal!</em></p>
</li>
<li>
<p><strong>No Control</strong> - This will prevent other fleets to coordinate with it through RMF, and will likely cause deadlocks when sharing the same navigable environment or resource. This level will not function with an RMF-enabled environment.</p>
</li>
</ul>
<p>In short, the more collaborative a fleet is with RMF, the more harmoniously all of the fleets and systems are able to operate together. Note again that there can only ever be one &quot;Read Only&quot; fleet in an environment, as any two or more of such fleets will make avoiding deadlock or resource conflict nearly impossible.</p>
<p>After identifying the level of control the fleet can provide, users can select to use the basic fleet adapters labelled by their control level, that have been implemented within the <code>rmf_core</code> repository. These fleet adapters are designed to work seamlessly with RMF, requiring the users simply set up a list of parameters during launch. Below is an example of the parameters required for launching a Path level fleet adapter:</p>
<pre><code class="language-xml">&lt;include file=&quot;$(find-pkg-share rmf_fleet_adapter)/fleet_adapter.launch.xml&quot;&gt;

  &lt;!-- The name and control type of the fleet --&gt;
  &lt;arg name=&quot;fleet_name&quot; value=&quot;$(var fleet_name)&quot;/&gt;
  &lt;arg name=&quot;control_type&quot; value=&quot;full_control&quot;/&gt;

  &lt;!-- The graph that this fleet should use for navigation --&gt;
  &lt;arg name=&quot;nav_graph_file&quot; value=&quot;$(var nav_graph_file)&quot; /&gt;

  &lt;!-- The nominal linear and angular velocity of this fleet's vehicles --&gt;
  &lt;arg name=&quot;linear_velocity&quot; value=&quot;0.5&quot;/&gt;
  &lt;arg name=&quot;angular_velocity&quot; value=&quot;0.4&quot;/&gt;

  &lt;!-- The nominal linear and angular acceleration of this fleet's vehicles --&gt;
  &lt;arg name=&quot;linear_acceleration&quot; value=&quot;0.3&quot;/&gt;
  &lt;arg name=&quot;angular_acceleration&quot; value=&quot;1.0&quot;/&gt;

  &lt;!-- The radius of the circular footprint of this fleet's vehicles --&gt;
  &lt;arg name=&quot;footprint_radius&quot; value=&quot;0.6&quot;/&gt;
  &lt;!-- Other robots are not allowed within this radius --&gt; 
  &lt;arg name=&quot;vicinity_radius&quot; value=&quot;2.0&quot;/&gt;

  &lt;!-- Whether to use sim time --&gt;
  &lt;arg name=&quot;use_sim_time&quot; value=&quot;$(var use_sim_time)&quot;/&gt;

  &lt;!-- How long it can be delayed before we give up and start over --&gt;
  &lt;arg name=&quot;delay_threshold&quot; value=&quot;15.0&quot;/&gt;

  &lt;!-- Don't make the mir wait long to retry --&gt;
  &lt;arg name=&quot;retry_wait&quot; value=&quot;10.0&quot;/&gt;

  &lt;!-- Give everything time to discover --&gt;
  &lt;arg name=&quot;discovery_timeout&quot; value=&quot;60.0&quot;/&gt;

  &lt;!-- Whether it can perform deliveries --&gt;
  &lt;arg name=&quot;perform_deliveries&quot; value=&quot;true&quot;/&gt;

&lt;/include&gt;
</code></pre>
<p>This exact launch file can be found in the <code>rmf_demos</code> <a href="https://github.com/osrf/rmf_demos">repository</a>, while the variable <code>nav_graph_file</code> describes the path to a navigation graph file that was either generated by <code>building_map_tools</code> or in a similar format. The graph describes the various traversable waypoints and lanes for the particular mobile robot fleet. The other parameters listed are used by RMF to make estimations and predictions of the movements of each mobile robot within this fleet, in order to predict potential conflicts between mobile robots, re-plan and resolve them before they can occur.</p>
<p>The final piece of the puzzle is the Fleet Driver, which interacts with the Fleet Adapter over ROS 2 messages, while at the same time using the fleet manager's API to directly obtain status updates and relay commands to each mobile robot. Fleet Drivers for various fleets are expected to have unique implementations as required by their specific API which could be based on <code>REST</code>, <code>XMLRPC</code>, <code>SQL</code> databases, or other approaches. Users implementing their own Fleet Drivers will need to communicate with the Fleet Adapters using these standardized ROS 2 messages and topics listed in the table below:</p>
<table><thead><tr><th>Message Types</th><th>ROS2 Topic</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rmf_fleet_msgs/ModeRequest</code></td><td><code>/robot_mode_requests</code></td><td>Allows RMF to give pause/resume and emergency commands.</td></tr>
<tr><td><code>rmf_fleet_msgs/PathRequest</code></td><td><code>/robot_path_requests</code></td><td>Allows full control over the path which mobile robots use during navigation, provided in the form of a list of waypoints.</td></tr>
<tr><td><code>rmf_fleet_msgs/DestinationRequest</code></td><td><code>/destination_requests</code></td><td>Gives mobile robots a one-way command to a certain location/waypoint.</td></tr>
<tr><td><code>rmf_fleet_msgs/FleetState</code></td><td><code>/fleet_states</code></td><td>Provides RMF with fleet and mobile robot status updates, including the their locations, as well as their current path and task information.</td></tr>
</tbody></table>
<p>(** These messages and topics are referenced from the code-base, it might not be the most up-to-date)</p>
<p>The block diagram below shows an example implementation using a fleet of MiR100™ mobile robots, with a Path Fleet Adapter. On one end the Fleet Driver uses the ROS 2 message and topic interfaces to interact with the Fleet Adapter, while on the other end it uses the REST API that comes with the MiR100™ robots to communicate and control each mobile robot.</p>
<img src="images/hardware_mir_fleet_driver_blocks.png">
<p>If however the user wishes to add more complexity to his or her fleet's behavior, the Fleet Adapter and Fleet Drivers can be implemented from scratch using the API provided in the <code>rmf_core</code> <a href="https://github.com/osrf/rmf_core">repository</a>. In this scenario, the user can opt for implementing both the adapter and driver into a single module, without the need to use ROS 2 topic and messages between them.</p>
<h3><a class="header" href="#free-fleet" id="free-fleet">Free Fleet</a></h3>
<p>In the event that the user wishes to integrate a standalone mobile robot which doesn't come with its own fleet management system, the open source fleet management system <code>free_fleet</code> could be used. </p>
<p><code>free_fleet</code> can be split into a client and a server. The client is to be run on each of these standalone mobile robots alongside their navigation software and is intended to have direct control over the mobile robot while at the same time monitor its status and reported back to the server. The client's base implementation is designed to allow interaction with different configurations of mobile robots yet report to the same server. This way, users are able to use <code>free_fleet</code> to manage a heterogenrous fleet of robots, each using different distributions of ROS, versions of ROS, navigation software, or onboard communication protocols.</p>
<p>The server is run on a central computer and consolidates the incoming status updates from each client to be either visualized using a UI, or relayed upstream to RMF. The server also relays commands from the user via the UI or RMF down to the clients to be executed. Each server can work with multiple clients at a time, hence it serves the role as a fleet management system. The server can be implemented and used as its own fleet management system or work with larger systems like RMF, bridging the gap between each mobile robot's API and RMF's API and interface.</p>
<p>The communication between the <code>free_fleet</code> server and <code>free_fleet</code> clients is implemented using <code>CycloneDDS</code>, therefore we are not concerned if the mobile robot or central computer is running different versions of ROS.</p>
<p>In this section, we will address 4 different approaches of using <code>free_fleet</code> to integrate with RMF, specifically the navigation stack used by the robot. Each approach maintains a similar systems architecture, which is illustrated in the simple block diagram below, but there are specific examples depending on the software choice for the navigation stack used by the robot developer.</p>
<img src="images/free_fleet_block_diagram.png">
<h4><a class="header" href="#ros-1-navigation-stack" id="ros-1-navigation-stack">ROS 1 Navigation Stack</a></h4>
<p>An implementation of a <code>free_fleet</code> client that works with a ROS 1 navigation stack can be found in the <a href="https://github.com/osrf/free_fleet">repository</a>. The implementation expects the transforms of the mobile robot to be fully defined, the mobile robot to accept navigation commands via the <code>move_base</code> action library, as well as publishing its battery status published using the <code>sensor_msgs/BatteryState</code> message.</p>
<p>After following the build instructions on the README on the mobile robot, the user can launch the client as part of their launch script while at the same time define the necessary parameters using <code>rosparam</code>. Below is a small snippet example of how a client can be launched, with its paramters defined,</p>
<pre><code class="language-xml">&lt;node name=&quot;free_fleet_client_node&quot; 
    pkg=&quot;free_fleet_client_ros1&quot;
    type=&quot;free_fleet_client_ros1&quot; output=&quot;screen&quot;&gt;

  &lt;!-- These parameters will be used to identify the mobile robots --&gt;
  &lt;param name=&quot;fleet_name&quot; type=&quot;string&quot; value=&quot;example_fleet&quot;/&gt;
  &lt;param name=&quot;robot_name&quot; type=&quot;string&quot; value=&quot;example_bot&quot;/&gt;
  &lt;param name=&quot;robot_model&quot; type=&quot;string&quot; value=&quot;Turtlebot3&quot;/&gt;

  &lt;!-- These are the topics required to get battery and level information --&gt;
  &lt;param name=&quot;battery_state_topic&quot; type=&quot;string&quot; value=&quot;example_bot/battery_state&quot;/&gt;
  &lt;param name=&quot;level_name_topic&quot; type=&quot;string&quot; value=&quot;example_bot/level_name&quot;/&gt;

  &lt;!-- These frames will be used to update the mobile robot's location --&gt;
  &lt;param name=&quot;map_frame&quot; type=&quot;string&quot; value=&quot;example_bot/map&quot;/&gt;
  &lt;param name=&quot;robot_frame&quot; type=&quot;string&quot; value=&quot;example_bot/base_footprint&quot;/&gt;

  &lt;!-- The name of the move_base server for actions --&gt;
  &lt;param name=&quot;move_base_server_name&quot; type=&quot;string&quot; value=&quot;example_bot/move_base&quot;/&gt;

  &lt;!-- These are DDS configurations used between Free Fleet clients and servers --&gt;
  &lt;param name=&quot;dds_domain&quot; type=&quot;int&quot; value=&quot;42&quot;/&gt;
  &lt;param name=&quot;dds_state_topic&quot; type=&quot;string&quot; value=&quot;robot_state&quot;/&gt;
  &lt;param name=&quot;dds_mode_request_topic&quot; type=&quot;string&quot; value=&quot;mode_request&quot;/&gt;
  &lt;param name=&quot;dds_path_request_topic&quot; type=&quot;string&quot; value=&quot;path_request&quot;/&gt;
  &lt;param name=&quot;dds_destination_request_topic&quot; type=&quot;string&quot; value=&quot;destination_request&quot;/&gt;
  
  &lt;!-- This decides how long the client should wait for a valid transform and action server before failing --&gt;
  &lt;param name=&quot;wait_timeout&quot; type=&quot;double&quot; value=&quot;10&quot;/&gt;
  
  &lt;!-- These define the frequency at which the client checks for commands and 
  publishes the robot state to the server --&gt;
  &lt;param name=&quot;update_frequency&quot; type=&quot;double&quot; value=&quot;10.0&quot;/&gt;
  &lt;param name=&quot;publish_frequency&quot; type=&quot;double&quot; value=&quot;1.0&quot;/&gt;

  &lt;!-- The client will only pass on navigation commands if the destination or first waypoint 
  of the path is within this distance away, otherwise it will ignore the command --&gt;
  &lt;param name=&quot;max_dist_to_first_waypoint&quot; type=&quot;double&quot; value=&quot;10.0&quot;/&gt;

&lt;/node&gt;
</code></pre>
<p>The running <code>free_fleet</code> client will communicate with the nodes running on the robot via ROS 1, while publishing its state and subscribing to requests over DDS with the <code>free_fleet</code> Server.</p>
<p>The current implementation of the <code>free_fleet</code> server is implemented with ROS 2 and communicates with RMF using the aforementioned ROS 2 message and topic interfaces of an RMF fleet adapter. The ROS 2 build instructions can also be found on the same repository. Similar to the client, a simple ROS2 wrapper has been implemented, and it can be started using a <code>.launch.xml</code> file like so,</p>
<pre><code class="language-xml">&lt;node pkg=&quot;free_fleet_server_ros2&quot;
    exec=&quot;free_fleet_server_ros2&quot;
    name=&quot;free_fleet_server_node&quot;
    node-name=&quot;free_fleet_server_node&quot;
    output=&quot;both&quot;&gt;

  &lt;!-- Fleet name will be used to identify robots --&gt;
  &lt;param name=&quot;fleet_name&quot; value=&quot;example_fleet&quot;/&gt;

  &lt;!-- These are the ROS2 topic names that will be used to communicate with RMF --&gt;
  &lt;param name=&quot;fleet_state_topic&quot; value=&quot;fleet_states&quot;/&gt;
  &lt;param name=&quot;mode_request_topic&quot; value=&quot;robot_mode_requests&quot;/&gt;
  &lt;param name=&quot;path_request_topic&quot; value=&quot;robot_path_requests&quot;/&gt;
  &lt;param name=&quot;destination_request_topic&quot; value=&quot;robot_destination_requests&quot;/&gt;

  &lt;!-- These are the DDS specific configurations used to communicate with the clients --&gt;
  &lt;param name=&quot;dds_domain&quot; value=&quot;42&quot;/&gt;
  &lt;param name=&quot;dds_robot_state_topic&quot; value=&quot;robot_state&quot;/&gt;
  &lt;param name=&quot;dds_mode_request_topic&quot; value=&quot;mode_request&quot;/&gt;
  &lt;param name=&quot;dds_path_request_topic&quot; value=&quot;path_request&quot;/&gt;
  &lt;param name=&quot;dds_destination_request_topic&quot; value=&quot;destination_request&quot;/&gt;

  &lt;!-- This determines the frequency it checks for incoming state and request messages,
  as well as how often it publishes its fleet state to RMF --&gt;
  &lt;param name=&quot;update_state_frequency&quot; value=&quot;20.0&quot;/&gt;
  &lt;param name=&quot;publish_state_frequency&quot; value=&quot;2.0&quot;/&gt;

  &lt;!-- These transformations are required when the frame of the robot fleet is
  different from that of RMF globally. In order to transform a pose from the RMF
  frame to the free fleet robot frame, it is first scaled, rotated, then 
  translated using these parameters --&gt;
  &lt;param name=&quot;scale&quot; value=&quot;0.928&quot;/&gt;
  &lt;param name=&quot;rotation&quot; value=&quot;-0.013&quot;/&gt;
  &lt;param name=&quot;translation_x&quot; value=&quot;-4.117&quot;/&gt;
  &lt;param name=&quot;translation_y&quot; value=&quot;27.26&quot;/&gt;

&lt;/node&gt;
</code></pre>
<p>Furthermore, an example of this configuration can be found in the repository as well, under the packages <code>ff_examples_ros1</code> and <code>ff_exmaples_ros2</code>. This example launches the example simulation from <code>ROBOTIS</code>, shown <a href="https://emanual.robotis.com/docs/en/platform/turtlebot3/simulation/#ros-1-simulation">here</a>, which has a small simulated world with 3 Turtlebot3 mobile robots, each running its own ROS 1 navigation stack.</p>
<p>After successful builds for both ROS 1 and ROS 2 workspaces, the simulation can be launched following <a href="https://github.com/osrf/free_fleet#turtlebot3-simulation">these instructions</a>, which also includes a ROS 2 <code>free_fleet</code> server, publishing fleet state messages and accepting mode and navigation requests over ROS 2 messages and topics.</p>
<h4><a class="header" href="#ros-2-navigation-stack" id="ros-2-navigation-stack">ROS 2 Navigation Stack</a></h4>
<p>An implementation for a robot using ROS 2 would be similar to a ROS 1 navigation stack described earlier. At this time, the ROS 2 <code>free_fleet</code> client is still under development. This section will be updated once the refactoring, implementation and testing has been completed.</p>
<p>The same ready <code>free_fleet</code> server implementation in the repository will work in this scenario, as the interfaces provided by the fleet adapters are still the same ROS 2 messages and topics.</p>
<p>If required in the meantime, users can implement their own <code>free_fleet</code> client, by working with the <code>free_fleet</code> library that contains the base implementation and API for the DDS communication. This will be further elaborated in the next section <a href="hardware.html#custom-navigation-stack">Custom Navigation Stack</a>.</p>
<h4><a class="header" href="#developer-navigation-stack" id="developer-navigation-stack">Developer Navigation Stack</a></h4>
<p>In this implementation, it is assumed that the software running on the mobile robot was written by the robot developers themselves (or their immediate subcontractors) and the developers fully understand and have access to their robot's internal control software, API's and interfaces. This level of understanding and access will be necessary for implementing your own <code>free_fleet</code> client wrapper. The block diagram below illustrate this configuration.</p>
<img src="images/free_fleet_custom_config.png">
<p>Once the developer's <code>free_fleet</code> client is fully functional, it will be a simple task of launching the same ROS 2 <code>free_fleet</code> server as mentioned earlier in this section to work with the fleet adapters through ROS 2 messages and topics.</p>
<h4><a class="header" href="#system-integrator-via-api" id="system-integrator-via-api">System Integrator via API</a></h4>
<p>In this implementation, a system integrator (not the robot developer) would like to integrate with RMF. Typically system integrators will only have API level access provided by the robot developer. This scenario may be more difficult depending on the level of collaboration between the system integrator and the robot developer as well as the level of access granted. There are 2 potential approaches a system integrator may consider to a integrate a vendor developed robot with RMF.</p>
<p>The first and recommended approach is to implement a fleet driver for the robot, as documented in the previous section regarding <a href="hardware.html#mobile-robot-fleets">Mobile Robot Fleets</a>. This will ensure that the mobile robot communicates directly with fleet adapters, using the provided vendor API, without the need to run a client on the robot.</p>
<p>If however the system integrator intends to both manage the mobile robots using a fleet management system and integrate with RMF, a more indirect way may be required by implementing non-intrusive <code>free_fleet</code> clients running on the same machine as the server. The <code>free_fleet</code> client implementation would need to utilize the provided developer API to get status updates and receive navigation commands. This implementation is not advisable as it needlessly extends the communication route from RMF to the mobile robot. However if the user intends to manage a heterogeneous fleet of robots, each using different stacks of software and hardware, <code>free_fleet</code> could be a reasonable solution to that.</p>
<h2><a class="header" href="#doors-1" id="doors-1">Doors</a></h2>
<h3><a class="header" href="#map-requirements" id="map-requirements">Map requirements</a></h3>
<p>Before a door can be properly integrated, be sure to draw up the door locations with the correct door names on the navigation graph using <code>traffic_editor</code>. The instructions to do so can be found in Chapter 3. Traffic Editor.</p>
<h3><a class="header" href="#integration" id="integration">Integration</a></h3>
<p>Door integration is required when integrating RMF into a new environment. For hopefully obvious reasons, only automated doors can be integrated with RMF though it may be possible to trigger an alert to a designated human to open a manual door but this is not recommended. An automated door can be defined as an electronically powered door that is remotely controllable, either using a remote trigger or has been outfitted with a computing unit capable of commanding the door to open and close when needed, using certain interfaces.</p>
<p>Doors can be integrated with RMF using a ROS 2 door node and a door adapter, which we sometimes refer to as a door supervisor. The block diagram below displays the relationship and communication modes between each component.</p>
<img src="images/doors_block_diagram.png">
<p>The door node will have to be implemented based on the make and model of the door that is being integrated in order to address the specific API of the door controller module. The communication protocol will also be dependent on the door and controller model, which might be some form of <code>REST</code>, <code>RPCXML</code>, etc. The door node is in charge of publishing its state and receiving commands over ROS 2, using the messages and topics listed below.</p>
<table><thead><tr><th>Message Types</th><th>ROS2 Topic</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rmf_door_msgs/DoorState</code></td><td><code>/door_states</code></td><td>State of the door published by the door node</td></tr>
<tr><td><code>rmf_door_msgs/DoorRequest</code></td><td><code>/door_requests</code></td><td>Direct requests subscribed by the door node and published by the door adapter</td></tr>
<tr><td><code>rmf_door_msgs/DoorRequest</code></td><td><code>/adapter_door_requests</code></td><td>Requests to be sent to the door adapter/supervisor to request safe operation of doors</td></tr>
</tbody></table>
<p>The door adapter stands in between the rest of the RMF core systems, fleet adapters, and the door node, and acts like a state supervisor ensuring that the doors are not acting on requests that might obstruct an ongoing mobile robot task or accidentally closing on it. It keeps track of the door state from the door node, and receives requests from the <code>adapter_door_requests</code> topic which are published by either fleet adapters or other parts of the RMF core system. Only when the door adapter deems that a request is safe enough to be performed, it will instruct the door node using a request. It should also be noted that direct requests sent to the door node, without going through the door adapter will be negated by the door adapter, to return it to its prior state in order to prevent disruptions during operations with mobile robots.</p>
<h2><a class="header" href="#elevators" id="elevators">Elevators</a></h2>
<h3><a class="header" href="#map-requirements-1" id="map-requirements-1">Map requirements</a></h3>
<p>Before a lift can be properly integrated, be sure to draw up the lift locations with the correct lift names and levels on the navigation graph using <code>traffic_editor</code>. The instructions to do so can be found in Chapter 3. Traffic Editor.</p>
<h3><a class="header" href="#integration-1" id="integration-1">Integration</a></h3>
<p>Elevator integration will allow RMF to work over multiple levels, resolving conflicts and managing shared resources on a larger scale. Similar to door integration, the basic requirement is that the lift controllers accepts commands using a prescribed protocol, <code>OPC</code> is one such example.</p>
<p>The elevators will be integrated in a similar fashion as doors as well, relying on a lift node and a lift adapter. The following block diagram shows how each component works with each other.</p>
<img src="images/lifts_block_diagram.png">
<p>The lift node will act as a driver to work with the lift controller. An example of a lift node can be found in this <a href="https://github.com/sharp-rmf/kone_lift_controller">repository</a>. The node will publish its state and receive lift requests over ROS 2, using the messages and topics listed below.</p>
<table><thead><tr><th>Message Types</th><th>ROS2 Topic</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rmf_lift_msgs/LiftState</code></td><td><code>/lift_states</code></td><td>State of the lift published by the lift node</td></tr>
<tr><td><code>rmf_lift_msgs/LiftRequest</code></td><td><code>/lift_requests</code></td><td>Direct requests subscribed by the lift node and published by the lift adapter</td></tr>
<tr><td><code>rmf_lift_msgs/LiftRequest</code></td><td><code>/adapter_lift_requests</code></td><td>Requests to be sent to the lift adapter/supervisor to request safe operation of lifts</td></tr>
</tbody></table>
<p>A lift adapter subscribes to <code>lift_states</code> while keeping track of the internal and desired state of the lift in order to prevent it from performing any actions that might interrupt mobile robot or normal operations. The lift adapter performs this task by receiving lift requests from the fleet adapters and the RMF core systems and only relaying the instructions to the lift node if it is deemed appropriate. Any requests sent directly to the lift node, without going through the lift adapter, will also be negated by the lift adapter, to prevent unwanted disruption to mobile robot fleet operations.</p>
<h2><a class="header" href="#workcells-1" id="workcells-1">Workcells</a></h2>
<p>Work in progress.</p>
<h1><a class="header" href="#ui" id="ui">UI</a></h1>
<h2><a class="header" href="#introduction-1" id="introduction-1">Introduction</a></h2>
<p>We have looked at how we can integrate new hardware into RMF, now we will look at how we can write end user applications which integrate into RMF. We will briefly go through the requirements of an RMF UI application and provide a tutorial to write a React Webapp that interfaces with RMF.</p>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>The most common way to write a UI application is to make use of a UI framework. There are many available UI frameworks, the list below are some of the popular frameworks for reference:</p>
<ul>
<li>Multi-Paradigm
<ul>
<li>Qt</li>
<li>React native</li>
<li>Xamarin</li>
<li>Flutter</li>
</ul>
</li>
<li>Web
<ul>
<li>React</li>
<li>Angular</li>
<li>Vue</li>
</ul>
</li>
<li>Desktop
<ul>
<li>wxWidgets</li>
<li>Gtk</li>
<li>WPF (Windows only)</li>
</ul>
</li>
</ul>
<p>Each framework has pros and cons and we do not feel there is a &quot;best&quot; framework for all use cases. That being said, some frameworks are more suitable to integrate with RMF due to their specific underlying technologies. To understand why, let's take a brief overview at how an RMF UI application would work.</p>
<h2><a class="header" href="#how-does-an-rmf-ui-application-work" id="how-does-an-rmf-ui-application-work">How does an RMF UI Application Work?</a></h2>
<p>Imagine a simple UI application with a label that shows the current status of a door and a button that opens/closes the door. Recall that in the door adapter, we publish door states and subscribe to door requests. Here we are doing the reverse; subscribing to door states and publishing door requests. We will be listening to door states coming in from RMF and updating our display to match, and we will also be sending door requests when the user clicks the open or close button.</p>
<p>We need to use a libray to help us do that. In the hardware adapter examples we are using the <code>rclcpp</code> library, but <code>rclcpp</code> isn't the only way to use ROS 2. Here are some libraries that also work well</p>
<ul>
<li>Direct
<ul>
<li>rcl (C)</li>
<li>rclcpp (C++)</li>
<li>rclpy (python)</li>
<li>rclnodejs (nodejs)</li>
</ul>
</li>
<li>Indirect
<ul>
<li>soss (websocket)</li>
<li>rosbridge (websocket)</li>
</ul>
</li>
</ul>
<p>A &quot;direct&quot; library is able to send and receive ROS2 messages directly from the application, in contrast, an indirect library uses a middleman service to forward ROS2 messages. In general, the &quot;direct&quot; approach is more preferable but sometimes it is not possible on the target platform. In these cases, the indirect approach can be used.</p>
<div style="border: 1px; border-style: solid; padding: 1em">
<b>Note</b>: This is not an exhaustive list, you can find many third party projects that aims to bring the ROS2 ecosystem to more platforms, the <code>ros2-dotnet</code> project for example, provides C# bindings for ROS2. You can also write your own bindings and middlewares!
</div>
<p>At the end of the day, writing a RMF UI application isn't much different from writing any other UI application, the only difference being that we will be sending/receiving ROS2 in response to user input and updating the state.</p>
<h1><a class="header" href="#tutorial-react-webapp" id="tutorial-react-webapp">Tutorial: React WebApp</a></h1>
<p>In this section, we will go through an example of creating a React based webapp to monitor door states and send door open/close requests. The tutorial will focus on the aspects of communicating with RMF, basic knowledge of React and typescript is needed.</p>
<p>Note that this isn't the only way to create a RMF UI application, as mentioned before, you can use any UI toolkit, the only requirement is to be able to send/receive ROS2 messages.</p>
<p>The code for this tutorial is available at <a href="https://github.com/osrf/ros2multirobotbook/tree/master/src/react-app-tutorial">https://github.com/osrf/ros2multirobotbook/tree/master/src/react-app-tutorial</a>.</p>
<h2><a class="header" href="#requirements" id="requirements">Requirements</a></h2>
<ul>
<li>nodejs &gt;= 10</li>
<li>rmf_core (<a href="https://github.com/osrf/rmf_core">https://github.com/osrf/rmf_core</a>)</li>
<li>soss (<a href="https://github.com/osrf/soss">https://github.com/osrf/soss</a>)</li>
<li>romi-soss-ros2 (<a href="https://github.com/osrf/romi-soss-ros2">https://github.com/osrf/romi-soss-ros2</a>)</li>
<li>rmf_demos (<a href="https://github.com/osrf/rmf_demos">https://github.com/osrf/rmf_demos</a>)</li>
</ul>
<p>We will not go through the process of setting up the dependencies, instructions to set them up can be easily found on the web or from their project homepages.</p>
<h2><a class="header" href="#setting-up" id="setting-up">Setting Up</a></h2>
<p>We will be using an example from rmf_demo as the RMF deployment that we will be interacting with. This is a good time to test if your installation of <code>rmf_demo</code> is working properly, start the demo with the following command</p>
<pre><code>ros2 launch demos office.launch.xml
</code></pre>
<p>Next let's test if soss is working. In order to run soss, you need to provide it with a configuration file, you can use <a href="ui-resources/soss.yaml">this</a> template as a start. You would need a certificate for soss, refer to various tutorials online to generate one, if you are using a self-signed cert, also make sure your browser is set to accept it for websocket connections. Add the path of your cert and key to the soss config and try starting soss with</p>
<pre><code>soss &lt;path_to_config&gt;
</code></pre>
<p>Once the environment is set up, we can then proceed to set up our actual app. First, create a React workspace with:</p>
<pre><code>npx create-react-app react-app-tutorial --template typescript
</code></pre>
<p>Go inside the newly created <code>react-app-tutorial</code> directory and run the follow command to install all the javascript dependencies we will be using</p>
<pre><code>npm install @osrf/romi-js-core-interfaces @osrf/romi-js-soss-transport jsonwebtoken @types/jsonwebtoken
</code></pre>
<p>These libraries are not strictly required but they contain helpful functions to use soss and to communicate with RMF. If you are building a javascript based RMF app, it is recommended to make use of them, we will see later how they simplify the communicaton to RMF.</p>
<div style="border: 1px; border-style: solid; padding: 1em">
<b>Note</b>: Other than <code>@osrf/romi-js-soss-transport</code>, there is also <code>@osrf/romi-js-rclnodejs-transport</code> which is able to send ROS2 messages directly, however it does not work on the browser. It is preferred if you are writing a nodejs based desktop application using something like electron, or you are writing a server based application like a REST API provider.
</div>
<h2><a class="header" href="#door-component" id="door-component">Door Component</a></h2>
<p>First of all, let's start things simple by creating a component to show a door's state along with open and close buttons. Create a new file called <code>Door.tsx</code> in <code>react-app-tutorial/src</code> directory and copy the below snippet into it.</p>
<p>Door.tsx:</p>
<pre><code class="language-js">import React from 'react';

export interface DoorProps {
  name: string;
  state: string;
  onOpenClick?(e: React.MouseEvent): void;
  onCloseClick?(e: React.MouseEvent): void;
}

export const Door = (props: DoorProps) =&gt; {
  const { name, state, onOpenClick, onCloseClick } = props;
  return (
    &lt;div&gt;
      Door: {name}
      &lt;br /&gt;
      State: {state}
      &lt;br /&gt;
      &lt;button onClick={(e) =&gt; onOpenClick &amp;&amp; onOpenClick(e)}&gt;Open&lt;/button&gt;
      &lt;button onClick={(e) =&gt; onCloseClick &amp;&amp; onCloseClick(e)}&gt;Close&lt;/button&gt;
      &lt;br /&gt;
      &lt;br /&gt;
    &lt;/div&gt;
  );
};

export default Door;
</code></pre>
<p>Nothing much is happening here yet, we are simply rendering the door name, its state an open and a close button.</p>
<p>Let's test things out by running it, replace <code>App.tsx</code> with this</p>
<pre><code class="language-js">import React from 'react';
import Door from './Door';

function App() {
  return &lt;Door name=&quot;example_door&quot; state=&quot;Closed&quot; /&gt;;
}

export default App;
</code></pre>
<p>and start it with <code>npm start</code>, you should see something like this</p>
<p><img src="ui-resources/door.png" alt="Door" /></p>
<p>Great! we now have a base to start implementing the rest of the app.</p>
<h2><a class="header" href="#obtaing-list-of-doors" id="obtaing-list-of-doors">Obtaing List of Doors</a></h2>
<p>Previously we made a simple door component and tested rendering it with hardcoded values, obviusly this won't work in a proper app, here we will look at how we can obtain the list of actual doors from RMF.</p>
<p>Start of by adding a react state to track the list of doors</p>
<pre><code class="language-js">const [doors, setDoors] = React.useState&lt;RomiCore.Door[]&gt;([]);
</code></pre>
<p>RMF has a <code>get_building_map</code> service that we can use to get the list of doors, lifts, levels among many other data, in order to make use of the service we need to do a ROS2 service call, since there isn't ROS2 support on the browser, we will be using an &quot;indirect&quot; approach with <code>soss</code>. A websocket connection is made to soss which will then act as a middleman and pass our messages to the ROS2 network.</p>
<p>An easy way to use soss is with the <code>@osrf/romi-js-soss-transport</code> package, so let's do it now. Add a react effect hook to your <code>App</code> component</p>
<pre><code class="language-js">  React.useEffect(() =&gt; {
    (async () =&gt; {
      const token = jwt.sign({ user: 'example-user' }, 'rmf', { algorithm: 'HS256' });
      const transport = await SossTransport.connect('example', 'wss://localhost:50001', token);
    })();
  }, []);
</code></pre>
<p>we will need to import <code>SossTransport</code> so add this to the top of the file</p>
<pre><code class="language-js">import { SossTransport } from '@osrf/romi-js-soss-transport';
</code></pre>
<p>This performs a websocket connection to the soss server, <code>example</code> is the ROS2 node name that we will be using and we are connecting to a soss server at <code>wss://localhost:50001</code>. The server uses a JWT token signed with a secret specified in the soss config, the example config is using <code>rmf</code>, if you changed the secret, be sure to change it here as well.</p>
<div style="border: 1px; border-style: solid; padding: 1em">
<b>Note</b>: This example is only for convenience, you should never reveal the secret to the client. Usually the client would connect to an authentication server which will verify that its a valid request and return a signed token.
</div>
<p>Now that we have a connection to soss, we can call the <code>get_building_map</code> service, add this to the react effect</p>
<pre><code class="language-js">const buildingMap = (await transport.call(RomiCore.getBuildingMap, {})).building_map;
setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));
</code></pre>
<p>it uses <code>RomiCore</code> so add this to your imports</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
</code></pre>
<p>this downloads and parses the building map from RMF. <code>romi-js</code> simplifies a ROS2 service call with the async <code>call</code> method. If you are familiar with <code>rclnodejs</code>, this is roughly equivalent to</p>
<pre><code class="language-js">const client = node.createClient(
  'building_map_msgs/srv/GetBuildingMap',
  'get_building_map'
);
client.sendRequest({}, response =&gt; {
  const buildingMap = response.building_map;
  setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));
});
</code></pre>
<p>Notice that we need to provide it with type of the message (<code>building_map_msgs/srv/GetBuildingMap</code>) and the name of the service (<code>get_building_map</code>), but how do we find out what is the service name and type? We could read the RMF manual or query the ROS2 system while RMF is running, another way is with the help of <code>RomiCore</code>, it provides a list of known RMF services and messages so you don't have to go through the trouble of finding them yourself.</p>
<p>In this statement here, we are using <code>RomiCore</code> to call the <code>get_building_map</code> service without needing to know what is the service name and types</p>
<pre><code class="language-js">transport.call(RomiCore.getBuildingMap, {})
</code></pre>
<p>Now that we have a list of <code>RomiCore.Door</code>, let's make things simpler by updating <code>Door.tsx</code> to take that in as a prop, while we are at it, let's also have it take in a <code>RomiCore.DoorState</code> as a prop since we will be using it later.</p>
<p>Door.tsx:</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import React from 'react';

export interface DoorProps {
  door: RomiCore.Door;
  doorState?: RomiCore.DoorState;
  onOpenClick?(e: React.MouseEvent): void;
  onCloseClick?(e: React.MouseEvent): void;
}

export const Door = (props: DoorProps) =&gt; {
  const { door, doorState, onOpenClick, onCloseClick } = props;
  return (
    &lt;div&gt;
      Door: {door.name}
      &lt;br /&gt;
      State: {doorState ? doorState.current_mode.value : 'Unknown'}
      &lt;br /&gt;
      &lt;button onClick={(e) =&gt; onOpenClick &amp;&amp; onOpenClick(e)}&gt;Open&lt;/button&gt;
      &lt;button onClick={(e) =&gt; onCloseClick &amp;&amp; onCloseClick(e)}&gt;Close&lt;/button&gt;
      &lt;br /&gt;
      &lt;br /&gt;
    &lt;/div&gt;
  );
};

export default Door;
</code></pre>
<p>Now we can test it by passing the doors as props, your <code>App</code> component should now look like this</p>
<p>App.tsx:</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import { SossTransport } from '@osrf/romi-js-soss-transport';
import * as jwt from 'jsonwebtoken';
import React from 'react';
import Door from './Door';

function App() {
  const [doors, setDoors] = React.useState&lt;RomiCore.Door[]&gt;([]);

  React.useEffect(() =&gt; {
    (async () =&gt; {
      const token = jwt.sign({ user: 'example-user' }, 'rmf', { algorithm: 'HS256' });
      const transport = await SossTransport.connect('example', 'wss://localhost:50001', token);
      const buildingMap = (await transport.call(RomiCore.getBuildingMap, {})).building_map;
      setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));
    })();
  }, []);

  return (
    &lt;React.Fragment&gt;
      {doors.map((door) =&gt; (
        &lt;Door door={door} /&gt;
      ))}
    &lt;/React.Fragment&gt;
  );
}

export default App;
</code></pre>
<p>Don't worry about the door state for now. If everything goes well, you should see 3 doors that are in the building</p>
<p><img src="ui-resources/building-map-doors.png" alt="Doors" /></p>
<h2><a class="header" href="#listening-for-door-states" id="listening-for-door-states">Listening for Door States</a></h2>
<p>Previously we managed to render the list of doors in the RMF system but the building map doesn't tells us the door states so we will now fix it here. First, let's add a react state to track the door states</p>
<pre><code class="language-js">const [doorStates, setDoorStates] = React.useState&lt;Record&lt;string, RomiCore.DoorState&gt;&gt;({});
</code></pre>
<p>The door states can be obtained by subscribing to the <code>door_states</code> topic, update your effect to add this</p>
<pre><code class="language-js">transport.subscribe(RomiCore.doorStates, (doorState) =&gt;
  setDoorStates((prev) =&gt; ({ ...prev, [doorState.door_name]: doorState })),
);
</code></pre>
<p>This performs a ROS2 subscription to the <code>RomiCore.doorStates</code> topic, similar to the service call we did earlier, <code>romi-js</code> abstracts away the ROS2 topic name and provide type information. The callback will be fired each time a new door state message comes in, in the callback, we simply update the <code>doorStates</code> state.</p>
<p>now just pass the door state to the door component</p>
<pre><code class="language-js">&lt;Door door={door} doorState={doorStates[door.name]} /&gt;
</code></pre>
<p>the end result of your <code>App.tsx</code> should look like this</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import { SossTransport } from '@osrf/romi-js-soss-transport';
import * as jwt from 'jsonwebtoken';
import React from 'react';
import Door from './Door';

function App() {
  const [doors, setDoors] = React.useState&lt;RomiCore.Door[]&gt;([]);
  const [doorStates, setDoorStates] = React.useState&lt;Record&lt;string, RomiCore.DoorState&gt;&gt;({});

  React.useEffect(() =&gt; {
    (async () =&gt; {
      const token = jwt.sign({ user: 'example-user' }, 'rmf', { algorithm: 'HS256' });
      const transport = await SossTransport.connect('example', 'wss://localhost:50001', token);
      const buildingMap = (await transport.call(RomiCore.getBuildingMap, {})).building_map;
      setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));

      transport.subscribe(RomiCore.doorStates, (doorState) =&gt;
        setDoorStates((prev) =&gt; ({ ...prev, [doorState.door_name]: doorState })),
      );
    })();
  }, []);

  return (
    &lt;React.Fragment&gt;
      {doors.map((door) =&gt; (
        &lt;Door door={door} doorState={doorStates[door.name]} /&gt;
      ))}
    &lt;/React.Fragment&gt;
  );
}

export default App;
</code></pre>
<p>And just like that we now have the door states!</p>
<p><img src="ui-resources/with-door-states-number.png" alt="with door states" /></p>
<p>But wait... the door states are numbers like <code>1</code> and <code>2</code>, this is because RMF uses a constant to represent door states, we could run a simple function to convert these constants into string</p>
<pre><code class="language-js">function doorModeString(doorMode: RomiCore.DoorMode): string {
  switch (doorMode.value) {
    case 2:
      return 'Open';
    case 0:
      return 'Closed';
    case 1:
      return 'Moving';
    default:
      return 'Unknown';
  }
}
</code></pre>
<p>but how do we know <code>2</code> means &quot;Open&quot; etc? We can find out by reading the RMF manual or inspecting the ROS2 message definitions, but we can do better with <code>RomiCore</code>, it provides the list of constants in a more readable form</p>
<pre><code class="language-js">function doorModeString(doorMode: RomiCore.DoorMode): string {
  switch (doorMode.value) {
    case RomiCore.DoorMode.MODE_OPEN:
      return 'Open';
    case RomiCore.DoorMode.MODE_CLOSED:
      return 'Closed';
    case RomiCore.DoorMode.MODE_MOVING:
      return 'Moving';
    default:
      return 'Unknown';
  }
}
</code></pre>
<p>With this it's obvious what each constants represent so we don't have to refer to anything else to find their meaning.</p>
<p>Go ahead and add this to your <code>Door.tsx</code>, it should look like this now</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import React from 'react';

export interface DoorProps {
  door: RomiCore.Door;
  doorState?: RomiCore.DoorState;
  onOpenClick?(e: React.MouseEvent): void;
  onCloseClick?(e: React.MouseEvent): void;
}

export const Door = (props: DoorProps) =&gt; {
  const { door, doorState, onOpenClick, onCloseClick } = props;
  const modeString = doorState ? doorModeString(doorState.current_mode) : 'Unknown';
  return (
    &lt;div&gt;
      Door: {door.name}
      &lt;br /&gt;
      State: {modeString}
      &lt;br /&gt;
      &lt;button onClick={(e) =&gt; onOpenClick &amp;&amp; onOpenClick(e)}&gt;Open&lt;/button&gt;
      &lt;button onClick={(e) =&gt; onCloseClick &amp;&amp; onCloseClick(e)}&gt;Close&lt;/button&gt;
      &lt;br /&gt;
      &lt;br /&gt;
    &lt;/div&gt;
  );
};

function doorModeString(doorMode: RomiCore.DoorMode): string {
  switch (doorMode.value) {
    case RomiCore.DoorMode.MODE_OPEN:
      return 'Open';
    case RomiCore.DoorMode.MODE_CLOSED:
      return 'Closed';
    case RomiCore.DoorMode.MODE_MOVING:
      return 'Moving';
    default:
      return 'Unknown';
  }
}

export default Door;
</code></pre>
<p>Great! Now we have readable door states instead of cryptic numbers.</p>
<p><img src="ui-resources/with-door-states.png" alt="with door states" /></p>
<h2><a class="header" href="#sending-door-requests" id="sending-door-requests">Sending Door Requests</a></h2>
<p>As you may have expected by now, all we have to do here is to send door requests to RMF.</p>
<p>First, create a publisher, add this to the start of the render function.</p>
<pre><code class="language-js">const doorRequestPub = React.useRef&lt;RomiCore.Publisher&lt;RomiCore.DoorRequest&gt; | null&gt;(null);
</code></pre>
<p>Then add this helper function</p>
<pre><code class="language-js">const requestDoor = (door: RomiCore.Door, mode: number) =&gt; {
  if (doorRequestPub.current) {
    const request: RomiCore.DoorRequest = {
      door_name: door.name,
      request_time: RomiCore.toRosTime(new Date()),
      requested_mode: { value: mode },
      requester_id: 'example-request',
    };
    doorRequestPub.current.publish(request);
  }
};
</code></pre>
<p>it takes in a <code>RomiCore.Door</code> and a number, representing the desired mode and simply craft a <code>RomiCore.DoorRequest</code> message and sends it using the publisher. Normally you would have to consult the RMF manual or the ROS2 definitions to know exactly what you need to send, again, <code>RomiCore</code> provides the typing information to make it easier to fill in the required fields.</p>
<p>and finally add this to the props passed to the door component</p>
<pre><code class="language-js">onOpenClick={() =&gt; requestDoor(door, RomiCore.DoorMode.MODE_OPEN)}
onCloseClick={() =&gt; requestDoor(door, RomiCore.DoorMode.MODE_CLOSED)}
</code></pre>
<p>Your final <code>App.tsx</code> should look like this</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import { SossTransport } from '@osrf/romi-js-soss-transport';
import * as jwt from 'jsonwebtoken';
import React from 'react';
import Door from './Door';

function App() {
  const [doors, setDoors] = React.useState&lt;RomiCore.Door[]&gt;([]);
  const [doorStates, setDoorStates] = React.useState&lt;Record&lt;string, RomiCore.DoorState&gt;&gt;({});
  const doorRequestPub = React.useRef&lt;RomiCore.Publisher&lt;RomiCore.DoorRequest&gt; | null&gt;(null);

  React.useEffect(() =&gt; {
    (async () =&gt; {
      const token = jwt.sign({ user: 'example-user' }, 'rmf', { algorithm: 'HS256' });
      const transport = await SossTransport.connect('example', 'wss://localhost:50001', token);
      const buildingMap = (await transport.call(RomiCore.getBuildingMap, {})).building_map;
      setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));

      transport.subscribe(RomiCore.doorStates, (doorState) =&gt;
        setDoorStates((prev) =&gt; ({ ...prev, [doorState.door_name]: doorState })),
      );

      doorRequestPub.current = transport.createPublisher(RomiCore.adapterDoorRequests);
    })();
  }, []);

  const requestDoor = (door: RomiCore.Door, mode: number) =&gt; {
    if (doorRequestPub.current) {
      const request: RomiCore.DoorRequest = {
        door_name: door.name,
        request_time: RomiCore.toRosTime(new Date()),
        requested_mode: { value: mode },
        requester_id: 'example-request',
      };
      doorRequestPub.current.publish(request);
    }
  };

  return (
    &lt;React.Fragment&gt;
      {doors.map((door) =&gt; (
        &lt;Door
          door={door}
          doorState={doorStates[door.name]}
          onOpenClick={() =&gt; requestDoor(door, RomiCore.DoorMode.MODE_OPEN)}
          onCloseClick={() =&gt; requestDoor(door, RomiCore.DoorMode.MODE_CLOSED)}
        /&gt;
      ))}
    &lt;/React.Fragment&gt;
  );
}

export default App;
</code></pre>
<p>Try clicking on the open and close buttons now, you should see the door state being updated, you can also see the door opening/closing in gazebo. Congratulations! You have just written a simple RMF UI application! Obviously the design leaves much to be desired as we didn't do any CSS styling but that is outside the scope of this tutorial.</p>
<p>Extending this to provide more features like lift control, fleet states etc follows the same principal. All the available topics and services exposed by RMF are available in <code>RomiCore</code>, you can also find more detailed information by reading the rest of the manual. This also extends to writing UI applications for other platforms and frameworks, at the core you are really just publishing and subscribing to ROS2 messages so you can apply the same principals in other languages and frameworks.</p>
<h2><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h2>
<p>We have just created a minimal RMF UI application that reports the door state and allows a user to control the door. For simplicity, there aren't many features included but this tutorial should provide the basic knowledge of how to create an RMF UI application not only in React but also in any framework that you like!</p>
<p>If you would like more examples of a React RMF application, you can take a look at the official <a href="https://github.com/osrf/romi-dashboard">RoMi dashboard</a>.</p>
<h2><a class="header" href="#extra-extending-romi-js" id="extra-extending-romi-js">Extra: Extending romi-js</a></h2>
<p>Throughout the tutorial, we are using <code>romi-js</code> to simplify the communication to RMF. As you might have noticed <code>romi-js</code> is actually a collection of packages, this design makes it possible to easily extend it with new topic, services and even transports.</p>
<h3><a class="header" href="#adding-topics-and-services" id="adding-topics-and-services">Adding Topics and Services</a></h3>
<p>Adding topics and services are very simple, a topic and service is defined by the interfaces:</p>
<pre><code class="language-js">export interface RomiTopic&lt;Message&gt; {
  readonly validate: (msg: any) =&gt; Message;
  readonly type: string;
  readonly topic: string;
  readonly options?: Options;
}

export interface RomiService&lt;Request, Response&gt; {
  readonly validateRequest: (msg: any) =&gt; Request;
  readonly validateResponse: (msg: any) =&gt; Response;
  readonly type: string;
  readonly service: string;
  readonly options?: Options;
}
</code></pre>
<p>If you are familiar with ROS 2, the <code>type</code> field specifies the message type that the topic or service expects while <code>topic</code>/<code>service</code> are the topic and service names, respectively. Sometimes a topic or service is expected to use a different QoS option; for example a topic that does not only publish when the state changes and expects late subscriptions to make use of transient local QoS to receive the latest state. The <code>options</code> specify the &quot;default&quot; QoS options that should be used. In this way, users do not have to refer to the usage instructions to correctly publish and subscribe to the topic.</p>
<p>The <code>validate*</code> methods are used by the transport to convert an abitary object to the expected type of the topic or service. It should check if the object has the correct fields and that the fields are of the correct types. To ensure compatibility with different transports, these methods should be able to convert number arrays to typed arrays and vice versa.</p>
<p>We can create custom topics or services by implementing these interfaces, they can then be passed to the transport's various methods.</p>
<pre><code class="language-js">export const myTopic: RomiTopic&lt;MyMessage&gt; = {
  validate: validateMyMessage(msg), // some function that valides MyMessage
  type: 'my_messages/msg/MyMessage',
  topic: 'my_topic',
};
</code></pre>
<h3><a class="header" href="#adding-transport" id="adding-transport">Adding Transport</a></h3>
<p>A <code>Transport</code> in <code>romi-js</code> is a class with the interface:</p>
<pre><code class="language-js">export interface Subscription {
  unsubscribe(): void;
}

export interface Publisher&lt;Message&gt; {
  publish(msg: Message): void;
}

export interface Service&lt;Request, Response&gt; {
  start(handler: (req: Request) =&gt; Promise&lt;Response&gt; | Response): void;
  stop(): void;
}

export interface Transport extends TransportEvents {
  readonly name: string;

  createPublisher&lt;Message extends unknown&gt;(
    topic: RomiTopic&lt;Message&gt;,
    options?: Options,
  ): Publisher&lt;Message&gt;;

  subscribe&lt;Message extends unknown&gt;(
    topic: RomiTopic&lt;Message&gt;,
    cb: SubscriptionCb&lt;Message&gt;,
    options?: Options,
  ): Subscription;

  call&lt;Request extends unknown, Response extends unknown&gt;(
    service: RomiService&lt;Request, Response&gt;,
    req: Request,
  ): Promise&lt;Response&gt;;

  createService&lt;Request extends unknown, Response extends unknown&gt;(
    service: RomiService&lt;Request, Response&gt;,
  ): Service&lt;Request, Response&gt;;

  destroy(): void;
}
</code></pre>
<p>There isn't a general guide on how the interface should be implemented since the details would be different for each transport. One thing to note is that it might be tempting to return a type derived from <code>any</code> (e.g. <code>Publisher&lt;any&gt;</code>) to pass the typescript checks but doing so is not recommended. You should call the <code>validate*</code> methods in the topic or service to convert something into a type of <code>Message</code>.</p>
<p>To ensure compatibilities with different topics and services, transports must deserialize the data to a plain old data object. It can use either number arrays or typed arrays, the <code>validate*</code> methods should support converting them to the expected types.</p>
<h1><a class="header" href="#security" id="security">Security</a></h1>
<p>This chapter describes how to use DDS Security tools to provide authentication,
encryption, and access control to a RoMi-H system.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>

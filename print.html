<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programming Multiple Robots with ROS 2</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item "><a href="ros2.html"><strong aria-hidden="true">2.</strong> ROS 2</a></li><li class="chapter-item "><a href="traffic-editor.html"><strong aria-hidden="true">3.</strong> Traffic Editor</a></li><li class="chapter-item "><a href="simulation.html"><strong aria-hidden="true">4.</strong> Simulation</a></li><li class="chapter-item "><a href="rmf-core.html"><strong aria-hidden="true">5.</strong> RMF Core</a></li><li class="chapter-item "><a href="soss.html"><strong aria-hidden="true">6.</strong> SOSS</a></li><li class="chapter-item "><a href="hardware.html"><strong aria-hidden="true">7.</strong> Hardware</a></li><li class="chapter-item "><a href="ui.html"><strong aria-hidden="true">8.</strong> User Interfaces</a></li><li class="chapter-item "><a href="security.html"><strong aria-hidden="true">9.</strong> Security</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Programming Multiple Robots with ROS 2</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>In this section, we shall describe the motivation for ROS 2 and the RMF
system for integrating multiple robots.</p>
<h1><a class="header" href="#ros-2" id="ros-2">ROS 2</a></h1>
<p>(insert)</p>
<h1><a class="header" href="#robotics-middleware-framework-rmf" id="robotics-middleware-framework-rmf">Robotics Middleware Framework (RMF)</a></h1>
<h2><a class="header" href="#motivation-for-rmf" id="motivation-for-rmf">Motivation for RMF</a></h2>
<p>Imagine with us a world where the incredible robots that are available on the market are now able to co-exist in the same facility; gracefully sharing critical resources such as corridors, elevators/lifts, doors and other infrastructure to enable a more efficient overall system. Imagine integrating an elevator/lift for robots only once and this elevator/lift is now enabled to be used for any robot that needs to use the shared resource in a controlled and safe manner. Imagine a world free of robot deadlocks in a shared corridor. These ideas are achievable today using an amazing system called RMF.</p>
<p>Many companies adopt a strategy of operational efficiency and use the lever of technology, thru the deployment of robots and other smart devices, to help realize their goals. The current generation of robots in production environments today are able to provide services including both bulk and single piece flow delivery, cleaning, disinfecting, security, monitoring, and much more. The diversity in robotic use cases most likely means the best in class robots for each task will come from different robot providers or system integrators. This modern reality makes it critical for a common software framework to be in place in order to manage these heterogeneous resources and to ensure that information is being used effectively from different platforms to promote overall system efficiency.</p>
<p>Without an initial goal and plan for a holistically efficient robotics system, there can be a significant but hidden risk for end users when committing to a single system or platform provider. The hidden &quot;walled gardens&quot; are likely to force an end user to limit their selection of future solutions from that particular provider to minimize opearational risk and avoid redundant integration costs. As the scope and scale of robotic deployments increase this problem is exacerbated, leaving the customer with a perception of no good option except to stay with their current provider.</p>
<p>Beyond the increase cost risk of scaling deployment with different providers, there is also the inherent conflict over shared resources such as elevators, doorways, corridors, network bandwidth, chargers, operations-center screen “real estate,” and human resources such as IT personnel and maintenance technicians. As robotic scale increases, it would become more cumbersome for an operations team to consider managing a large, heterogeneous, multi-vendor robot environment.</p>
<p>These problem statements were the foundational motivations for the development of RMF. To unlock the end user's options and increase robotic system selection ultimately means the entire robotic ecosystem can grow. We can collectively grow the pie.</p>
<p>Historically ROS development has focused heavily on the software running on or near individual robots. RMF is designed to operate at a higher abstraction layer to create networked fleets of robots that interoperate with building infrastructure systems, enterprise services, IOT devices, and human interfaces. Unlock your facility and your future with RMF.</p>
<h1><a class="header" href="#ros-2-1" id="ros-2-1">ROS 2</a></h1>
<p>Herein we shall discuss Deep Thoughts about ROS 2</p>
<h1><a class="header" href="#traffic-editor" id="traffic-editor">Traffic Editor</a></h1>
<p>In this section, we shall describe the traffic-editor GUI.</p>
<h1><a class="header" href="#simulation" id="simulation">Simulation</a></h1>
<p>This chapter will describe how to generate building models from the
<code>traffic-editor</code> files and simulate fleets of robots in them.</p>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>Simulation environments for testing robotic solutions offer immense value across
various stages of R&amp;D and deployment. More notably, simulations provide the
following benefits.</p>
<ul>
<li>
<p><strong>Time and resource saving:</strong> While testing with hardware is indispensible,
the process can slow the pace of development with additional setup time, robot
downtime and and reset periods between trials. As the number of participants
scale, so do costs associated with purchasing hardware and consumables for
testing. This is especially true with solutions such as RMF which aim to
integrate several mobile/stationary robots, and building systems such as doors
and lifts. Simulations provide a potentially cost effective and time saving alternative
for evaluating the behavior of robot systems at scale. More importantly
simulations can help answer questions prior to deployment such as how many
participants can be supported or how the existing behavior would change with
the introduction of a new fleet, both of which can inform purchasing decisions
for facility owners. </p>
</li>
<li>
<p><strong>Robust testing:</strong> Robots in simulation neither run out of battery nor incur costs when they happen to unfortunately crash into something. Scenarios
can be tested for hours at a stretch, at faster speeds, to fine tune
algorithms and verify their robustness. One factor on how much scenario testing to run is a decision on how much compute power you want to avail for the simulation. With the introduction of cloud simulation, this limit is then a trade off of cost and speed as well. As scenarios in simulation are
repeatable, fixes for undesirable bugs encountered can be readily validated.
Reaction of the system to edge cases which are rare but have severe
consequences can also be studied through simulation. Data logged from hardware
trials can be used to recreate the scenario in simulation which may be further
helpful for debugging. Lastly, long running simulations can instill confidence
in facility owners prior to deployment.</p>
</li>
</ul>
<p>Physics-based simulators such as <code>Gazebo</code>, carry the benefit of easily
interfacing with ROS2 nodes through wrappers provided by <code>gazebo_ros_pkgs</code>.
Gazebo plugins can be developed that accurately emulate the behavior of robots,
sensors and infrastructure systems which enhance the overall fidelity of
simulations. It is worth emphasizing here that the exact same code used to run the simulations
will also be run on the physical system as well without any changes.</p>
<p>However, despite these compelling benefits, simulations are sparingly employed
by developers and system integrators citing complexity over generating
environments and configuring them with appropriate plugins. In a recent publication &quot;<em>A Study on the Challenges of Using Robotics Simulators for Testing</em>,&quot; by Afsoon Afzal, Deborah S. Katz, Claire Le Goues and Christopher S. Timperley they noted the main reasons participants gave for not using simulation for a particular project and summarized their findings as follows:</p>
<table><thead><tr><th>Reason for not using simulation</th><th>#</th><th>%</th></tr></thead><tbody>
<tr><td>Lack of time or resources</td><td>15</td><td>53.57%</td></tr>
<tr><td>Not realistic/accurate enough</td><td>15</td><td>53.57%</td></tr>
<tr><td>Lack of expertise or knowledge on how to use software-based simulation</td><td>6</td><td>21.43%</td></tr>
<tr><td>There was no simulator for the robot</td><td>4</td><td>14.29%</td></tr>
<tr><td>Not applicable</td><td>4</td><td>14.29%</td></tr>
<tr><td>Too much time or compute resources</td><td>2</td><td>7.14%</td></tr>
<tr><td>Nobody suggested it</td><td>0</td><td>0.00%</td></tr>
<tr><td>Other</td><td>2</td><td>7.14%</td></tr>
</tbody></table>
<p>The RMF project also
aims to address these hurdles by simplifying the process of setting up
simulation environments for multi-fleet traffic control as we will explain further throughout this section.</p>
<h2><a class="header" href="#building-map-generator" id="building-map-generator">Building Map Generator</a></h2>
<p>The <code>traffic_editor</code> as discussed previously is a tool to annotate building
floor plans with fleet specific traffic information in a vendor neutral manner.
This includes waypoints of interest, traffic lanes and shared resources such as
doorways and lifts. It can also be used to markup the walls and floors and add
thumbnails of artifacts in the environment. The ability to auto-generate a 3D
world using this annotated map is of significant value towards simplifying the
creation and management of simulations. To this end, the <code>building_map_tools</code>
package in <code>traffic_editor</code> contains an executable <code>building_map_generator</code>. The
executable operates in two modes 1) To generate a Gazebo/Ignition compliant
<code>.world</code> file and 2) Export the fleet specific traffic information in the form
of navigation graphs which are utilized by <code>fleet_adapters</code> for planning.</p>
<p><img src="images/building_map_generator.png" alt="" /></p>
<p>To auto-generate a Gazebo simulation world, the executable takes in the command arugment &quot;gazebo&quot; along with others described below.</p>
<pre><code class="language-bash">usage: building_map_generator gazebo [-h] [-o [OPTIONS [OPTIONS ...]]] [-n]
                                     [-m MODEL_PATH] [-c CACHE]
                                     INPUT OUTPUT_WORLD OUTPUT_MODEL_DIR

positional arguments:
  INPUT                 Input building.yaml file to process
  OUTPUT_WORLD          Name of the .world file to output
  OUTPUT_MODEL_DIR      Path to output the map model files

optional arguments:
  -h, --help            show this help message and exit
  -o [OPTIONS [OPTIONS ...]], --options [OPTIONS [OPTIONS ...]]
                        Generator options
  -n, --no_download     Do not download missing models from Fuel
  -m MODEL_PATH, --model_path MODEL_PATH
                        Gazebo model path to check for models
  -c CACHE, --cache CACHE
                        Path to pit_crew model cache
</code></pre>
<p>The script parses the <code>.building.yaml</code> file and generates meshes for the
flooring and walls for each level which are combined into a <code>model.sdf</code> file in
the <code>OUTPUT_MODEL_DIR/</code> directory. The <code>model.sdf</code> files for each level are
imported into the <code>.world</code> with filepath <code>OUTPUT_WORLD</code>. Model sub-elements for
various static objects annotated in the <code>traffic_editor</code> are included in the
<code>.world</code> as seen in the snippet below. Similar blocks for annotated robots are
generated. It is the responsibility of the user to append the environment
variable <code>$GAZEBO_MODEL_PATH</code> with the relevant paths to the models prior to
loading the <code>.world</code> file in Gazebo. This process can be simplified through ROS2
launch files and will be discussed in later sections.</p>
<pre><code class="language-xml">&lt;include&gt;
  &lt;name&gt;OfficeChairBlack_6&lt;/name&gt;
  &lt;uri&gt;model://OfficeChairBlack&lt;/uri&gt;
  &lt;pose&gt;4.26201267190027 -7.489812761393875 0 0 0 1.1212&lt;/pose&gt;
  &lt;static&gt;True&lt;/static&gt;
&lt;/include&gt;
</code></pre>
<p>The parser also includes Sdf elements for other dynamic assets such as doors and
lifts. Their mechanisms are discussed in the ensuing section. An <code>Ignition</code>
compatible world can be generated by using the &quot;command&quot; argument &quot;ignition&quot;.</p>
<p>Reconfiguring simulation environments becomes as trivial as editing the
annotations on the 2D drawing and re-running the <code>building_map_generator</code>. This
is exceedingly useful to quickly evaluate traffic flow as the spatial
configuration in the facility changes.</p>
<p>To generate navigation graphs for fleet adapters, the <code>building_map_generator</code> is executed with <code>command</code> argument &quot;nav&quot;. The navigation graph is generated as a <code>.yaml</code> file and is parsed during launch by the corresponding fleet adapter.</p>
<pre><code class="language-bash">usage: building_map_generator nav [-h] INPUT OUTPUT_DIR

positional arguments:
  INPUT       Input building.yaml file to process
  OUTPUT_DIR  Path to output the nav .yaml files

</code></pre>
<h2><a class="header" href="#rmf-assets-and-plugins" id="rmf-assets-and-plugins">RMF Assets and Plugins</a></h2>
<p>Assets play a pivotal role in recreating environments in simulation. Projects such as RMF, SubT and others have allowed developers to create and open source 3D models of robots, mechanical infrastructure systems and scene objects. They are available for download <a href="https://app.ignitionrobotics.org/OpenRobotics/fuel/collections/">here</a>.
Beyond imparting visual accuracy, assets may be dynamic and interface with rmf
core systems through the aid of plugins. </p>
<p>To simulate the behavior of hardware such as robot models and infrastructure
systems, several Gazebo plugins have been architected. These plugins are derivates of the <a href="http://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1ModelPlugin.html">ModelPlugin</a> class and tie in standard ROS2 and rmf_core messages to provide necessary functionality. The following sections briefly describe some of these plugins.</p>
<h4><a class="header" href="#robots" id="robots">Robots</a></h4>
<p>As highlighted earlier, several robot models (SESTO, MiR100, Magni, Hospi) have been
open sourced for use in simulation. For these models to emulate the behavior of
their physical counterparts which have been integrated with RMF, they need to 1)
interface with <code>rmf_fleet_adapters</code> and 2) navigate to locations in the
simulated world. These functionalities, for a &quot;<em>full control</em>&quot; robot type, are
achieved through the <code>slotcar</code> <a href="https://github.com/osrf/traffic_editor/blob/master/building_gazebo_plugins/src/slotcar.cpp">plugin</a>.
The plugin subscribes to <code>/robot_path_requests</code> and <code>/robot_mode_requests</code>
topics and responds to relevant <code>PathRequest</code> and <code>ModeRequest</code> messages
published by its <code>rmf_fleet_adapter</code>. The plugin also publishes the robot's
state to the <code>/robot_state</code> topic.</p>
<p>To navigate the robot through waypoints in a <code>PathRequest</code> message, a simple
&quot;rail-like&quot; navigation algorithm is utilized which accelerates and decelerates
the robot along a straight line from its current position to the next waypoint.
The plugin relies on these fundamental assumptions</p>
<ul>
<li>The robot model is a two-wheel differential drive robot</li>
<li>The left and right wheel joints are named  <code>joint_tire_left</code> and <code>joint_tire_right</code> respectively</li>
</ul>
<p>Other parameters, majority of which are kinematic properties of the robot are inferred from sdf parameters. </p>
<pre><code class="language-xml">&lt;plugin name=&quot;slotcar&quot; filename=&quot;libslotcar.so&quot;&gt;
  &lt;nominal_drive_speed&gt;0.5&lt;/nominal_drive_speed&gt;
  &lt;nominal_drive_acceleration&gt;0.25&lt;/nominal_drive_acceleration&gt;
  &lt;max_drive_acceleration&gt;0.75&lt;/max_drive_acceleration&gt;
  &lt;nominal_turn_speed&gt;0.6&lt;/nominal_turn_speed&gt;
  &lt;nominal_turn_acceleration&gt;1.5&lt;/nominal_turn_acceleration&gt;
  &lt;max_turn_acceleration&gt;2.0&lt;/max_turn_acceleration&gt;
  &lt;tire_radius&gt;0.1&lt;/tire_radius&gt;
  &lt;base_width&gt;0.3206&lt;/base_width&gt;
  &lt;stop_distance&gt;0.75&lt;/stop_distance&gt;
  &lt;stop_radius&gt;0.75&lt;/stop_radius&gt;
&lt;/plugin&gt;
</code></pre>
<p>During simulation, it is assumed that the robot's path is free of static
obstacles but the plugin contains logic to pause the robot's motion if an
obstacle is detected in its path. While it is possible to deploy a sensor based
navigation stack, the approach is avoided to minimize the computational load on
the system from running a navigation stack for each robot in the simulation.
Given the focus on traffic management of heterogeneous fleets and not robot
navigation, the <code>slotcar</code> plugin provides an efficiently means to simulate the
interaction between rmf core systems and robots.</p>
<p>The <code>slotcar</code> plugin is meant to serve as a generalized solution. Vendors are
encouraged to develop and distribute plugins that more accurately represent the
capabilities of their robot and the level of integration with RMF.</p>
<h4><a class="header" href="#doors" id="doors">Doors</a></h4>
<p>Unlike robot models whose geometries are fixed and hence can be directly
included in the generated <code>.world</code> file, doors are custom defined in
<code>traffic_editor</code> and have their own generation pipeline. As seen in the figure
below, an annotated door has several properties which include the location of
its ends, the type of door (hinged, double_hinged, sliding, double_sliding) and
its range of motion (for hinged doors).</p>
<p><img src="images/door_traffic_editor.png" alt="Figure X" /></p>
<p>The <code>building_map_generator gazebo</code> script parses a <code>.building.yaml</code> file for
any doors and automatically generates an sdf sub-element with links and joints
required for the door along with a configured plugin. The sdf sub-element
generated for the door in the figure above is presented below.</p>
<pre><code class="language-xml">&lt;model name=&quot;coe_door&quot;&gt;
  &lt;pose&gt;8.077686357313898 -5.898342045416362 0.0 0 0 1.1560010438234292&lt;/pose&gt;
  &lt;plugin filename=&quot;libdoor.so&quot; name=&quot;door&quot;&gt;
    &lt;v_max_door&gt;0.5&lt;/v_max_door&gt;
    &lt;a_max_door&gt;0.3&lt;/a_max_door&gt;
    &lt;a_nom_door&gt;0.15&lt;/a_nom_door&gt;
    &lt;dx_min_door&gt;0.01&lt;/dx_min_door&gt;
    &lt;f_max_door&gt;500.0&lt;/f_max_door&gt;
    &lt;door left_joint_name=&quot;left_joint&quot; name=&quot;coe_door&quot; right_joint_name=&quot;empty_joint&quot; type=&quot;SwingDoor&quot; /&gt;
  &lt;/plugin&gt;
  &lt;link name=&quot;left&quot;&gt;
    &lt;pose&gt;0 0 1.11 0 0 0&lt;/pose&gt;
    &lt;visual name=&quot;left&quot;&gt;
      &lt;material&gt;
        &lt;ambient&gt;120 60 0 0.6&lt;/ambient&gt;
        &lt;diffuse&gt;120 60 0 0.6&lt;/diffuse&gt;
      &lt;/material&gt;
      &lt;geometry&gt;
        &lt;box&gt;
          &lt;size&gt;0.8766026166317483 0.03 2.2&lt;/size&gt;
        &lt;/box&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
    &lt;collision name=&quot;left&quot;&gt;
      &lt;surface&gt;
        &lt;contact&gt;
          &lt;collide_bitmask&gt;0x02&lt;/collide_bitmask&gt;
        &lt;/contact&gt;
      &lt;/surface&gt;
      &lt;geometry&gt;
        &lt;box&gt;
          &lt;size&gt;0.8766026166317483 0.03 2.2&lt;/size&gt;
        &lt;/box&gt;
      &lt;/geometry&gt;
    &lt;/collision&gt;
    &lt;inertial&gt;
      &lt;mass&gt;50.0&lt;/mass&gt;
      &lt;inertia&gt;
        &lt;ixx&gt;20.17041666666667&lt;/ixx&gt;
        &lt;iyy&gt;23.36846728119012&lt;/iyy&gt;
        &lt;izz&gt;3.20555061452345&lt;/izz&gt;
      &lt;/inertia&gt;
    &lt;/inertial&gt;
  &lt;/link&gt;
  &lt;joint name=&quot;left_joint&quot; type=&quot;revolute&quot;&gt;
    &lt;parent&gt;world&lt;/parent&gt;
    &lt;child&gt;left&lt;/child&gt;
    &lt;axis&gt;
      &lt;xyz&gt;0 0 1&lt;/xyz&gt;
      &lt;limit&gt;
        &lt;lower&gt;-1.57&lt;/lower&gt;
        &lt;upper&gt;0&lt;/upper&gt;
      &lt;/limit&gt;
    &lt;/axis&gt;
    &lt;pose&gt;0.44330130831587417 0 0 0 0 0&lt;/pose&gt;
  &lt;/joint&gt;
&lt;/model&gt;
</code></pre>
<p>The door <a href="https://github.com/osrf/traffic_editor/blob/master/building_gazebo_plugins/src/door.cpp">plugin</a> responds to <code>DoorRequest</code> messages with <code>door_name</code> matching its <code>model name</code> sdf tag. These messages are published over the <code>/door_requests</code> topic. The plugin is agnostic of the type of door defined and relies on the <code>left_joint_name</code> and <code>right_joint_name</code> parameters to determine which joints to actuate during open and close motions. During these motions, the joints are commanded to their appropriate limits which are specified in the parent element. The joint motions adhere to kinematic constraints specified by sdf parameters while following acceleration and deceleration profiles similar to the <code>slotcar</code>. </p>
<p>To avoid situations where one robot requests a door to close on another robot, a <code>door_supervisor</code> <a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/src/door_supervisor/main.cpp">node</a> is deployed in practice. The node publishes to <code>/door_requests</code> and subscribes to <code>/adapter_door_requests</code> which the fleet adapters publish to when their robot requires access through a door. The <code>door_supervisor</code> keeps track of requests from all the fleet adapters in the system and relays the request to the door adapters while avoiding aforementioned conflicts.</p>
<h4><a class="header" href="#lifts" id="lifts">Lifts</a></h4>
<p>The ability to test lift integration is crucial as these systems are often the operational bottlenecks in facilities given their shared usage by both humans and multi robot fleets. As with annotated doors, lifts can be customized in a number of ways in the <code>traffic_editor</code> gui including the dimension &amp; orientation of the cabin and mapping cabin doors to building levels.</p>
<p>TODO: update gazebo image
<img src="images/lift_traffic_editor.png" alt="" /></p>
<p>The <code>building_map_generator gazebo</code> script parses the <code>.building.yaml</code> file for lifts definitions and auto-generates the sdf elements for the cabin, cabin doors as well as lift shaft doors. A prismatic joint is defined at the base of the cabin which is actuated by the lift plugin to move the cabin between different levels. While the cabin doors are part of the cabin structure, the shaft doors are fixed to building. Both sets of doors open/close simultaneously at a given level and are controlled by the lift plugin itself. These doors are created using the same method as other doors in the building and include the door plugin as well. The <code>building_map_generator</code> also appends a lift [plugin](todo add link) element with required parameters to the lift's model sdf block.</p>
<pre><code class="language-xml">&lt;plugin filename=&quot;liblift.so&quot; name=&quot;lift&quot;&gt;
  &lt;lift_name&gt;Lift1&lt;/lift_name&gt;
  &lt;floor elevation=&quot;0.0&quot; name=&quot;L1&quot;&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door1&quot; shaft_door=&quot;ShaftDoor_Lift1_L1_door1&quot; /&gt;
  &lt;/floor&gt;
  &lt;floor elevation=&quot;10.0&quot; name=&quot;L2&quot;&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door1&quot; shaft_door=&quot;ShaftDoor_Lift1_L2_door1&quot; /&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door2&quot; shaft_door=&quot;ShaftDoor_Lift1_L2_door2&quot; /&gt;
  &lt;/floor&gt;
  &lt;floor elevation=&quot;20.0&quot; name=&quot;L3&quot;&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door1&quot; shaft_door=&quot;ShaftDoor_Lift1_L3_door1&quot; /&gt;
  &lt;/floor&gt;
  &lt;reference_floor&gt;L1&lt;/reference_floor&gt;
  &lt;v_max_cabin&gt;2.0&lt;/v_max_cabin&gt;
  &lt;a_max_cabin&gt;1.2&lt;/a_max_cabin&gt;
  &lt;a_nom_cabin&gt;1.0&lt;/a_nom_cabin&gt;
  &lt;dx_min_cabin&gt;0.001&lt;/dx_min_cabin&gt;
  &lt;f_max_cabin&gt;25323.0&lt;/f_max_cabin&gt;
  &lt;cabin_joint_name&gt;cabin_joint&lt;/cabin_joint_name&gt;
&lt;/plugin&gt;
</code></pre>
<p>The plugin subscribes to <code>/lift_requests</code> topic and responds to <code>LiftRequest</code> messages with <code>lift_name</code> matching its <code>model name</code> sdf tag. The displacement between the cabin's current elevation and that of the <code>destination_floor</code> is computed and a suitable velocity is applied to the cabin joint. Prior to any motion, the cabin doors are closed and only opened at the <code>destination_floor</code> if specified in the LiftRequest message. As the cabin and shaft doors are configured with the <code>door</code> plugin, they are commanded through <code>DoorRequest</code> messages published by the <code>lift</code> plugin.
Analogous to the <code>door_supervisor</code>, a <code>lift_supervisor</code> <a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/src/lift_supervisor/main.cpp">node</a> is started in practice to manage requests from different robot fleets.</p>
<h4><a class="header" href="#dispensers" id="dispensers">Dispensers</a></h4>
<p>Robots performing deliveries within facilities is a common use case and hence a <code>Delivery</code> task is configured into the <code>rmf_fleet_adapters</code>. In a delivery task, a payload is loaded onto the robot at one location and unloaded at another. The loading and unloading of the payload may be automated by a robot/workcell in a facility. To integrate these systems (generalized as &quot;dispensers&quot;) with RMF core systems, a set of dispenser messages are <a href="https://github.com/osrf/rmf_core/tree/master/rmf_dispenser_msgs/msg">defined</a>. When the robot reaches the loading station, the <code>rmf_fleet_adapter</code> publishes a <code>DispenserRequest</code> message which the dispenser receives and begins processing. When the dispensing is successful, the dispenser is required to publish a <code>DispenserResult</code> message with <code>SUCCESS</code> status. The <code>rmf_fleet_adapter</code> then instructs the robot to proceed to the unloading station where a similar set of message are exchanged with the workcell unloading the payload.</p>
<p>To replicate this delivery behavior in simulation, the <code>TeleportDispenser</code> and <code>TeleportIngestor</code> <a href="https://github.com/osrf/rmf_demos/tree/master/rmf_gazebo_plugins/src">plugins</a> are designed. These plugins are loaded into <a href="https://github.com/osrf/rmf_demos/tree/master/rmf_demo_assets/models">3D models</a> the same names. 
To setup a payload loading station:</p>
<ul>
<li>Assign a <code>workcell_name</code> attribute to the waypoint (see figure below)</li>
<li>Add a <code>TeleportDispenser</code> model beside the waypoint with <code>name</code> matching the <code>workcell_name</code></li>
<li>Add the payload model beside the <code>TeleportDispenser</code> model (Coke can in image below)</li>
</ul>
<p>To setup a payload unloading station:</p>
<ul>
<li>Assign a <code>workcell_name</code> attribute to the waypoint (see figure below)</li>
<li>Add a <code>TeleportIngestor</code> model beside the waypoint with <code>name</code> matching the <code>workcell_name</code></li>
</ul>
<p>When a <code>DispenserRequest</code> message is published with <code>target_guid</code> matching the name of the <code>TeleportDispenser</code> model, the plugin will teleport the payload onto the nearest robot model. Conversely, when the <code>target_guid</code> matches the name of the <code>TeleportIngestor</code> model, the <code>TeleportIngestor</code> plugin will teleport the payload on the robot to its location in the world. The combinations of these plugins allow for delivery requests to be simulation. In the future, this mechanism will be replaced by actual workcells or robot arms but the underlying message exchanges will remain the same.</p>
<p><img src="images/dispensers.png" alt="" /></p>
<h2><a class="header" href="#creating-simulations-and-running-scenarios" id="creating-simulations-and-running-scenarios">Creating Simulations and Running Scenarios</a></h2>
<p>The section aims to provide an overview of the various components in the <code>rmf_demos</code> <a href="https://github.com/osrf/rmf_demos">repository</a> which may serve as a reference for setting up other simulations and assigning tasks to robots. Here, will will focus on the <code>office</code> world.</p>
<h4><a class="header" href="#map-package" id="map-package">Map package</a></h4>
<p>The <code>rmf_demo_maps</code> package houses annotated <code>traffic_editor</code> files which will be used for the 3D world generation. Opening the <code>office.project.yaml</code> file in <code>traffic_editor</code> reveals a single level floorplan that has walls, floors, scale measurements, doors, lanes and models annotated. All the robot lanes are set to <code>bidirectional</code> with <code>graph_idx</code> equal to &quot;0&quot;. The later signifies that all the lanes belong to the same fleet. In the <code>airport</code> world, we have two sets of graphs with indices &quot;0&quot; and &quot;1&quot; which reflect laneways occupiable by two fleets respectively. The figures below highlights special attributes assigned to certain waypoints to indicate robot spawn locations as well as disperser workcells.</p>
<p><img src="images/rmf_demo_maps.png" alt="" /></p>
<p>To export a 3D world file along with the navigation graphs, the <code>building_map_generator</code> script is used. The <code>CMakeLists.txt</code> file of this package is configured to automatically run the generator scripts when the package is built. The outputs are installed to the <code>share/</code> directory for the package. This allows for the generated files to be easily located and used by other packages in the demo.</p>
<pre><code class="language-cmake">foreach(path ${traffic_editor_paths})

  # Get the output world name
  string(REPLACE &quot;.&quot; &quot;;&quot; list1 ${path})
  list(GET list1 0 name)
  string(REPLACE &quot;/&quot; &quot;;&quot; list2 ${name})
  list(GET list2 -1 world_name)

  set(map_path ${path})
  set(output_world_name ${world_name})
  set(output_dir ${CMAKE_CURRENT_BINARY_DIR}/maps/${output_world_name})
  set(output_world_path ${output_dir}/${output_world_name}.world)
  set(output_model_dir ${output_dir}/models)

  # first, generate the world
  add_custom_command(
    OUTPUT ${output_world_path}
    COMMAND ros2 run building_map_tools building_map_generator gazebo ${map_path} ${output_world_path} ${output_model_dir}
    DEPENDS ${map_path}
  )

  add_custom_target(generate_${output_world_name} ALL
    DEPENDS ${output_world_path}
  )

  # now, generate the nav graphs
  set(output_nav_graphs_dir ${output_dir}/nav_graphs/)
  set(output_nav_graphs_phony ${output_nav_graphs_dir}/phony)
  add_custom_command(
    OUTPUT ${output_nav_graphs_phony}
    COMMAND ros2 run building_map_tools building_map_generator nav ${map_path} ${output_nav_graphs_dir}
    DEPENDS ${map_path}
  )

  add_custom_target(generate_${output_world_name}_nav_graphs ALL
    DEPENDS ${output_nav_graphs_phony}
  )

  install(
    DIRECTORY ${output_dir}
    DESTINATION share/${PROJECT_NAME}/maps
  )

endforeach()

</code></pre>
<h4><a class="header" href="#launch-files" id="launch-files">Launch Files</a></h4>
<p>The <code>demos</code> package includes all the essential launch files required to bring up the simulation world and start various RMF services. The office simulation is launched using the <code>office.launch.xml</code> file. First, a <code>common.launch.xml</code> file is loaded which starts </p>
<ul>
<li>The <code>rmf_traffic_schedule</code> node responsible for maintaining the database of robot trajectories and monitoring traffic for conflicts. If a conflict is detected, notifications are sent to relevant fleet adapters which begin the negotiation process to find an optimal resolution.</li>
<li>The <code>building_map_server</code> which publishes a <code>BuildingMap</code> message used by UIs for visualization. The executable takes in the path to the relevant <code>.building.yaml</code> file as an argument. The <code>office.building.yaml</code> file installed by the <code>rmf_demo_maps</code> package is located using the <code>find-pkg-share</code> substitution command and is stored in the <code>config_file</code> argument.</li>
<li>The <code>rmf_schedule_visualizer</code> which is an RViz based UI to visualize the traffic lanes, actual positions of the robots, expected trajectory of robots as reflected in the <code>rmf_traffic_schedule</code> and states of building systems such as door and lifts.</li>
<li>The <code>door_supervisor</code> and <code>lift_supervisor</code> nodes to manage requests submitted by fleet adapter and UIs.</li>
</ul>
<pre><code class="language-xml">&lt;!-- Common launch --&gt;
&lt;include file=&quot;$(find-pkg-share demos)/common.launch.xml&quot;&gt;
  &lt;arg name=&quot;use_sim_time&quot; value=&quot;true&quot;/&gt;
  &lt;arg name=&quot;viz_config_file&quot; value =&quot;$(find-pkg-share demos)/include/office/office.rviz&quot;/&gt;
  &lt;arg name=&quot;config_file&quot; value=&quot;$(find-pkg-share rmf_demo_maps)/office/office.building.yaml&quot;/&gt;
&lt;/include&gt;
</code></pre>
<p>The next set of commands in <code>office.launch.xml</code> load the <code>office.world</code> in <code>Gazebo</code> after updating the relevant environment variables with paths to the models, plugins and resources directories.</p>
<pre><code class="language-xml">  &lt;group&gt;
    &lt;let name=&quot;world_path&quot; value=&quot;$(find-pkg-share rmf_demo_maps)/maps/office/office.world&quot; /&gt;
    &lt;let name=&quot;model_path&quot; value=&quot;$(find-pkg-share rmf_demo_maps)/maps/office/models:$(find-pkg-share rmf_demo_assets)/models:/usr/share/gazebo-9/models&quot; /&gt;
    &lt;let name=&quot;resource_path&quot; value=&quot;$(find-pkg-share rmf_demo_assets):/usr/share/gazebo-9&quot; /&gt;
    &lt;let name=&quot;plugin_path&quot; value=&quot;$(find-pkg-prefix rmf_gazebo_plugins)/lib:$(find-pkg-prefix building_gazebo_plugins)/lib&quot; /&gt;

    &lt;executable cmd=&quot;gzserver --verbose -s libgazebo_ros_factory.so -s libgazebo_ros_init.so $(var world_path)&quot; output=&quot;both&quot;&gt;
      &lt;env name=&quot;GAZEBO_MODEL_PATH&quot; value=&quot;$(var model_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_RESOURCE_PATH&quot; value=&quot;$(var resource_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_PLUGIN_PATH&quot; value=&quot;$(var plugin_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_MODEL_DATABASE_URI&quot; value=&quot;&quot; /&gt;
    &lt;/executable&gt;
    &lt;executable cmd=&quot;gzclient --verbose $(var world_path)&quot; output=&quot;both&quot;&gt;
      &lt;env name=&quot;GAZEBO_MODEL_PATH&quot; value=&quot;$(var model_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_RESOURCE_PATH&quot; value=&quot;$(var resource_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_PLUGIN_PATH&quot; value=&quot;$(var plugin_path)&quot; /&gt;
    &lt;/executable&gt;
  &lt;/group&gt;
</code></pre>
<p>Lastly, instances of the &quot;full control&quot; <code>rmf_fleet_adapter</code> are launched for each robot type annotated in the map. The navigation graphs for each fleet as generated by the <code>building_map_generator</code> script is passed via the <code>nav_graph_file</code> argument. For the office map, a single fleet of <code>Magni</code> robots is defined. Hence, a single <code>magni_adapter.launch.xml</code> file configured with the kinematic properties of this robot type along with spatial thresholds used for planning, is launched. Along with the fleet adapter, a <code>robot_state_aggregator</code> node is started. This node aggregates <code>RobotState</code> messages with <code>RobotState.name</code> containing the <code>robot_prefix</code> argument and publishes the aggregate to <code>/fleet_states</code> with <code>FleetState.name</code> specified by the <code>fleet_name</code> argument.</p>
<pre><code class="language-xml">&lt;group&gt;
  &lt;let name=&quot;fleet_name&quot; value=&quot;magni&quot;/&gt;
  &lt;include file=&quot;$(find-pkg-share demos)/include/adapters/magni_adapter.launch.xml&quot;&gt;
    &lt;arg name=&quot;fleet_name&quot; value=&quot;$(var fleet_name)&quot;/&gt;
    &lt;arg name=&quot;use_sim_time&quot; value=&quot;$(var use_sim_time)&quot;/&gt;
    &lt;arg name=&quot;nav_graph_file&quot; value=&quot;$(find-pkg-share rmf_demo_maps)/maps/office/nav_graphs/0.yaml&quot; /&gt;
  &lt;/include&gt;
  &lt;include file=&quot;$(find-pkg-share rmf_fleet_adapter)/robot_state_aggregator.launch.xml&quot;&gt;
    &lt;arg name=&quot;robot_prefix&quot; value=&quot;magni&quot;/&gt;
    &lt;arg name=&quot;fleet_name&quot; value=&quot;$(var fleet_name)&quot;/&gt;
    &lt;arg name=&quot;use_sim_time&quot; value=&quot;true&quot;/&gt;
  &lt;/include&gt;
&lt;/group&gt;
</code></pre>
<p>When testing RMF with hardware, the same launch files can be used with noted exception of not starting <code>Gazebo</code>. More information on running demos with hardware can be found <a href="hardware.html">here</a>.</p>
<h4><a class="header" href="#task-requests" id="task-requests">Task Requests</a></h4>
<p>With the office world launched, robots may be issued tasks to carry out. At present, the rmf_fleet_adapters are designed to fulfil two classes of tasks: 1) <code>Loop</code> requests where a robot is requested to loop between two waypoints and 2) <code>Delivery</code> requests which requires a robot to pick up a payload from a dispenser and drop it off at an unloading station. The <code>rmf_fleet_adapters</code> listen for <code>Loop</code> and <code>Delivery</code> request <a href="https://github.com/osrf/rmf_core/tree/master/rmf_task_msgs/msg">messages</a> published over <code>/loop_requests</code> and <code>delivery_requests</code> topics respectively and assign the task to an available robot in their fleet.</p>
<p>Note: the <code>perform_deliveries</code> parameter in the fleet adapter launch file must be set <code>true</code> to enable the given fleet to perform delivery requests. In the current version it is advised to have only one fleet of robots capable of fulfilling delivery requests as a &quot;task allocator&quot; is yet to be implemented.</p>
<p>The <code>rmf_demo_tasks</code> package is created with two executables, <code>request_loop.py</code> and <code>request_delivery.py</code>, which populate and publish <code>Loop</code> and <code>Delivery</code> messages with supplied arguments. Their usages are shown below. The <code>ROBOT_TYPE</code> argument in both cases should match the <code>FleetState.name</code> of the fleet to be assigned the task. For <code>request_loop</code> the <code>START</code> and <code>FINISH</code> arguments should contain valid waypoint names from the navigation graph while <code>NUM</code> specifies the number of loops between these waypoints. For <code>request_delivery</code>, the <code>PICKUP</code> and <code>DROPOFF</code> arguments must be valid waypoint names with <code>workcell_name</code> fields specified in the <code>traffic_editor</code>. </p>
<pre><code class="language-bash">ros2 run rmf_demo_tasks request_loop -h
usage: request_loop [-h] [-s START] [-f FINISH] [-n NUM] [-i TASK_ID]
                    [-r ROBOT_TYPE]

ros2 run rmf_demo_tasks request_delivery -h
usage: request_delivery [-h] [-p PICKUP] [-d DROPOFF] [-i TASK_ID]
                        [-r ROBOT_TYPE]
</code></pre>
<p>As an alternative, UIs may be developed to send out these requests. More information can be found in the <a href="ui.html">UI</a> chapter. The <code>rmf_demos</code> repository contains a <code>rmf_rviz_plugin</code> package which defines a custom Panel that can be used to send the above commands from RViz. A snapshot of the same is seen below.</p>
<p><img src="images/rmf_panel.png" alt="" /></p>
<h1><a class="header" href="#rmf-core" id="rmf-core">rmf-core</a></h1>
<p>RMF is an umbrella term for a wide range of open specifications and software
tools that aim to ease the integration and interoperability of robotic systems,
building infrastructure, and user interfaces. <code>rmf_core</code> is an implementation
of some of these core scheduling and traffic management systems.</p>
<p>Avoiding mobile robot traffic conflicts is a key functionality of <code>rmf_core</code>.
There are two levels to traffic deconfliction: (1) prevention, and (2)
resolution.</p>
<p><em>Prevention:</em> Whenever possible, it would be good to prevent traffic conflicts
from happening in the first place. To facilitate this, we have implemented a
platform agnostic Traffic Schedule Database. The traffic schedule is a living
database whose contents will change over time to reflect delays, cancelations,
or route changes. All fleet managers that are integrated into RoMi-H must
report the expected itineraries of their vehicles to the traffic schedule. With
the information available on the schedule, compliant fleet managers can plan
routes for their vehicles that avoid conflicts with any other vehicles, no
matter which fleet they belong to. <code>rmf_traffic</code> provides a Planner class to
help facilitate this for vehicles that behave like standard AGVs. In the future
we intend to provide a similar utility for AMRs.</p>
<p><em>Resolution:</em> It is not always possible to perfectly prevent traffic conflicts.
Mobile robots may experience delays because of unanticipated obstacles in their
environment, or the predicted schedule may be flawed for any number of reasons.
In cases where a conflict does arise, <code>rmf_traffic</code> has a Negotiation scheme.
When the Traffic Schedule Database detects an upcoming conflict between two or
more schedule participants, it will send a conflict notice out to the relevant
fleet managers, and a negotiation between the fleet managers will begin. Each
fleet manager will submit its preferred itineraries, and each will respond with
itineraries that can accommodate the others. A third-party judge (deployed by
the system integrator) will choose the set of proposals that is considered
preferable and notify the fleet managers about which itineraries they should
follow.</p>
<h2><a class="header" href="#schedules" id="schedules">Schedules</a></h2>
<p>The schedule is a centralized database of all the intended robot traffic
trajectories in a facility. Note that it's the intended trajectories, so it's
looking into the future. The job of the schedule is to identify conflicts in
the intentions of the different robot fleets and notify the fleets when a
conflict is noticed. It will also facilitate a procedure for the fleets to
automatically resolve their conflict. If no resolution is found in a reasonable
time, the conflict may be escalated to the attention of a human operator.</p>
<h2><a class="header" href="#frequently-asked-questions" id="frequently-asked-questions">Frequently Asked Questions</a></h2>
<h4><a class="header" href="#why-is-this-traffic-management-system-so-complicated" id="why-is-this-traffic-management-system-so-complicated">Why is this traffic management system so complicated?</a></h4>
<p>RMF has a number of system design constraints that create unique challenges for
traffic management. The core goal of RMF is to facilitate system integration
for heterogeneous mobile robot fleets that may be provided by different vendors
and may have different technical capabilities.</p>
<p>Vendors tend to want to keep their computing systems independent from other
vendors. Since vendors are often responsible for ensuring uptime and
reliability on their computing infrastructure, they may view it as an
unacceptable liability to share computing resources with another vendor. This
means that the traffic management system must be able to function while being
distributed across different machines on a network.</p>
<p>Different robot platforms may have different capabilities. Many valuable AGV
platforms that are currently deployed are not able to change their itineraries
dynamically. Some AGV platforms can change course when instructed to, as long
as they stick to a predefined navigation graph. Some AMR platforms can
dynamically navigate themselves around unanticipated obstacles in their
environment. Since RMF is meant to be an enabling technology, it is important
that we design a system that can maximize the utility of all these different
types of systems without placing detrimental constraints on any of them.</p>
<p>These considerations led to the current design of distributed conflict
prevention and distributed schedule negotiation. There is plenty of space
within the design to create simpler and more efficient subsets for categories
of mobile robots that fit certain sets of requirements, but these optimizations
can be added later, building on top of the existing completely generalized
framework.</p>
<h4><a class="header" href="#who-opens-and-closes-doors-and-operates-the-lifts-the-robot-or-rmf-or-both" id="who-opens-and-closes-doors-and-operates-the-lifts-the-robot-or-rmf-or-both">Who opens and closes doors and operates the lifts? The robot or RMF? Or both?</a></h4>
<p>The responsibility of knowing when a door needs to be opened and then sending
the command to open it belongs to the &quot;fleet adapter&quot;. The basic design is:</p>
<ul>
<li>The fleet adapter keeps track of the robot's progress</li>
<li>When the robot needs to go through a door, the fleet adapter will recognize this</li>
<li>The fleet adapter will send a signal to the door to open</li>
<li>Once the door is open, the fleet adapter will command the robot to proceed</li>
<li>Once the robot is through the door, the fleet adapter will command the robot wait until the door is closed</li>
<li>The fleet adapter will command the door to close</li>
<li>Once the door is closed, the fleet adapter will command the robot to proceed</li>
</ul>
<p>The way a fleet adapter knows about the doors is by parsing the navigation
graph that is provided to it. The navigation graph is a required parameter for
the <code>full_control</code> type of fleet adapter. <code>rmf_demos</code> shows an example of
providing a navigation graph to the fleet adapter.</p>
<p>The recommended way to construct a navigation graph is to use the
<code>traffic-editor</code> tool. The <code>rmf_demos</code> repos shows some examples of
<code>traffic-editor</code> project files.</p>
<p>However, it's entirely possible to construct your own navigation graphs. They
use a very simple yaml format.</p>
<h4><a class="header" href="#are-lifts-supported" id="are-lifts-supported">Are lifts supported?</a></h4>
<p>Proper lift support (meaning, specifying an actual lift that can move between
floors, and exporting that information into the navigation graph) is not
something that has been developed yet due to time constraints and the need to
prioritize certain features over others.</p>
<p>However, for testing and demonstration purposes, there are two special
navigation graph edge properties that can allow a RMF fleet adapter to emulate
lift usage. This is meant for demo scenarios where a &quot;mock lift&quot; has been
created that receives lift commands and transmits lift states but does not
actually move between any different floors in a building. For example, tape
on the floor of a lab to indicate the &quot;lift cabin&quot; box, to allow development
and testing without occupying the actual building lift.</p>
<p>These properties were initially included for demonstration purposes, but they
are proving useful enough that we might make them officially supported
properties. Due to the cost and scarcity of &quot;real&quot; lifts, there seems to be
broad interest in having single-floor hardware test setups that emulate
multi-floor scenarios.</p>
<p>The edge properties are:</p>
<ul>
<li><code>demo_mock_floor_name</code>: The name of the floor that the robot is on while traversing the edge</li>
<li><code>demo_mock_lift_name</code>: The name of the lift that is being entered or exited while the robot traverses the edge</li>
</ul>
<p>The idea is that if you have a single floor demonstration environment but want
to demonstrate interaction with a lift, then you can set up a mock &quot;lift&quot; and
imagine that each side of the &quot;lift&quot; opens to a different floor, and the robot
is only allowed to enter/exit that side of the &quot;lift&quot; when the &quot;lift&quot; believes
it is on that floor. This emulates lift cabins with two sets of doors.</p>
<p>To make this idea more concrete, imagine you have a single-floor hardware
testing area, and a box is drawn on the ground with an LED display next to it
that reads off pretend floor names. The mock lift will transmit lift state
messages that match up with whatever floor the LED is displaying. There is also
some indication of whether the lift doors are open or closed. You can further
imagine that entering or exiting from west side of the &quot;lift&quot; is only allowed
when the lift believes it is on floor L1 whereas entering or exiting the &quot;lift&quot;
from the east side is only allowed when it believes it is on floor L3.</p>
<p>In that setup, for a robot to &quot;correctly&quot; navigate from a waypoint on L1 to a
waypoint on L3, the robot needs to:</p>
<ul>
<li>Approach the &quot;lift&quot; from the west side</li>
<li>Call the &quot;lift&quot; down to L1</li>
<li>Wait until the lift state has it on floor L1 with the doors open</li>
<li>Move into the &quot;lift&quot; (i.e. the box drawn on the ground) and request that it &quot;moves&quot; to L3</li>
<li>Wait until the &quot;lift&quot; indicates that it has reached L3 and that its doors are open</li>
<li>Exit the &quot;lift&quot; on the east side</li>
</ul>
<p>A rough ASCII diagram would look like this (numbers are waypoints and letters
are edges):</p>
<p><code>1 &lt;---a---&gt; 2 &lt;---b---&gt; 3</code></p>
<ul>
<li>Waypoint 1 is on floor L1</li>
<li>Waypoint 2 is inside the &quot;lift&quot; named LIFT001</li>
<li>Waypoint 3 is on floor L3</li>
<li>The properties of edge a are:
<ul>
<li>bidirectional: true</li>
<li>demo_mock_floor_name: L1</li>
<li>demo_mock_lift_name: LIFT001</li>
</ul>
</li>
<li>The properties of edge b are:
<ul>
<li>bidirectional: true</li>
<li>demo_mock_floor_name: L3</li>
<li>demo_mock_lift_name: LIFT001</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#if-multiple-fleets-can-do-the-same-task-which-one-is-one-chosen" id="if-multiple-fleets-can-do-the-same-task-which-one-is-one-chosen">If multiple fleets can do the same task, which one is one chosen?</a></h4>
<p>It's not implemented yet, but there's a design worked out for a bidding system
where a task request will be converted to a bid request. The bid request will
be sent to each fleet adapter, and each fleet adapter that can perform the task
will report its best estimate for how soon it would be able to have the task
finished. The fleet adapter that offers the lowest bid will be assigned the
task.</p>
<p>The API and implementation for this is on the backburner right now as we
finalize some of the more critical components.</p>
<h4><a class="header" href="#can-some-robots-have-priority-over-other-robots" id="can-some-robots-have-priority-over-other-robots">Can some robots have priority over other robots?</a></h4>
<p>The negotiation system concept does support prioritization for which robot will
accommodate the other robot(s). Any arbitrary metric or weighting system can be
used when resolving a negotiation. But in the current implementation that we
are using, we are treating all vehicles as equal and choosing the resolution
that minimizes the net delay across all the robots, without any prioritization
or weighting.</p>
<p>Since this codebase is open source, you can easily fork the code and modify it
to use any prioritization system that you'd like. Specifically, replace
<code>rmf_traffic::schedule::QuickestFinishEvaluator()</code> your own
<code>Negotiation::Evaluator</code> class that behaves in whatever way you would like.</p>
<h4><a class="header" href="#what-distance-is-maintained-between-two-robots" id="what-distance-is-maintained-between-two-robots">What distance is maintained between two robots?</a></h4>
<p>This is configurable. There are two relevant parameters: <code>footprint_radius</code> and
<code>vicinity_radius</code>. The <code>footprint_radius</code> represents an estimate of the
vehicle's physical footprint. The <code>vicinity_radius</code> represents an estimate of
the region which the robot needs other vehicles to stay clear of. A &quot;schedule
conflict&quot; is defined as an instance where one vehicle's &quot;footprint&quot; is
scheduled to enter another vehicle's &quot;vicinity&quot;. The job of the negotiation
system is to come up with a fix to the schedule that keeps all vehicles'
&quot;footprints&quot; out of all other vehicles' &quot;vicinities&quot;.</p>
<h1><a class="header" href="#soss" id="soss">SOSS</a></h1>
<p>The system-of-systems synthesizer (SOSS) is a tool which provides protocol
translation between different subsystems. Currently, ROS 2, ROS 1, and
Websockets are supported. Such composite systems can be called The ROS-SOSS.</p>
<h1><a class="header" href="#hardware" id="hardware">Hardware</a></h1>
<p>In this chapter, we will describe the process for adding hardware to RMF,
describing how to build the necessary ROS 2 packages and interfaces that
are used by <code>rmf_core</code>.</p>
<h1><a class="header" href="#map-data-requirements-for-integration-with-romi-h--rmf_core" id="map-data-requirements-for-integration-with-romi-h--rmf_core">Map data requirements for integration with RoMi-H / rmf_core</a></h1>
<h2><a class="header" href="#motivation-1" id="motivation-1">Motivation</a></h2>
<p>RoMi-H / RMF uses robot route maps to be able to predict the future motions of robots in the building. RoMi-H generates &quot;multi-fleet&quot; predictions which can be used to help avoid conflicts between robot fleets and individual robots, provide multi-fleet visualization to building staff, and improve scheduling of resources, among other benefits.</p>
<p>Robot route maps in large buildings are complex and may evolve over time in response to customer requests and building renovations. As a result, RoMi-H works best when scripts can automatically import robot route maps, and re-import them in the future after changes are made.</p>
<h2><a class="header" href="#minimum-map-information-required" id="minimum-map-information-required">Minimum Map Information Required</a></h2>
<ul>
<li>list of waypoints or nodes
<ul>
<li>name of waypoint</li>
<li>level name (B1, L1, L2, etc.)</li>
<li>(x, y) location in meters within the level</li>
<li>any special properties or flags, such as:
<ul>
<li>is this a dropoff/pickup parking point?</li>
<li>is this a charger?</li>
<li>is this a safe parking spot during an emergency alarm?</li>
</ul>
</li>
</ul>
</li>
<li>list of edges or &quot;travel lanes&quot; between nodes
<ul>
<li>(start, end) waypoint names</li>
<li>two-way or one-way traffic?
<ul>
<li>if one-way, identify direction of travel</li>
</ul>
</li>
<li>any other information, such as speed limit along this segment</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#format-requirements" id="format-requirements">Format requirements</a></h2>
<p>We can write import scripts to handle virtually any &quot;open&quot; file format that contains the required information. This includes, in order of preference:</p>
<ul>
<li>YAML</li>
<li>XML</li>
<li>plain text (space or comma-separated ASCII, etc.)</li>
<li>DXF</li>
<li>DWG</li>
<li>SVG</li>
</ul>
<h2><a class="header" href="#comments" id="comments">Comments</a></h2>
<p>If the map data is provided in textual form, screenshots are helpful for &quot;sanity-checking&quot; the coordinate system and alignment with building features.</p>
<h1><a class="header" href="#ui" id="ui">UI</a></h1>
<h1><a class="header" href="#security" id="security">Security</a></h1>
<p>This chapter describes how to use DDS Security tools to provide authentication,
encryption, and access control to a RoMi-H system.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>

<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programming Multiple Robots with ROS 2</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item "><a href="ros2.html"><strong aria-hidden="true">2.</strong> ROS 2</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ros2_tools_resources.html"><strong aria-hidden="true">2.1.</strong> ROS Resources</a></li><li class="chapter-item "><a href="ros2_design_patterns.html"><strong aria-hidden="true">2.2.</strong> ROS Concepts and Design Patterns</a></li><li class="chapter-item "><a href="ros2_cli.html"><strong aria-hidden="true">2.3.</strong> The ROS Command Line Interface</a></li><li class="chapter-item "><a href="ros2_api.html"><strong aria-hidden="true">2.4.</strong> The ROS API</a></li></ol></li><li class="chapter-item "><a href="traffic-editor.html"><strong aria-hidden="true">3.</strong> Traffic Editor</a></li><li class="chapter-item "><a href="simulation.html"><strong aria-hidden="true">4.</strong> Simulation</a></li><li class="chapter-item "><a href="rmf-core.html"><strong aria-hidden="true">5.</strong> RMF Core Overview</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rmf-core_faq.html"><strong aria-hidden="true">5.1.</strong> Frequently Asked Questions</a></li></ol></li><li class="chapter-item "><a href="soss.html"><strong aria-hidden="true">6.</strong> SOSS</a></li><li class="chapter-item "><a href="integration.html"><strong aria-hidden="true">7.</strong> Integration</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="integration_nav-maps.html"><strong aria-hidden="true">7.1.</strong> Navigation Maps</a></li><li class="chapter-item "><a href="integration_fleets.html"><strong aria-hidden="true">7.2.</strong> Mobile Robot Fleets</a></li><li class="chapter-item "><a href="integration_free-fleet.html"><strong aria-hidden="true">7.3.</strong> Free Fleet</a></li><li class="chapter-item "><a href="integration_read-only.html"><strong aria-hidden="true">7.4.</strong> Read-Only Fleets</a></li><li class="chapter-item "><a href="integration_doors.html"><strong aria-hidden="true">7.5.</strong> Doors</a></li><li class="chapter-item "><a href="integration_lifts.html"><strong aria-hidden="true">7.6.</strong> Lifts (Elevators)</a></li><li class="chapter-item "><a href="integration_workcells.html"><strong aria-hidden="true">7.7.</strong> Workcells</a></li></ol></li><li class="chapter-item "><a href="ui.html"><strong aria-hidden="true">8.</strong> User Interfaces</a></li><li class="chapter-item "><a href="security.html"><strong aria-hidden="true">9.</strong> Security</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Programming Multiple Robots with ROS 2</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>In this section, we shall describe the motivation for ROS 2 and the RMF
system for integrating multiple robots.</p>
<h1><a class="header" href="#ros-2" id="ros-2">ROS 2</a></h1>
<p>The Robot Operating System (ROS) is a set of software libraries and tools for building robot applications. From drivers to state-of-the-art algorithms, and with powerful developer tools, ROS has what you need for your next robotics project. And it’s all open source.</p>
<p>Before we talk specifically about ROS 2, let's review some history. Since ROS was started in 2007, a lot has changed in the robotics and ROS community. ROS 1, which at that time was just &quot;ROS&quot;, began life as the development environment for the Willow Garage PR2 robot. The primary goal was to provide the software tools that users would need to undertake novel research and development projects with the PR2. At the same time, the ROS 1 development team knew that the PR2 would not be the only, or even the most important, robot in the world, and they wanted ROS 1 to be useful on other robots. The original focus was on defining levels of abstraction (usually through message interfaces) that would allow much of the software to be reused elsewhere.</p>
<p>It is fair to say that ROS 1 satisfied the PR2 use case, but also overshot by becoming useful on a surprisingly wide variety of robots. ROS 1 was used on robots that are similar to the PR2, but also on wheeled robots of all sizes, legged humanoids, industrial arms, outdoor ground vehicles (including self-driving cars), aerial vehicles, surface vehicles, and more. In addition, ROS 1 adoption was happening in domains beyond the mostly academic research community that was the initial focus. ROS 1-based products were coming to market, including manufacturing robots, agricultural robots, commercial cleaning robots, and others. Government agencies were also looking more closely at ROS for use in their fielded systems; e.g., NASA expected to be running ROS on the Robonaut 2 that was deployed to the International Space Station.</p>
<p>With all these new uses of ROS, the platform became stretched in unexpected ways. While it was holding up well, the ROS 1 team believed that they could better meet the needs of the broader ROS community by tackling their new use cases head-on. And so ROS 2 was born.</p>
<p>The initial goal of the ROS 2 project was to adapt to the changing landscape, leveraging what is great about ROS 1 and improving what isn’t. But there was also a desire to keep ROS 1 as it existed to keep working and be unaffected by the development of ROS 2. So ROS 2 has been built as a parallel set of packages that can be installed alongside and interoperate with ROS 1 (e.g., through message bridges).</p>
<p>As of this writing, we have reacehd the 13th and last official ROS 1 release, <a href="https://www.openrobotics.org/blog/2020/5/23/noetic-ninjemys-the-last-official-ros-1-release">Noetic Ninjemys</a>, and the first LTS release of ROS 2, <a href="https://www.openrobotics.org/blog/2020/6/5/ros-2-foxy-fitzroy-release">Foxy Fitzroy</a>. :tada:</p>
<p>There is a large and growing amount of ROS 2 resources which can be found on the web. A great place to start for ROS 2 is on the ROS Index page for <a href="https://index.ros.org/doc/ros2/">ROS 2</a> and farther along in this book in the ROS 2 chapter. Enjoy your journey!</p>
<h1><a class="header" href="#robotics-middleware-framework-rmf" id="robotics-middleware-framework-rmf">Robotics Middleware Framework (RMF)</a></h1>
<h2><a class="header" href="#motivation-for-rmf" id="motivation-for-rmf">Motivation for RMF</a></h2>
<p>Imagine with us a world where the incredible robots that are available on the market are now able to co-exist in the same facility; gracefully sharing critical resources such as corridors, elevators/lifts, doors and other infrastructure to enable a more efficient overall system. Imagine integrating an elevator/lift for robots only once and this elevator/lift is now enabled to be used for any robot that needs to use the shared resource in a controlled and safe manner. Imagine a world free of robot deadlocks in a shared corridor. These ideas are achievable today using an amazing system called RMF.</p>
<p>Many companies adopt a strategy of operational efficiency and use the lever of technology, thru the deployment of robots and other smart devices, to help realize their goals. The current generation of robots in production environments today are able to provide services including both bulk and single piece flow delivery, cleaning, disinfecting, security, monitoring, and much more. The diversity in robotic use cases most likely means the best in class robots for each task will come from different robot providers or system integrators. This modern reality makes it critical for a common software framework to be in place in order to manage these heterogeneous resources and to ensure that information is being used effectively from different platforms to promote overall system efficiency.</p>
<p>Without an initial goal and plan for a holistically efficient robotics system, there can be a significant but hidden risk for end users when committing to a single system or platform provider. The hidden &quot;walled gardens&quot; are likely to force an end user to limit their selection of future solutions from that particular provider to minimize opearational risk and avoid redundant integration costs. As the scope and scale of robotic deployments increase this problem is exacerbated, leaving the customer with a perception of no good option except to stay with their current provider.</p>
<p>Beyond the increase cost risk of scaling deployment with different providers, there is also the inherent conflict over shared resources such as elevators, doorways, corridors, network bandwidth, chargers, operations-center screen “real estate,” and human resources such as IT personnel and maintenance technicians. As robotic scale increases, it would become more cumbersome for an operations team to consider managing a large, heterogeneous, multi-vendor robot environment.</p>
<p>These problem statements were the foundational motivations for the development of RMF. To unlock the end user's options and increase robotic system selection ultimately means the entire robotic ecosystem can grow. We can collectively grow the pie.</p>
<p>(insert re: funders and collaborators)</p>
<p>Historically ROS development has focused heavily on the software running on or near individual robots. RMF is designed to operate at a higher abstraction layer to create networked fleets of robots that interoperate with building infrastructure systems, enterprise services, IOT devices, and human interfaces. Unlock your facility and your future with RMF.</p>
<h2><a class="header" href="#so-what-is-rmf" id="so-what-is-rmf">So what is RMF?</a></h2>
<p>First and foremost, RMF is a collection of reusable, sclable libraries and tools building on top of ROS 2 which enable the interoperability of heterogeneous fleets of any type of robotic systems. RMF utilizes standardized communication protocals to infrastructure, environments and automation where robots are deployed to optimize the use of critical resources (i.e. robots, elevators/lifts, doors, passageways, etc). It adds intelligence to the system through resource allocation and by preventing conflicts over shared resources through the RMF Core which will be described in detail later in this book. RMF is flexible and robust enough to operate over virtually any communications layer and integrate with any number of IOT devices. The architecture of RMF is designed in such a way to allow scalability as the level of automation in an environment increases. There are various ways for systems and users to interact with RMF via APIs and customizable user interfaces. Once deployed in an environment, RMF will save cost by allowing resources to be shared and integrations to be minimized. In a nutshell, it is what robotic developers and robot customers have been looking for and here it is:</p>
<p><img src="https://user-images.githubusercontent.com/43839559/84993483-e89e3e80-b17b-11ea-8bc9-0a0d559de3ba.png" alt="RMF Book Architecture Diagram" /></p>
<h2><a class="header" href="#how-does-rmf-make-the-magic-happen" id="how-does-rmf-make-the-magic-happen">How does RMF make the magic happen?</a></h2>
<p>One of the principles of RMF's design is to simplify and standardaize messaging as much as possible. You can see in the below diagram of the RMF Core that all of the complex interactions and coordination is currently boiled down to only fourteen standard messages. </p>
<img src="https://raw.githubusercontent.com/osrf/rmf_core/master/docs/rmf_core_integration_diagram.png">
<p>We will explore each of these functional areas in more detail in later chapters of this book but for now we'd like to also introduce some of the other utilities that you will find helpful when developing and integrating with RMF.</p>
<h3><a class="header" href="#rmf-demos" id="rmf-demos">RMF Demos</a></h3>
<p><a href="https://github.com/osrf/rmf_demos">Demonstrations</a> of the capabilities of RMF in various environments. This repository serves as a starting point for working and integrating with RMF.</p>
<h3><a class="header" href="#traffic-editor" id="traffic-editor">Traffic Editor</a></h3>
<p><a href="https://github.com/osrf/traffic_editor">Traffic Editor</a> is a GUI for creating and annotating floorplans to be used in RMF. Thru Traffic Editor you are able create traffic patterns to be used in RMF and introduce simulation models to enhance your virtual simulation environments. The <code>.yaml</code> files can be easily exported for use in Gazebo.</p>
<h3><a class="header" href="#free-fleet" id="free-fleet">Free Fleet</a></h3>
<p><a href="https://github.com/osrf/free_fleet">Free Fleet</a> is an open-source robot fleet management system. For those robot developers who do not have their own fleet manager or who would prefer to use and contribute to an open-source fleet management utility.</p>
<h3><a class="header" href="#systems-of-systems-synthesizer-soss" id="systems-of-systems-synthesizer-soss">Systems of Systems Synthesizer (SOSS)</a></h3>
<p>The <a href="https://github.com/osrf/soss">SOSS</a> you've been missing! SOSS can be used to easily pass messages between various message formats/types including ROS 1, ROS 2, WebSocket, REST, FiWare, DDS, OPC-UA, and more.</p>
<h3><a class="header" href="#rmf-schedule-visualizer" id="rmf-schedule-visualizer">RMF Schedule Visualizer</a></h3>
<p>This <a href="https://github.com/osrf/rmf_schedule_visualizer">visualizer</a> is an rviz-based rmf_core visualizer and control panels (&quot;what is it thinking&quot;) aimed towards developers</p>
<h3><a class="header" href="#romi-dashboard" id="romi-dashboard">RoMi Dashboard</a></h3>
<p>The Robotics Middleware for Healthcare (RoMi-H) is a healthcare specific implementation of RMF. This <a href="http://github.com/osrf/romi-dashboard">dashboard</a> is a web application that provides overall visualization and control over the RoMi-H system. The dashboard is by design more &quot;operator-friendly&quot; compared to the previously mentioned schedule visualizer which is intended to be more functional for RMF or RoMi-H developers.</p>
<h3><a class="header" href="#simulation-assets" id="simulation-assets">Simulation Assets</a></h3>
<p>Open-source and freely distributable <a href="https://app.ignitionrobotics.org/fuel">assets</a> being created and shared to accelerate simulation efforts.</p>
<h2><a class="header" href="#jump-in-the-water-is-fine" id="jump-in-the-water-is-fine">Jump in, the water is fine!</a></h2>
<p>So now you have an idea of what RMF is all about, it's time to jump in. We would suggest if you have not already that you take the time to review the <a href="https://github.com/osrf/rmf_demos">RMF Demos</a> repository and if you want a really quick overview of RMF then take a look at this <a href="https://vimeo.com/405803151">Mock Airport Terminal video demo</a> (Short film Oscar nominations most welcome). We hope you find RMF to be a useful tool to help you scale your robot deployments and operations and we look forward to the many improvements and contributions to come!</p>
<h1><a class="header" href="#an-introduction-to-ros-2" id="an-introduction-to-ros-2">An Introduction to ROS 2</a></h1>
<p>In this chapter we will cover the basics of Robot Operating System (ROS) and
give you all the tools you need to build, debug, and understand robotic
applications. This chapter is laid out from the most general concepts, necessary
for decision makers to make sound decisions, to specific API references needed
by engineers to develop new robotic applications. Somewhere in between high
level concepts, and low level API commands lives the knowledge necessary for
those maintaining and supporting multi-robot deployments in the field.</p>
<p>A good analogy to learning about ROS is the process of learning about motor
vehicles. At the practical, day-to-day level, most people will learn how to
start a vehicle and safely use it on a motorway. For these individuals, learning
about the high level concepts behind ROS, along with application-specific
commands is probably sufficient. Those who enjoy driving often choose to learn
how to repair and maintain their vehicle. If this is your interest level we
recommend learning the basics of the ROS command line interface. This will allow
you to &quot;check the oil&quot; of your robotic systems and make sure everything is
functioning correctly. Finally, if you are the type that would like to swap out
the engine of your vehicle with something more powerful, or potentially build a
wholly new vehicle from scratch, then the ROS API is the set of tools that will
make this possible. Generally speaking, automotive engineers don't appear into
the world fully formed, and the same is true for roboticists. It is advisable to
work through each phase of understanding as you develop your skills with ROS.</p>
<p>Following from our analogy above the process of learning how to use robotic
systems built on ROS can be divided roughly into four parts. This chapter works
through these four parts of the process, using ROS 2. Subsequent chapters then
build upon this knowledge and discuss the subtleties of specific
applications. The four parts of this chapter are as follows.</p>
<ul>
<li>
<p>Meta-discussion of the tools and resources available to help you in the
learning process.</p>
</li>
<li>
<p>A high level discussion to the design patterns use in ROS. These patterns are
roughly analogous to the subsystems you would find in a vehicle (engine,
brakes, safety, climate control, etc).</p>
</li>
<li>
<p>A treatment of the command line interface (CLI) for ROS. The CLI is a set of
programs for starting, inspecting, controlling, and monitoring a ROS
robot. You can think of this topic as teaching you how check a robot's oil,
and read the instrument panel.</p>
</li>
<li>
<p>An introduction to the ROS application programming interface. This section
will show you how to create your own applications and modify existing software
for your specific application.</p>
</li>
</ul>
<p>While this books aims to cover the basics it should be made clear that ROS, like
almost all software is a moving target. Technology moves quickly, and while
print media is helpful and delivering high fidelity instruction, that
instruction can become rapidly outdated. For this reason we start this chapter
with a meta-discussion of ROS resources that can be used to help you in your
learning process.</p>
<h1><a class="header" href="#ros-resources" id="ros-resources">ROS Resources</a></h1>
<p>The most up to date to date information about ROS can be found on the web and
there are a myriad of resources on-line to help you out in your educational or
practical journey. One thing to keep in mind is that ROS, like most software,
has different versions, and the format and structure of commands and API calls
may differ slightly between versions (although the developers try to keep things
as stable as possible). This book is specifically written for <em>ROS 2, Eloquent
Elusor</em>, or ROS Eloquent to be terse. While newer or older versions of ROS will
be generally helpful it is worth paying attention to the version number as there
can be minor changes between versions. ROS has both major versions (i.e. ROS
1, and ROS 2) and minor versions denoted by a pair of matching letter adjectives
and specific nouns related to specific genus and species of turtles
(e.g. Eloquent Elusor, or Foxy Fitzroy). The biggest difference in the CLI and
API come between the major versions, i.e. ROS 1 and ROS 2. There may be minor
changes between minor versions, and usually it is the addition of features, not
their modification or removal. It is worth noting that ROS versions are usually
pegged to specific version of Ubuntu Linux. If your search engine results are
specific enough for your particular problem it is a good practice to append your
ROS version to your search. Moreover, when seeking help or posting questions
online you should always specify the version of ROS version you are using.</p>
<p>ROS grew up with the modern web, and as such it has a variety of tools and
forums to help you solve problems and learn about the API and tools. Some of our
web resources actually pre-date more widely used systems, so it helps to know
where they are and how to use them. Probably the most important resource on the
web for ROS users is <a href="http://anwers.ros.org">answers.ros.org</a>. Answers is a Q&amp;A
website similar to StackOverflow. Once you register for Answers you can ask or
answer any question ROS related. Be aware that asking a question well can be
difficult. You should include as much information as possible to help others
answer your question. This means you should include the ROS version, any
debugging or stack trace information you have, and the offending source code.</p>
<p>Aside from ROS Answers you should check out both the ROS 2 tutorials and API
documentation and the ROS 1 wiki. The ROS 1 wiki can be found at
<a href="http://wiki.ros.org/"><a href="http://wiki.ros.org/">http://wiki.ros.org/</a></a> and while it is specifically
dedicated to ROS 1, much of the information is still relevant to ROS 2. If you
are searching for up to date ROS 2 information your go to source for this
information is the ROS 2 tutorials and API documents located at
<a href="https://index.ros.org/doc/ros2/"><a href="https://index.ros.org/doc/ros2/">https://index.ros.org/doc/ros2/</a></a>. Many of
the tutorials you will find in this book pull directly from this body of
work. If you would like to find the latest ROS news and discuss various ROS
features the ROS Discourse forum at
<a href="https://discourse.ros.org/"><a href="https://discourse.ros.org/">https://discourse.ros.org/</a></a> is your best bet. ROS
discourse is the community hub where developers discuss their latest projects
and debate the finer points of ROS development.</p>
<p>For ROS application developers there are number of tools to help you connect
with the broader ROS developer community. Open Robotics supports
<a href="https://index.ros.org/">index.ros.org</a> which is an extended list of ROS
packages sorted by version. If you are searching for a ROS driver for a
particular piece of hardware then the index is a great place to start. If you
find a package with failing tests, or would like to know the build status of any
ROS package at <a href="http://build.ros.org/">build.ros.org</a>. Similarly, for un-indexed
packages <a href="https://github.com/topics/ros?o=desc&amp;s=updated">GitHub maintains a ROS code
tag</a>. This tag will allow you to
search all of the tagged repositories that are publicly listed. At the time of
writing there were close to 4000 repositories listed on github, so there is a
pretty good chance you'll find what you need.</p>
<p>Finally, there are a variety of unofficial resources that you should be aware of
that can be useful, particularly if you want to keep yourself up to date with
the latest ROS projects and features. Both <a href="https://twitter.com/openroboticsorg">Open
Robotics</a> and
<a href="https://twitter.com/rosorg">ROS</a> maintain  twitter feeds to share the latest
news. We also have a yearly ROS developers conference called
<a href="https://roscon.ros.org/2020/">ROSCon</a>; most talks are freely available
on the web. There are a few other resources that can also be useful including the <a href="https://www.reddit.com/r/ROS/">ROS
subreddit</a> an &quot;unofficial&quot; <a href="https://discord.com/invite/HnVcz5a">ROS Discord</a>.</p>
<h1><a class="header" href="#setting-up-your-computer" id="setting-up-your-computer">Setting Up Your Computer</a></h1>
<p>For this chapter we assume that you are working on a modern desktop with a
discrete graphics card. While a graphics card isn't necessary for this chapter
later chapters will be graphics intensive and having one will greatly improve
the end user experience. Moreover, this book assumes you are working with the
Ubuntu Linux 20.04 operating system. While other operating systems are supported
by ROS 2, all of the tutorials and instructions on this book assume you are
running Linux. If instead use a Mac or Windows PC you can either install ROS 2
Eloquent Elusor using the instructions found in the <a href="https://index.ros.org/doc/ros2/Installation/Eloquent/">ROS 2 installation
instructions</a>. An
alternative path for installation on Mac and PC is to using a virtual
machine. Roughly the process for doing so is as follows:</p>
<ol>
<li>Install virtual machine software like <a href="https://www.virtualbox.org/">Virtual
Box</a> or
<a href="https://www.vmware.com/products/workstation-pro.html">VMWare</a>. On your host
machine.</li>
<li>Create a virtual machine using the software, and install <a href="https://ubuntu.com/download/desktop">Desktop Ubuntu 18.04 Bionic
Beaver from the Canonical website.</a>
Configure the installation as you wish.</li>
<li>Now start your virtual machine and log in as a user. The directions below
should be applicable.</li>
</ol>
<p>For these initial tutorials we will be working with the pre-compiled ROS 2:
Eloquent Elusor desktop version. These directions follow directly from the
installation instructions found on the [Eloquent release
page]https://index.ros.org/doc/ros2/Installation/Eloquent/Linux-Install-Debians/). To
run these commands you'll need a terminal window. To open a terminal in Ubuntu
18.04 click on the nine dots in the bottom left hand of the screen. A dialog
should appear. Enter the word <em>terminal</em> and click on the terminal icon to open
a terminal. Alternatively, you can press the control, alt, and 't' keys
simultaneously to open a terminal (we abbreviate this <code>CTRL-ALT-T</code>).</p>
<h1><a class="header" href="#setup-locale" id="setup-locale">Setup Locale</a></h1>
<p>The first step is to make sure you have a locale which supports <code>UTF-8</code>. What this means is that we
will check that the language used by your computer uses a particular format of
text. If you are in a minimal environment, such as a docker container, the locale may be
something minimal like POSIX. We test with the following settings. It
should be fine if you're using a different UTF-8 supported locale.</p>
<pre><code class="language-{.sourceCode.bash}">sudo locale-gen en_US en_US.UTF-8
sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
export LANG=en_US.UTF-8
</code></pre>
<h1><a class="header" href="#setup-sources" id="setup-sources">Setup Sources</a></h1>
<p>You will need to add the ROS 2 apt repositories to your system. Out of the box
Ubuntu doesn't know where the ROS 2 binary programs live so we have to give it a
secure location. To do this the computer will prompt you for your root
password. For more technical readers we need to authorize the ROS GPG key with
apt by typing the following command in the terminal:</p>
<pre><code class="language-{.sourceCode.bash}">sudo apt update &amp;&amp; sudo apt install curl gnupg2 lsb-release
curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -
</code></pre>
<h1><a class="header" href="#install-ros-2-packages" id="install-ros-2-packages">Install ROS 2 packages</a></h1>
<p>The next steps for installing ROS is to do a system update (i.e. check for newer
programs) and then install ROS Eloquent. To do this we run the following
commands. Be aware that these commands will download a lot of data and may take
awhile. It is best to run these commands on your home network.</p>
<pre><code class="language-{.sourceCode.bash}">sudo apt update
</code></pre>
<p>Desktop Install (Recommended): ROS, RViz, demos, tutorials.</p>
<pre><code class="language-{.sourceCode.bash}">sudo apt install ros-eloquent-desktop
</code></pre>
<p>Next we'll install a set of tutorials called <code>TurtleSim</code>. To do this we run
another apt command.</p>
<pre><code class="language-{.sourceCode.bash}">sudo apt install ros-eloquent-turtlesim
</code></pre>
<p>ROS 2 command line tools use argcomplete for autocompletion. If you
want autocompletion, installing argcomplete is necessary. We're also going to
install a few other tools to make our lives easier.</p>
<pre><code class="language-{.sourceCode.bash}">sudo apt install python3-argcomplete htop byobu
</code></pre>
<h1><a class="header" href="#check-your-installation" id="check-your-installation">Check Your Installation</a></h1>
<p>ROS uses <code>environment variables</code> to help keep track of what version of ROS is
running and where all the programs using ROS are used on the computer. To set
these environment variable we <code>source</code>, or load, a bash script file. A bash
script file isn't magic; it is just a series of commands to enter into the
terminal, just like the series of commands we just entered to setup ROS. It is
possible to have different version of ROS running on a single computer. Using
the wrong version of ROS can lead to all sorts of problems and is a common
mistake for new users! If you are having problems try sourcing the correct ROS
bash file. From now on, whenever you open a new terminal, you will
need to tell the computer which version of ROS to use. To set the necessary
environment variables for ROS you need to <code>source</code> a bash file every time you
open a new terminal. Yes, this is annoying, but it is a sound approach as it
makes the version of ROS you are using explicit. On Ubuntu 18.04 all versions of
ROS live in <code>/opt/ros/</code>. Inside this directory will be a programs and script
files to run ROS. To tell the operating system that we want to use ROS Eloquent
we simply source the ROS Eloquent setup.bash file using the command below.</p>
<pre><code class="language-{.sourceCode.bash}">source /opt/ros/eloquent/setup.bash
</code></pre>
<p>Once that command runs your terminal should be ready to run a ROS program. Let's
test our installation by running two small ROS programs called <code>talker</code> and
<code>listener</code>. These two programs will send data back and forth using ROS to
perform the communication. One program was written in C++ and the other in
Python. Running these two different programs is a quick and easy way to check
that your ROS system is configured correctly. To start the talker run the following command.</p>
<pre><code class="language-{.sourceCode.bash}">source /opt/ros/eloquent/setup.bash
ros2 run demo_nodes_cpp talker
</code></pre>
<p>If everything is working correctly you should see something like the following:</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 run demo_nodes_cpp talker
[INFO] [talker]: Publishing: 'Hello World: 1'
[INFO] [talker]: Publishing: 'Hello World: 2'
[INFO] [talker]: Publishing: 'Hello World: 3'
....
</code></pre>
<p>Now, let's fire up the listener. We're going to use a Python listener in this
example to make sure we installed Python correctly. First we will need a second terminal. We can
open a new terminal tab by entering <code>CTRL-SHIFT-T</code> in our terminal. We can also
create a wholly new terminal by pressing <code>CTRL-ALT-T</code>. Pick whatever works best
for you. Now in your new terminal source your bash file and run the following
command.</p>
<pre><code class="language-{.sourceCode.bash}">source /opt/ros/eloquent/setup.bash
ros2 run demo_nodes_py listener
</code></pre>
<p>If everything is working correctly you should see something like the following:</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 run demo_nodes_py listener
[INFO] [listener]: I heard: [Hello World: 264]
[INFO] [listener]: I heard: [Hello World: 265]
[INFO] [listener]: I heard: [Hello World: 266]
</code></pre>
<p>Now that we have tested our ROS installation we can stop these two programs. In
ROS most programs run in infinite loops until the robot is shut down. To stop
these programs we navigate to the terminal running the program and press the
<code>Ctrl</code> and <code>C</code> keys simultaneously. We call this combo <code>CTRL-C</code> and you can use
it to stop just about any program in a terminal. Use it to stop the talk and
listener programs.</p>
<h1><a class="header" href="#ros-concepts-and-design-patterns" id="ros-concepts-and-design-patterns">ROS Concepts and Design Patterns</a></h1>
<p>As we said, learning about ROS is similar to learning about an
automobile. In fact, a car is a lot like a robot (and sometimes it
really is a robot; cf. the large and active self-driving vehicle
industry). A modern automobile comprises many parts that are
connected to each other. The steering wheel is connected to the front
axle, the brake pedal is connected to the brake calipers, the oxygen
sensor is connected to the fuel injectors, and so on. From this
perspective, a car is a <em>distributed system</em>: each part plays a
well-defined role, communicating (whether electrically or mechanically)
as needed with other parts, and the result of that symphony-like
coordination is a working vehicle.</p>
<p>A key philosophical tenet of ROS is that robotics software should also
be designed and developed as a distributed system. We aim to separate
the functions of a complex system into individual parts that interact
with each other to produce the desired behavior of that system. In ROS
we call those parts <em>nodes</em> and we call the interactions between them
<em>topics</em> (and sometimes <em>services</em>, but we will get to that).</p>
<h2><a class="header" href="#the-ros-communication-graph" id="the-ros-communication-graph">The ROS Communication Graph</a></h2>
<p>Imagine we are building a wheeled robot that chases a red ball. This
robot needs a camera with which to see the ball, a vision system to
process the camera images to figure out where the ball is, a control
system to decide what direction to move, and some motors to move motors
to move the wheels to allow it to move toward the ball. Using ROS we
might construct the system like so:</p>
<p><img src="./images/ros_graph_example.png" alt="image" /></p>
<p>This design separates the software into four ROS <em>nodes</em>: two device
drivers and two algorithms. Those nodes communicate with each other as
shown, via three ROS <em>topics</em>. We call this structure a <em>ROS
communication graph</em>: the nodes are the graph vertices and the topics
are the graph edges. You can tell a lot about a ROS system by examining
its communication graph.</p>
<p>The camera driver node is responsible for handling the details of
interacting with the physical camera, which might happen through a
custom USB protocol, through a vendor-provided library, or in some other
way. Whatever those details, they are encapsulated inside the camera
driver node, which presents a standard <em>topic</em> interface to the rest of
the system. As a result, the blob finder node does not need to know
anything about the camera; it simply receives image data in a standard
format that is used for all cameras in ROS. The output of the blob
finder is the detected location of the red ball, also in a standard
format. Then the target follower node can read in the ball location and
produce the steering direction needed to move toward the ball, again in
a standard format. Finally, the motor driver node's responsibility is to
convert the desired steering direction into the specific instructions
necessary to command the robot's wheel motors accordingly.</p>
<h2><a class="header" href="#publish-subscribe-messaging-topics-and-types" id="publish-subscribe-messaging-topics-and-types">Publish-subscribe messaging: topics and types</a></h2>
<p>With the example of the ball-chasing robot in mind, we can add some terminology
to describe what is happening as the system operates. First, the ROS
communication graph is based on a well-known pattern called <em>publish-subscribe
messaging</em>, or simply <em>pub-sub</em>. In a pub-sub system, as the name implies, data
are sent as <em>messages</em> from <em>publishers</em> to <em>subscribers</em>. A publisher may have
zero, one, or multiple subscribers listening to its published messages. Messages
may be published at any time, making the system <em>asynchronous</em>.</p>
<p>In ROS, nodes publish and subscribe via topics, each of which has a name and a
type. A publisher announces that it will be publishing data by <em>advertising</em> a
topic. For example, the camera driver node may advertise a topic named <code>/image</code>
with type <code>sensor_msgs/Image</code>. If the blob finder node subscribes to a topic
with the same name and type, then the two nodes find each other and establish a
connection over which image messages can get from the camera driver to the blob
finder (the nodes find each other and establish those connection in a process
called <em>discovery</em>, which will be treated in detail later in this book). Each
message that flows across the <code>/image</code> topic will be of type
<code>sensor_msgs/Image</code>.</p>
<p>A single node can be (and often is) both a publisher and a subscriber. In our
example, the blob finder subscribes to image messages and publishes ball
location messages. Similarly the target follower subscribes to ball location
messages and publishes steering direction messages.</p>
<p>A topic's type is very important. In fact, taken together, the ROS types are
among the most valuable aspects of the entire platform. First, a type tells you
the syntax: which fields, of which types, does the message contain? Second, it
tells you the semantics: what do those fields mean and how they should be
interpreted? For example, a thermometer and a pressure sensor might produce what
appear to be the same data: a floating-point value. But in ROS a well-designed
thermometer driver node would publish one clearly defined type (say,
<code>sensor_msgs/Temperature</code>), while a pressure sensor driver node would publish
another (say, <code>sensor_msgs/FluidPressure</code>).</p>
<p>We always advise the use of semantically meaningful message types.
For example, ROS provides simple message types like <code>std_msgs/Float64</code>, which
contains a single 64-bit floating-point field called <code>data</code>. But you should only
use that sort of generic type for rapid prototyping and experimenting. When you
build a real system, even if something like <code>std_msgs/Float64</code> could get the job
done on syntax, you should instead find or define a message that also matches
the semantics of your application.</p>
<h2><a class="header" href="#why-publish-subscribe" id="why-publish-subscribe">Why publish-subscribe?</a></h2>
<p>Given that it comes with additional complexity (nodes, topics, types, etc.), it
is reasonable to ask why ROS follows the pub-sub pattern. After more than a
decade of building and deploying ROS-based robot systems, we can identify
several key benefits:</p>
<ul>
<li><strong>Substitution</strong>: If we decide to upgrade the robot's camera, we need
only modify or replace the camera driver node. The rest of the system
never knew the details of the camera anyway. Similarly, if we find a
better blob finder node, then we can just swap it in for the old one and
nothing else changes.</li>
<li><strong>Reuse</strong>: A well-designed blob finder node can be used today on this
robot to chase the red ball, then reused tomorrow on a different robot
to orange cat, and so on. Each new use of a node should require only
configuration (no code) changes.</li>
<li><strong>Collaboration</strong>: By cleanly separating concerns between nodes, we
let our blob finder expert do her work independently of the target
follower expert, with neither of them bothering the device driver
expert. It is often the case that a robot application requires the
combined expertise of many people, and it would be difficult to
overstate the importance of ensuring that they can each contribute
confidently and efficiently.</li>
<li><strong>Introspection</strong>: Because the nodes are explicitly communicating with
each other via topics, we can listen in. So when the robot fails to
chase the red ball, and we think that the problem is in the blob finder,
we can use developer tools to visualize, log, and play back that nodes
inputs and outputs. The ability to introspect a running system in this
way is instrumental to being able to debug it.</li>
<li><strong>Fault tolerance</strong>: Say that the target follower node crashes because
of a bug. If it is running in its own process, then that crash will
not bring down the rest of the system, and we can get things working
again by just restarting the target follower. In general with ROS we
have the choice to run nodes in separate processes, which allows for
such fault tolerance, or run them together in a single process, which
can provide higher performance (and of course we can mix and match the
two approaches).</li>
<li><strong>Language independence</strong>: It can happen that our blob finder expert
writes her computer vision code in C++, while our target follower
expert is dedicated to Python. We can accommodate those preferences
easily by just running those nodes in separate processes. In ROS, it is
perfectly reasonable, and in fact quite common, to mix and match the use
of languages in this way.</li>
</ul>
<h2><a class="header" href="#beyond-topics-services-actions-and-parameters" id="beyond-topics-services-actions-and-parameters">Beyond topics: services, actions, and parameters</a></h2>
<p>Most ROS data flow over topics, which we introduced in the previous
sections. Topics are best for streaming data, which includes a lot of
the common use cases in robotics. For example, going back to our
ball-chasing robot, most cameras will naturally produces a stream of
images at some rate, say, 30Hz. So it makes sense for the camera driver
to publish the ROS messages containing those images just as soon as
they're received. Then the blob finder will be receiving image messages
at 30Hz, so it might as well publish its ball location messages at the
same rate, and so on, through the target follower to the motor driver.
We might say that such a systems is <em>clocked from the camera</em>: the data
rate of the primary sensor, the camera in this case, drives the rate of
computation of the system, with each node reacting in to receipt of
messages published via topics by other nodes. This approach is fairly
common and is appropriate for system like our ball-chasing robot. There
is no reason to do any work until you have a new camera image, and once
you have one you want to process it as quickly as possible and then
command an appropriate steering direction in response.</p>
<p>(We are making various simplifying assumptions, including that there is
sufficient computational capacity to run all the nodes fast enough to
keep up with the camera's data rate; that we do not have a way to predict
where the ball is going in between camera frames; and that the motors
can be commanded at the same rate the camera produces images.)</p>
<h3><a class="header" href="#services" id="services">Services</a></h3>
<p>So topics get the job done for the basic ball-chasing robot. But now say
that we we want to add the ability to periodically capture an
ultra-high-resolution image. The camera can do it, but it requires
interrupting the usual image stream that we rely on for the application,
so we only want it to happen on demand. This kind of interaction is a
poor fit for the publish-subscribe pattern of a topic. Fortunately, ROS
also offers a request-reply pattern in a second concept: <em>services</em>.</p>
<p>A ROS service is form of remote procedure call (RPC), a common concept
in distributed systems. Calling a ROS service is similar to calling a
normal function in a library via a code API. But because the call may be
dispatched to another process or even another machine on the network,
there is more to it than just copying pointers around. Specifically, a
ROS service is implemented using a pair of ROS messages: a <em>request</em> and
a <em>reply</em>. The node calling the service populates the request message
and sends it to the node implementing the service, where the request is
processed, resulting in a reply message that is sent back.</p>
<p>We might implement the new high-res snapshot capability like so:</p>
<ul>
<li><strong>Define a new service type.</strong> Because services are less widely used than
topics, there are relatively few &quot;standard&quot; service types predefined.
In our case, the new service's request message might include the desired
resolution of the snapshot. The request message could be a standard
<code>sensor_msgs/Image</code>.</li>
<li><strong>Implement the service.</strong> In the camera driver, we would
advertise the newly defined service so that when a request is
received, the usual image-handling is interrupted temporarily to allow
the device interaction necessary to grab one high-res snapshot, which is
then packed into a reply message and sent back to the node that called
the service.</li>
<li><strong>Call the service.</strong> In the target follower node, we might add a
timer so that every 5 minutes, it calls the new service. The target
follower would receive the high-res snapshot in response to each call,
and could then, say, add it to a photo gallery on disk.</li>
</ul>
<p>In general, if you have a need for infrequent, on-demand interactions
among nodes, ROS services are a good choice.</p>
<h3><a class="header" href="#actions" id="actions">Actions</a></h3>
<p>Sometimes, when building robot control systems, there is a need for an
interaction that looks like request-reply, but that can require a lot of
time between the request and the reply. Imagine that we want to wrap up
our ball-chasing control system into a black box that can be invoked as
part of a larger system that makes the robot play football. In this
case, the higher level football controller will periodically want to
say, &quot;please chase the red ball until you have it right in front of
you.&quot; Once the ball is in front of the robot, the football controller
wants to stop the ball-chasing controller and invoke the ball-dribbling
controller.</p>
<p>We <em>could</em> achieve this kind of interaction with a ROS service. We could
define a chase-ball service and implement it in the target follower.
Then the football controller could call that service when it wants the
ball chased. But ball-chasing may take quite some time to complete, and
it may fail to complete. Unfortunately, after calling the chase-ball
service, the football controller is stuck waiting for the reply, similar
to the situation in which you call a long-running function in code. The
football controller does not know how well (or poorly) the chase is
going, and it cannot stop the chase.</p>
<p>For such goal-oriented time-extended tasks, ROS offers a third concept
that is similar to services but more capable: <em>actions</em>. A ROS action is
defined by three ROS messages: a goal, a result, and feedback. The goal,
sent once by the node calling the action to initiate the interaction,
indicates what the action is trying to achieve; for ball-chasing it
might be the minimum required distance to the ball. The result, sent
once by the node implementing the action after the action is complete,
indicates what happened; for ball-chasing it might be final distance to
the ball after the chase. The feedback, sent periodically by the node
implementing the action until it is complete, updates the caller on how
things are going; for ball-chasing it might be the current distance to
the ball during the chase. In addition, actions are cancelable, so the
football controller can decide to give up and move onto another tactic
if the case is taking too long or if the feedback messages are showing
that there is little chance of success.</p>
<p>In general, if you want to support on-demand long-running behaviors, ROS
actions are a good choice.</p>
<h3><a class="header" href="#parameters" id="parameters">Parameters</a></h3>
<p>Any nontrivial system requires configuration, and ROS is no exception.
When we start our robot's motor driver node, how do we tell it to
connect to the motors via <code>/dev/ttyUSB1</code>? We do not want to hard-code
that information into the node, because on the next robot it might be
<code>/dev/ttyUSB0</code> instead. ROS addresses such configuration needs via a
fourth concept: <em>parameters</em>. A ROS parameter is what you might expect:
a named, typed, place to store a piece of data. For example, the motor
driver node may define a parameter called <code>serial_port</code> with type
string. When it starts up, the node would use the value of that
parameter to know which device to open to get to the motor system.</p>
<p>ROS parameters can be set in a few ways:</p>
<ul>
<li><strong>Defaults.</strong> A ROS node that uses a parameter must embed in its code
some default value for that parameter. In the case that nothing else
in the system sets the parameter value explicitly, the node needs some
value to work with.</li>
<li><strong>Command-line.</strong> There is standard syntax for setting parameter
values on the command-line when launching a node. Values set in this
manner override defaults in the code.</li>
<li><strong>Launch files.</strong> When launching nodes via the <code>launch</code> tool instead
of manually via the command-line, you can set parameter values in the
launch file. Values set in this manner override defaults in the code.</li>
<li><strong>Service calls.</strong> ROS parameters are dynamically reconfigurable via a
standard ROS service interface, allowing them to be changed on the
fly, if the node hosting the parameters allows it. Values set in this
manner override whatever previous values were set.</li>
</ul>
<p>For most nodes, parameter management is relatively simple: define a
handful of parameters, each with a reasonable default; retrieve the
parameters' values at startup, which accounts for changes made via
command-line or launch file; then begin execution and disallow future
changes. This pattern makes sense for the motor driver, which needs to
know which <code>/dev/ttyUSB</code> device file to open at startup, and does not
support changing that setting later. But there are cases that require
more sophisticated handling. For example, the blob finder node may
expose as parameters a variety of thresholds or other settings that
configure how it identifies the red ball in images. These kinds of
settings can be changed on the fly, which the target follower might want
to do, based on how well the chase is going. In this case the blob
finder needs to be sure to use the latest values for its parameters,
knowing that they may have been changed by another node.</p>
<p>In general, when you want to store stable, but possibly changeable,
configuration information in a node, ROS parameters are a good choice.</p>
<h2><a class="header" href="#asynchrony-in-code-callbacks" id="asynchrony-in-code-callbacks">Asynchrony in code: callbacks</a></h2>
<p>Throughout ROS, you will see a common pattern in the code, which is the
use of <em>callback functions</em>, or simply <em>callbacks</em>. For example, when
subscribing to a topic, you supply a callback, which is a function that
will be invoked each time your node receives a message on that topic.
Similarly, when you advertise a service, you supply a callback that is
invoked when the service is called. The same goes for actions (for
handling of goals, results, and feedback) and parameters (for handling
of setting new values).</p>
<p>Programming with callbacks is not familiar to everyone. It differs from the
standard sequential presentation of programming, in which you write a <code>main()</code>
function that does A, then B, then C, and so on. By contrast, in ROS (and in
most systems that focus on data-processing and/or control), we follow an
event-based pattern. In this pattern, we do A whenever X happens, B whenever Y
happens, and so on.</p>
<p>A common structure for a ROS node is the following:</p>
<ul>
<li><strong>Get parameter values.</strong> Retrieve the node's configuration,
considering defaults and what may have been passed in from outside.</li>
<li><strong>Configure.</strong> Do whatever is necessary to configure the node, like
establish connections to hardware devices.</li>
<li><strong>Set up ROS interfaces.</strong> Advertise topics, services, and/or actions;
and subscribe to services. Each of these steps supplies a callback
function that is registered by ROS for later invocation.</li>
<li><strong>Spin.</strong> Now that everything is configured and ready to go, hand
control over to ROS. As messages flow in and out, ROS will invoke the
callbacks you registered.</li>
</ul>
<p>Following this structure, a <code>main()</code> function in a ROS node is often very
short: initialize and configure everything, then call a spin function to let
ROS take over. When you are trying to understand what is happening in a ROS
node, look in the callbacks; that is where the real work is happening.</p>
<h1><a class="header" href="#the-ros-command-line-interface" id="the-ros-command-line-interface">The ROS Command Line Interface</a></h1>
<p>The ROS command line interface, or CLI for short, is a set of programs for
starting, inspecting, controlling, and monitoring a ROS robot. The best way to
think of the CLI is a collection of small and simple programs that allow you
perform basic tasks in ROS. Drawing from our car analogy, the CLI can be thought
of as the subsystems of a vehicle, the breaks, the transmission, the window
wipers; all of the smaller parts that are composed together to build the larger
vehicle. What we'll show you in this section is how to turn on the car, put it
gear, turn on the radio, and perhaps check your oil to perform routine
maintenance. The ROS 2 CLI draws heavily from the Unix/Linux philosophy of small
programs that can be composed together. If you are familiar with the command
line interface found in Unix and Linux, or to a lesser extent in MacOS or
Windows you'll feel right at home.</p>
<p>The ROS command line tools draw heavily from the design patterns mentioned in the
previous section, and directly interface with the APIs we will treat in the next
section. The CLI interface is at its core just a set of simple tools built from
the ROS 2 API, this API is simply an implementation of the high-level patterns
we discussed in the previous section. If your goal is to simply interface with a
particular piece of software written using ROS, the CLI interface is the way you
will go about starting, stopping, and controlling the underlying ROS
software. For more advanced users these tools will allow you to study a ROS
system by exploring the underlying software processes in the system.</p>
<p>There are only two things you need to memorize from this section. It is actually
quite an amazing feat; everything you need to know about the ROS 2
CLI can be derived from just two simple commands. From these two
commands you can figure out everything else fairly quickly! Are you ready to
learn the two magic commands? The first command simply tells your computer that
you are using ROS, and what version of ROS you want to use. Let's take a look at
the magic command, you've actually already seen it before:</p>
<pre><code class="language-{.sourceCode.bash}">source /opt/ros/eloquent/setup.bash
</code></pre>
<p>If everything is working correctly this command should simply return. Nothing
happens that you can see, but underneath the hood all sorts of magic has just
occurred. What you've just done is told this particular shell that you are using
ROS 2 Eloquent Elusor, and where all the ROS programs and files live. You should
plan on doing this every time you want to use ROS. The most common mistake new
users have is not running this command. If you're not sure if your ran the
command in a shell, that's okay. The command is idempotent; meaning running it
twice in a row won't break anything. You can run it a million times in a row and
it won't make any difference.</p>
<p>The other command you need to commit to memory is <code>ros2</code>. That's it. That's all
there is to it. Almost everything in the ROS 2 CLI starts with <code>ros2</code>. Go ahead,
try it, in the same shell where you just sourced the setup file. If everything
is working correctly you should see the following:</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2
usage: ros2 [-h] Call `ros2 &lt;command&gt; -h` for more detailed usage. ...

ros2 is an extensible command-line tool for ROS 2.

optional arguments:
  -h, --help            show this help message and exit

Commands:
  action     Various action related sub-commands
  component  Various component related sub-commands
  daemon     Various daemon related sub-commands
  doctor     Check ROS setup and other potential issues
  interface  Show information about ROS interfaces
  launch     Run a launch file
  lifecycle  Various lifecycle related sub-commands
  msg        Various msg related sub-commands
  multicast  Various multicast related sub-commands
  node       Various node related sub-commands
  param      Various param related sub-commands
  pkg        Various package related sub-commands
  run        Run a package specific executable
  security   Various security related sub-commands
  service    Various service related sub-commands
  srv        Various srv related sub-commands
  topic      Various topic related sub-commands
  wtf        Use `wtf` as alias to `doctor`

  Call `ros2 &lt;command&gt; -h` for more detailed usage.

</code></pre>
<p>The command just told you everything there is to know about the ROS 2 CLI. From
this one command you can figure out what every single ROS 2 CLI program does and
how to use it. If you study the list above you'll notice that there is a long
list of commands. The ROS 2 CLI has a syntax just like most languages. Just like
all English sentences start with a capital letter, all ROS CLI commands start
with <code>ros2</code> followed by a command. After the command any number of other things
can come, but most of the commands will tell you and show you what they
want. The rest of this section just walks through each of the commands one by
one.</p>
<p>It is worth noting before we move on one particular trick. If you are new to the
command line there are two things that will make your life much much
easier. Writing commands using the command line is tricky and error
prone. There are a couple of tools you can use to make the process much
smoother. The first is the <code>TAB</code> key. The tab key is magic in the command line
as it attempts to auto complete whatever you type. The tab button can't read
your mind, but for common command combinations you usually only need to type the
first one or two letters. Another tool is the up arrow key. When you use the
command line sometimes you mistype a command, or need to rerun a
command. Pressing the up key will cycle through the previous commands which you
can either rerun, or edit as needed.</p>
<h1><a class="header" href="#running-your-first-ros-program" id="running-your-first-ros-program">Running Your First ROS Program</a></h1>
<p>Let's get started with our first ROS CLI command. The first command we'll visit
is <code>run</code>. Let's start by looking at the documentation for the run command. First
we'll type <code>ros2 run</code> and see what happens. Give it a try, you won't break
anything.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 run
usage: ros2 run [-h] [--prefix PREFIX] package_name executable_name ...
ros2 run: error: the following arguments are required: package_name, executable_name, argv
</code></pre>
<p>This output is helpful, but not <em>that</em> helpful. There is one trick to get more
complete information about a ROS 2 command, simply ask the command for help by
adding <code>--help</code> to the command. Let's try that again.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 run --help
usage: ros2 run [-h] [--prefix PREFIX] package_name executable_name ...

Run a package specific executable

positional arguments:
  package_name     Name of the ROS package
  executable_name  Name of the executable
  argv             Pass arbitrary arguments to the executable

optional arguments:
  -h, --help       show this help message and exit
  --prefix PREFIX  Prefix command, which should go before the executable.
                   Command must be wrapped in quotes if it contains spaces
                   (e.g. --prefix 'gdb -ex run --args').
</code></pre>
<p>Much better! Let's take a look at the results. We can see that <code>ros2 run</code> is the
command to, &quot;Run a package specific executable.&quot; In ROS 2 collections of ROS
software are gathered into logical units called <code>packages</code>. Each package
contains all of the source code for the package as a variety of other data that
tells ROS how to build and compile the package and the names of all the
programs, also called <code>executables</code>, that can be found in the package. The line
below the description then gives the <em>positional arguments</em> for the
package. Positional arguments are the words and values that come after <code>ros2</code>
and the command you run. In this case the syntax for the command sentence we
want to write is as follows:</p>
<p><code>ros2 run &lt;package name&gt; &lt;program/executable name&gt; &lt;args&gt;</code></p>
<p>There is one piece of missing information here. What is this <code>argv</code> that the
command is asking for? The <code>argv</code> element is programmer short hand for variable
arguments, and it simply means, &quot;some number of additional arguments that are
determined by the executable`. It is worth noting that a program can have zero
arguments and you can just leave it blank. This is actually how a lot of
programs work. Just to make this very clear, let's say we had a package
called <em>math</em>, and an executable called <em>add</em> that takes in two numbers and
returns the result. In this case <em>argv</em> would be the two numbers to add. The
final command would look like:</p>
<p><code>ros2 run math add 1 2</code></p>
<p>Finally, below the positional arguments we have <em>optional arguments</em>. These
arguments are, as the name would suggest, optional. You don't need to included
them, unless you need to.</p>
<p>Now that we've looked into our help file let's run our first ROS program. For
these tutorials we're going to use a package called &quot;turtlesim&quot;, and the program
we want to run is &quot;turtlesim_node.&quot; Let's run this program (remember your tab
complete!). Your command should look like the following:</p>
<p><code>ros2 run turtlesim turtlesim_node</code></p>
<p>If everything goes smoothly you should see the following</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 run turtlesim turtlesim_node
[INFO] [turtlesim]: Starting turtlesim with node name /turtlesim
[INFO] [turtlesim]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]
</code></pre>
<p>A window should also pop up with a cute little turtle that looks like the one
below.</p>
<p><img src="./images/turtle.png" alt="image" /></p>
<p>The real power in ROS, isn't that it can run a program, it is that it can run
lots of programs all that same time, all talking together to make a robot, or
multiple robots, all working together. To illustrate this let's run a second ROS
program that makes our little turtle move around</p>
<p>To do this we'll first open a new terminal (using <code>CTRL-SHIFT-T</code>). Next we'll
tell that terminal that we want to use ROS Eloquent by using the <code>source /opt/ros/eloquent/setup.bash </code>. Finally, we'll run another program in the
<code>turtlesim</code> package to draw a square. See if you can find the program
yourself. If everything works you should have typed the following, and the
following output should be visible.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ source /opt/ros/eloquent/setup.bash
kscottz@kscottz-ratnest:~$ ros2 run turtlesim draw_square
[INFO] [draw_square]: New goal [7.544445 5.544445, 0.000000]
[INFO] [draw_square]: Reached goal
[INFO] [draw_square]: New goal [7.448444 5.544445, 1.570796]
[INFO] [draw_square]: Reached goal
</code></pre>
<p>Your screen should look roughly like this:</p>
<p><img src="./images/turtlesim_square.png" alt="image" /></p>
<p>It is worth noting that You can stop any ROS program by typing the <code>Ctrl</code> and
<code>C</code> keys at the same time in the terminal , we call this <code>CTRL-C</code>. The astute reader may notice
that <code>CTRL-C</code> is usually used at the hotkey combination for copy. For arcane
reasons on most flavors of linux terminal <code>CTRL-C</code> ends a program while
<code>CTRL-SHIFT-C</code> and <code>CTRL-SHIFT-V</code> is used to paste. The reasons for this are
arcane and not worth discussing, just accept this confusing detail that you
must remember. Feel free to try it out. Start and stop the programs and then
restart them.</p>
<h1><a class="header" href="#ros-topics" id="ros-topics">ROS Topics</a></h1>
<p>As it stands we now have two ROS 2 programs running from the <code>turtlesim</code> package,
<code>turtle_node</code> and <code>draw_square</code>. If we reflect on this for a moment we have
<code>turtle_node</code> that draws our turtle simulation, and <code>draw_square</code> spitting out
commands that make the turtle in <code>turtle_node</code> move around. How are these two
programs communicating? ROS programs, also called <em>nodes</em>, communicate over
<em>topics</em> on the ROS <em>message bus</em>. ROS <em>topics</em> are very similar to telephone
numbers. In the US, like most countries, telephone numbers are broken into
logical sections. In North America, you start with a country code,
followed by a three digit area code, followed by an exchange, and then finally a
house number. ROS topics are very similar but instead of using numbers,
parethesis, and dashes to break up these sections, ROS topics use words and
slashes. Another analogy for ROS topics are the file systems where files are
located in a directory structure broken up by slashes (e.g. C:\foo\bar or
/home/foo/bar). No matter how you do it, these symbols all work to logically
group things together, and topic is just a stream of data arranged in a smart
way. For example, in a vehicle running ROS, the positions of each wheel may be
organized as follows:</p>
<pre><code>/wheels/front/driver/velocity
/wheels/front/passenger/velocity
/wheels/rear/driver/velocity
/wheels/rear/passenger/velocity
</code></pre>
<p>The key thing to realize about topics, is that they are more like phone numbers
than a file system in that the data they contain is dynamic, meaning it changes
constantly. In our vehicle example the velocity of each wheel might be measured
one thousand times a second or more. Since the data in a ROS topic is constantly
changing an important distinction for a topic is whether the topic is &quot;creating&quot;
or as we like to say in ROS <code>publishing</code>, or if it is reading the data, what we call
<code>subscribing</code> to the topic. Another way to think of subscribing is <em>listening</em>,
this is to say, you listening to values being <em>published</em> on the topic to which
the node has <em>subscribed</em>. Many ROS nodes subscribe to one set of topics,
process that input data, and then publish to another set of topics.</p>
<p>Let's return to our turtlesim example and see if we can use the ROS CLI to
understand the topics, publishers, and subscribers. Let's example the help
information for the <code>topic</code> command. To do this we'll run: <code>ros2 topic --help</code>.</p>
<p>This command outputs the following:</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 topic --help
usage: ros2 topic [-h] [--include-hidden-topics]
                  Call `ros2 topic &lt;command&gt; -h` for more detailed usage. ...

Various topic related sub-commands

optional arguments:
  -h, --help            show this help message and exit
  --include-hidden-topics
                        Consider hidden topics as well

Commands:
  bw     Display bandwidth used by topic
  delay  Display delay of topic from timestamp in header
  echo   Output messages from a topic
  find   Output a list of available topics of a given type
  hz     Print the average publishing rate to screen
  info   Print information about a topic
  list   Output a list of available topics
  pub    Publish a message to a topic
  type   Print a topic's type

  Call `ros2 topic &lt;command&gt; -h` for more detailed usage.
</code></pre>
<p>Like a Russian nesting doll this ROS command has subcommands! There are quite a
few subcommands; we won't give a treatment of all of them, but let's look at a
few of them.What's great about the ROS CLI is that the subcommands have their
own help command! Why don't we examine the <code>list</code> command. Repeating our command
pattern let's try running <code>ros2 topic list --help</code>.</p>
<pre><code class="language-{.sourceCode.bash}">usage: ros2 topic list [-h] [--spin-time SPIN_TIME] [-t] [-c]
                       [--include-hidden-topics]

Output a list of available topics

optional arguments:
  -h, --help            show this help message and exit
  --spin-time SPIN_TIME
                        Spin time in seconds to wait for discovery (only
                        applies when not using an already running daemon)
  -t, --show-types      Additionally show the topic type
  -c, --count-topics    Only display the number of topics discovered
  --include-hidden-topics
                        Consider hidden topics as well
						
</code></pre>
<p>As indicated at the top of this command help file, <code>ros2 topic list</code> does the
following, &quot;Output a list of available topics.&quot; There appears to be a variety of
<em>optional</em> arguments that we don't need to include if we don't want to. However,
the <code>-t, --show-types</code> line looks interesting. It is worth noting that command
arguments, sometimes called flags, can have two types. A short form indicated
with a single dash (&quot;-&quot;), and a long form indicated by a double dash
(&quot;--&quot;). Don't worry, despite looking different both versions of the argument do
the same thing. Let's try running this command, subcommand pair with the
<code>-show-types</code> argument.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 topic list --show-types
/parameter_events [rcl_interfaces/msg/ParameterEvent]
/rosout [rcl_interfaces/msg/Log]
/turtle1/cmd_vel [geometry_msgs/msg/Twist]
/turtle1/color_sensor [turtlesim/msg/Color]
/turtle1/pose [turtlesim/msg/Pose]
</code></pre>
<p>What does this all mean!? On the left hand side we see all of the ROS topics
running on the system. We can see that most of them are gathered in the
<code>/turtle1/</code> group. This group defines all the inputs and outputs of the little
turtle on our screen. So what's to the right of the topics? The words in the
brackets (&quot;[]&quot;) define the messages used on the topic. Our car wheel example was
simple, we were only publishing velocity, but ROS allows you to publish more
complex data structures that are defined by a <em>message type</em>. When we added the
<code>--show-types</code> flag we told the command to include this information. We'll dig
into messages in detail a bit later.</p>
<p>One of the more commonly used topic subcommands for the topic command is
<code>info</code>. Unsurprisingly, <code>info</code> provides info about a topic.  Let's peek at its
help file using <code>ros2 topic info --help</code></p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic info --help
usage: ros2 topic info [-h] topic_name

Print information about a topic

positional arguments:
  topic_name  Name of the ROS topic to get info (e.g. '/chatter')

optional arguments:
  -h, --help  show this help message and exit
</code></pre>
<p>That seems pretty straight forward. Let's give it a go by running it on
<code>/turtle1/pose</code></p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic info /turtle1/pose
Type: turtlesim/msg/Pose
Publisher count: 1
Subscriber count: 1
</code></pre>
<p>What does this command tell us? First it tells us the <em>message type</em> for the
pose topic; which is <code>/turtlesim/msg/Pose</code>. From this we can determine that the
message type comes from the <em>turtlesim</em> package, and its type is <code>Pose</code>. ROS
messages have a predefined message type that can be shared by different
programming languages and between different nodes. We can also see that this
topic has a single publisher, that is to say a single node generating data on the
topic. The topic also has a single subscriber, also called a listener, who is
processing the incoming pose data.</p>
<p>For what it is worth, if we just wanted to know the message type of a topic
there is a subcommand just for that called, <code>type</code>. Let's take a look at its
help file and its result.</p>
<pre><code>kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic type --help
usage: ros2 topic type [-h] topic_name

Print a topic's type

positional arguments:
  topic_name  Name of the ROS topic to get type (e.g. '/chatter')

optional arguments:
  -h, --help  show this help message and exit
kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic type /turtle1/pose
turtlesim/msg/Pose
</code></pre>
<p>While it is not part of topic command it is worthwhile for us to jump ahead
briefly and look at one particular command, subcommand pair, namely the <code>interface</code>
command and the show subcommand. This subcommand will print all the
information related to a message type using you can better understand the data
being moved over a topic. In the previous example we saw that the <code>topic type</code>
subcommand told up the <code>/turtle1/pose</code> topic has a type <code>turtlesim/msg/Pose</code>.
But what is a <code>turtlesim/msg/Pose</code> you may ask? We can look at the data
structure transferred by this topic by running: <code>ros2 interface show</code>
subcommand and giving the message type name as an input. Let's look at the help
for this subcommand and its output:</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 interface show --help
usage: ros2 interface show [-h] type

Output the interface definition

positional arguments:
  type        Show an interface definition (e.g. &quot;std_msgs/msg/String&quot;)

optional arguments:
  -h, --help  show this help message and exit

kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 interface show turtlesim/msg/Pose
float32 x
float32 y
float32 theta

float32 linear_velocity
float32 angular_velocity
kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$
</code></pre>
<p>What does all of this mean? The first thing we see in the output is <code>float32</code>
which is just a number type. If you are a computer programmer then this should
look familiar, if you're not a programmer a float is just a number with a
decimal like &quot;1.2345&quot; or &quot;424123123.1231231&quot;. The values <code>x</code> and <code>y</code> are the
position of our turtle, and <code>theta</code> is the direction the head is pointing. The
next two values <code>linear_velocity</code> and <code>angular_velocity</code> are, respectively, how
fast the turtle is moving, and how quickly it is turning. To summarize, this
message tells us where a turtle is on the screen, where it is headed, and how
fast it is moving or rotating.</p>
<p>Now that we know what ROS topics are on our simple turtlesim, and their message
types, we can dig in and find out more about how everything works. If we look
back at our topic subcommands, we can see a subcommand called <code>echo</code>. Echo is
computer jargon that means &quot;repeat&quot; something. If you echo a topic it means you
want the CLI to repeat what's on a topic. Let's look at the <code>echo</code> subcommand's
help text:</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 topic echo --help
usage: ros2 topic echo [-h]
                       [--qos-profile {system_default,sensor_data,services_default,parameters,parameter_events,action_status_default}]
                       [--qos-reliability {system_default,reliable,best_effort}]
                       [--qos-durability {system_default,transient_local,volatile}]
                       [--csv] [--full-length]
                       [--truncate-length TRUNCATE_LENGTH] [--no-arr]
                       [--no-str]
                       topic_name [message_type]

Output messages from a topic

positional arguments:
  topic_name            Name of the ROS topic to listen to (e.g. '/chatter')
  message_type          Type of the ROS message (e.g. 'std_msgs/String')

optional arguments:
  -h, --help            show this help message and exit
  --qos-profile {system_default,sensor_data,services_default,parameters,parameter_events,action_status_default}
                        Quality of service preset profile to subscribe with
                        (default: sensor_data)
  --qos-reliability {system_default,reliable,best_effort}
                        Quality of service reliability setting to subscribe
                        with (overrides reliability value of --qos-profile
                        option, default: best_effort)
  --qos-durability {system_default,transient_local,volatile}
                        Quality of service durability setting to subscribe
                        with (overrides durability value of --qos-profile
                        option, default: volatile)
  --csv                 Output all recursive fields separated by commas (e.g.
                        for plotting)
  --full-length, -f     Output all elements for arrays, bytes, and string with
                        a length &gt; '--truncate-length', by default they are
                        truncated after '--truncate-length' elements with
                        '...''
  --truncate-length TRUNCATE_LENGTH, -l TRUNCATE_LENGTH
                        The length to truncate arrays, bytes, and string to
                        (default: 128)
  --no-arr              Don't print array fields of messages
  --no-str              Don't print string fields of messages
</code></pre>
<p>Wow, that's a lot of features. The top of the help files says that this CLI
program, &quot;output[s] messages from a topic.&quot; As we scan the positional arguments we see one
required argument, a topic name, and an optional message type. We know the
message type is optional because it has square brackets (&quot;[]&quot;) around it. Let's
give the simple case a whirl before we address some of the optional
elements. Two things to keep in mind: first is that  topics are long and easy to mess
up, use the TAB key, second is that this will print a lot of data, fast. You can
use <code>CTRL-C</code> to stop command and stop all the output. Let's take a look at the
<code>/turtle1/pose</code> topic.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic echo /turtle1/pose
x: 5.4078755378723145
y: 7.081490516662598
theta: -1.0670461654663086
linear_velocity: 1.0
angular_velocity: 0.0
---
x: 5.4155988693237305
y: 7.067478179931641
theta: -1.0670461654663086
linear_velocity: 1.0
angular_velocity: 0.0
---
x: 5.423322677612305
y: 7.053465843200684
theta: -1.0670461654663086
linear_velocity: 1.0
angular_velocity: 0.0
---
&lt;&lt; GOING ON FOREVER&gt;&gt;
</code></pre>
<p>What can see all sorts of data. Let's examine what is going on. Between the
dashes (<code>---</code>) is a single ROS message on our topic. If you examine the numbers
closely you can see that they are changing; and changing in relation to the
movement of the turtle. Going back to our car example you can see how this would
be useful for understanding the instantaneous velocity of each of our wheels.</p>
<p>Now that we have the basics down let's dig into a few of the optional
arguments. We see a variety of commands that start with <code>--qos</code>, &quot;QOS&quot; here
means &quot;quality of service&quot; and it is a really cool feature that is only in
ROS 2. Without getting too technical QOS is a way of asking for a certain level
of networking robustness. A ROS system can operate over a network, and just like
streaming video or video games, packets can get dropped or not get to their
destination. The QOS settings help you control which packets are the most
important and should get the highest priority.</p>
<p>Most of the other commands deal with changing the output format of this CLI
program, but there is one in particular that is super handy, and it is also new
in ROS 2. The <code>--csv</code> flag stands for &quot;comma separated values&quot; and it a very
simple way of defining a spreadsheet. What this argument does is make the topic
echo command output data in the comma separate value format. Many command lines
allow you send data from the screen to a file using just a little bit of
magic. What's great about this is it allows you to save data for later
review or analysis. To do this file saving in linux we use the <code>&gt;</code> character
followed by a file name. Below I show two examples of using the <code>--csv</code></p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic echo /turtle1/pose --csv
7.097168922424316,8.498645782470703,2.442624092102051,0.0,0.4000000059604645
7.097168922424316,8.498645782470703,2.449024200439453,0.0,0.4000000059604645
...
&lt;CRTL-C&gt;
kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic echo /turtle1/pose --csv &gt; mydata.csv
&lt;nothing happens&gt;
&lt;CTRL-C&gt;
</code></pre>
<p>The second command above creates a file called mydata.csv. You can look at it
using a CLI utility called <code>less</code> (press q to quit), or open it with your
favorite spreadsheet tool.</p>
<p>Now that we've looked at <code>ros2 topic echo</code> let's take a look at a few other
topic subcommands. One thing you may have noticed is that topics can make a lot
of data! More complex robots, like a self driving car, can saturate a high
speed internet connection with how much data it produces. There are two topic
subcommands that can be used to diagnose performance issues. The first
subcommand is <code>topic hz</code> which is the abbreviation of Hertz, the unit of
frequency, as in the frequency of a radio station. The <code>hz</code> subcommand will
tell you how often a particular topic produces a message. Similarly there is
the <code>topic bw</code> subcommand, where <code>bw</code> stands for bandwidth, which is a
engineering term related to the <em>volume</em> of data being produced. A high
bandwidth connection can move more data, like high definition video, than a low
bandwidth data, which might move a radio show. Let's take a look at the help
for these two commands.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic hz --help
usage: ros2 topic hz [-h] [--window WINDOW] [--filter EXPR] [--wall-time]
                     topic_name

Print the average publishing rate to screen

positional arguments:
  topic_name            Name of the ROS topic to listen to (e.g. '/chatter')

optional arguments:
  -h, --help            show this help message and exit
  --window WINDOW, -w WINDOW
                        window size, in # of messages, for calculating rate
                        (default: 10000)
  --filter EXPR         only measure messages matching the specified Python
                        expression
  --wall-time           calculates rate using wall time which can be helpful
                        when clock is not published during simulation
kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic bw --help
usage: ros2 topic bw [-h] [--window WINDOW] topic

Display bandwidth used by topic

positional arguments:
  topic                 Topic name to monitor for bandwidth utilization

optional arguments:
  -h, --help            show this help message and exit
  --window WINDOW, -w WINDOW
                        window size, in # of messages, for calculating rate
                        (default: 100)
</code></pre>
<p>Both <code>bw</code> and <code>hz</code> follow the same pattern, they simply take in a topic name
followed by a few optional arguments. The only argument worth noting is the
<code>window</code> argument. Both of these commands calculate statistics for a series of
messages, how many messages to use in calculating those statistics in the window
size. The default value for window is 100, so when you call <code>ros2 topic bw</code> it
will first collect 100 messages then use that data to calculate the average
message size. Let's give it a shot (use <code>TAB</code> to complete and <code>CTRL-C</code> to exit)</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic hz /turtle1/pose
average rate: 60.021
	min: 0.001s max: 0.073s std dev: 0.00731s window: 65
average rate: 61.235
	min: 0.001s max: 0.073s std dev: 0.00523s window: 128
kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic bw /turtle1/pose
Subscribed to [/turtle1/pose]
average: 1.44KB/s
	mean: 0.02KB/s min: 0.02KB/s max: 0.02KB/s window: 46
average: 1.52KB/s
	mean: 0.02KB/s min: 0.02KB/s max: 0.02KB/s window: 100
</code></pre>
<p>As we can see above the <code>hz</code> command says that the topic is publishing messages
at 60.021, where the unit is hz, or 60.021 times a second. Notice that the
command give the publishing frequency as an average, followed by the minimum,
maximum, and standard deviation, in seconds. The bandwidth subcommand is very
similar; and we can see that the topic is producing 1.44 kilobytes of data per
second. This command has similar outputs around the minimum, maximum, and mean.</p>
<p>One tool that is handy when exploring topics is understanding their type. While
we have already looked at the <code>interface</code> command to see integral types make up
a topic, the <code>topic</code> command has both a tool to query the type of a topic, and a
means to search all topics for a specific type. If all you want to know is a
topic's type you can use the <code>type</code> command which will return a type that can
then be further explored with the <code>interface</code> command. If instead you would like
to know what topics use a particular message type you can use the <code>topic find</code>
command / subcommand pair. Both the <code>topic type</code> and <code>topic interface</code> command
/ subcommand pairs have a very limited set of optional arguments, so we simply
provide them with our desired topic or message type. Let's take a look at these two commands together: </p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic type --help
usage: ros2 topic type [-h] topic_name
Print a topic's type

positional arguments:
  topic_name  Name of the ROS topic to get type (e.g. '/chatter')

optional arguments:
  -h, --help  show this help message and exit
kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic type /turtle1/pose 
turtlesim/msg/Pose
kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic find --help
usage: ros2 topic find [-h] [-c] [--include-hidden-topics] topic_type

Output a list of available topics of a given type

positional arguments:
  topic_type            Name of the ROS topic type to filter for (e.g.
                        'std_msg/msg/String')

optional arguments:
  -h, --help            show this help message and exit
  -c, --count-topics    Only display the number of topics discovered
  --include-hidden-topics
                        Consider hidden topics as wel
kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic find  turtlesim/msg/Pose 
/turtle1/pose
</code></pre>
<p>The last subcommand for the topic command is <code>pub</code>, pub simply means publish,
and it allows you to publish a command to any ROS topic from the command
line. While you shouldn't need to use this command regularly it can be
particularly handy for testing and debugging when you are building a robot
system. The <code>pub</code> command has a number of optional arguments that allow you to
send one or more message, and with different quality of service (QoS)
presets. The format of the command is <code>ros2 topic pub TOPIC_NAME MESSAGE_TYPE VALUES</code>, which means for it to work successfully you must include a
target topic, the topic's message type, and finally the message's values. The
values for the message are specified in the YAML format and we can use the
<code>interface show</code> command to understand the format. To illustrate the utility of this
command we'll issue a message to rotate and stop  our turtle by publishing
to the <code>/turtle1/cmd_vel/</code> topic. Let's first take a look at the <code>topic pub</code>
documentation before we construct our command:</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic pub --help
usage: ros2 topic pub [-h] [-r N] [-p N] [-1] [-n NODE_NAME]
                      [--qos-profile {system_default,sensor_data,services_default,parameters,parameter_events,action_status_default}]
                      [--qos-reliability {system_default,reliable,best_effort}]
                      [--qos-durability {system_default,transient_local,volatile}]
                      topic_name message_type [values]

Publish a message to a topic

positional arguments:
  topic_name            Name of the ROS topic to publish to (e.g. '/chatter')
  message_type          Type of the ROS message (e.g. 'std_msgs/String')
  values                Values to fill the message with in YAML format (e.g.
                        &quot;data: Hello World&quot;), otherwise the message will be
                        published with default values

optional arguments:
  -h, --help            show this help message and exit
  -r N, --rate N        Publishing rate in Hz (default: 1)
  -p N, --print N       Only print every N-th published message (default: 1)
  -1, --once            Publish one message and exit
  -n NODE_NAME, --node-name NODE_NAME
                        Name of the created publishing node
  --qos-profile {system_default,sensor_data,services_default,parameters,parameter_events,action_status_default}
                        Quality of service preset profile to publish with
                        (default: system_default)
  --qos-reliability {system_default,reliable,best_effort}
                        Quality of service reliability setting to publish with
                        (overrides reliability value of --qos-profile option,
                        default: system_default)
  --qos-durability {system_default,transient_local,volatile}
                        Quality of service durability setting to publish with
                        (overrides durability value of --qos-profile option,
                        default: system_default)
kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ 

</code></pre>
<p>Since we want to manually move our turtle we will use the <code>--once</code>
flag to issue our command once. It is worth noting that the message type used to
command the velocity of the turtle is complex in that it is made up of other
message types so we'll have to query the base message type. Here's a rough summary of what we will do:</p>
<ul>
<li>Print the <code>cmd_vel</code> topic type using <code>ros2 topic type</code>, which is <code>geometry_msgs/msg/Twist</code></li>
<li>Determine the structure of the <code>Twist</code> message type using <code>interface show</code>.</li>
<li>Determine the structure of the <code>Vector3</code>, which is part of the <code>Twist</code> message
type using <code>inteface show</code> command a second time. </li>
<li>Create the YAML syntax for our command. Note the YAML syntax below as it is
rather tricky! The YAML is wrapped in single quotes and a top level set of
curly braces, while subsequent levels follow the
pattern of <code>name:value</code>, and <code>name:{name1:val1,name2:val2}</code> for nested types
like the <code>Twist</code> command.</li>
<li>Issue the command using <code>ros2 pub</code>.</li>
</ul>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 topic type /turtle1/cmd_vel 
geometry_msgs/msg/Twist
kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 interface show geometry_msgs/msg/Twist
# This expresses velocity in free space broken into its linear and angular parts.

Vector3  linear
Vector3  angular
kscottz@kscottz-ratnest:~/Code/ros2multirobotbook$ ros2 interface show geometry_msgs/msg/Vector3
# This represents a vector in free space.

float64 x
float64 y
float64 z

ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist '{linear: {x: 4.0,y: 4.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}}'

</code></pre>
<p>If you did everything correctly you should have moved around the turtle on the
screen. Try changing the command to draw a small picture.</p>
<h1><a class="header" href="#ros-2-services-and-actions" id="ros-2-services-and-actions">ROS 2 Services and Actions</a></h1>
<p>ROS has two main patterns for encapsulating robot behaviors: services and
actions. As we have discussed previously services are the name given to short,
synchronous robot behaviors that can be done quickly, like turning on lights
and switching components on or off. Action is the term to describe longer term,
asynchronous, tasks, that may have intermediate steps. A classic example of an
action is navigation: a robot is provided a goal position and asked to navigate
to that goal. Try as the robot might, since it cannot move infinitely fast, it
takes time to move to a goal and sometimes its path may become blocked. These
two primitives are the backbone of most robotic systems using ROS, and learning
how to use them via the command line will allow you quickly and easily command
a robot to complete a task for you. To aid in clarity of this section we'll
also touch on the <code>ros2 node</code> command to determine what node, or software
process is conducting a particular action or service.</p>
<p>Let's get nodes out of the way quickly. As we have alluded to ROS nodes are
small programs, running in their own process. A ROS system can have ten,
hundreds, or even thousands of nodes running concurrently. Moreover, a ROS
system can have multiple copies of the same node running concurrently on the
same system. In the case of our turtle simulation we can actually create
multiple turtles, each with their own node, all running the exact same
program. ROS Nodes, like ROS topics, have namespaces so that you can address
specific nodes in the case where multiple copies of the same node (program) are
running. Let's dig in a bit by restarting our turtle simulation in a terminal
using <code>ros2 run turtlesim turtlesim_node</code>. Now in a new terminal let's first
examine what <code>ros2 node</code> has to offer by asking for help.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 node --help
usage: ros2 node [-h]
                 Call `ros2 node &lt;command&gt; -h` for more detailed usage. ...

Various node related sub-commands

optional arguments:
  -h, --help            show this help message and exit

Commands:
  info  Output information about a node
  list  Output a list of available nodes

  Call `ros2 node &lt;command&gt; -h` for more detailed usage.
</code></pre>
<p>Much like topics we see two subcommands, <code>info</code> and <code>list</code>. Node list works much the
same as topic list and simply prints a list of all running nodes. Let's see what
is running on our system. </p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 node list
/turtlesim
</code></pre>
<p>We have a single node running called &quot;turtlesim&quot;. <code>node info</code> works in a way
very similar to <code>topic info</code> except that it lists information about the nodes we
give it. Let's call it with our single ROS Node <code>/turtlesim</code> as its
argument.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 node info /turtlesim
/turtlesim
  Subscribers:
    /parameter_events: rcl_interfaces/msg/ParameterEvent
    /turtle1/cmd_vel: geometry_msgs/msg/Twist
  Publishers:
    /parameter_events: rcl_interfaces/msg/ParameterEvent
    /rosout: rcl_interfaces/msg/Log
    /turtle1/color_sensor: turtlesim/msg/Color
    /turtle1/pose: turtlesim/msg/Pose
  Service Servers:
    /clear: std_srvs/srv/Empty
    /kill: turtlesim/srv/Kill
    /reset: std_srvs/srv/Empty
    /spawn: turtlesim/srv/Spawn
    /turtle1/set_pen: turtlesim/srv/SetPen
    /turtle1/teleport_absolute: turtlesim/srv/TeleportAbsolute
    /turtle1/teleport_relative: turtlesim/srv/TeleportRelative
    /turtlesim/describe_parameters: rcl_interfaces/srv/DescribeParameters
    /turtlesim/get_parameter_types: rcl_interfaces/srv/GetParameterTypes
    /turtlesim/get_parameters: rcl_interfaces/srv/GetParameters
    /turtlesim/list_parameters: rcl_interfaces/srv/ListParameters
    /turtlesim/set_parameters: rcl_interfaces/srv/SetParameters
    /turtlesim/set_parameters_atomically: rcl_interfaces/srv/SetParametersAtomically
  Service Clients:

  Action Servers:
    /turtle1/rotate_absolute: turtlesim/action/RotateAbsolute
  Action Clients:
</code></pre>
<p>Wow, that's a lot of information, some of which looks familiar. We can see all
the topics that the node subscribes to, as well as all the nodes it publishes
to. We can also see a number of &quot;action servers&quot; and &quot;service servers&quot;. It is
worth noting the client and server relationship here. Since ROS may have
multiple nodes running some nodes may offer service, these are servers, and
other ROS nodes may call those servers, these are the clients. The clients can
be other ROS nodes, or for these examples, a human using the CLI.</p>
<p>The command line interface for services and actions are very similar, in fact
the both have only four subcommands. Let's run the <code>action</code> and <code>service</code>
commands and compare them.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 action --help
usage: ros2 action [-h]
                   Call `ros2 action &lt;command&gt; -h` for more detailed usage.
                   ...

Various action related sub-commands

optional arguments:
-h, --help            show this help message and exit

Commands:
  info       Print information about an action
  list       Output a list of action names
  send_goal  Send an action goal
  show       Output the action definition

  Call `ros2 action &lt;command&gt; -h` for more detailed usage.
</code></pre>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 service --help
usage: ros2 service [-h] [--include-hidden-services]
                    Call `ros2 service &lt;command&gt; -h` for more detailed usage.
                    ...

Various service related sub-commands

optional arguments:
  -h, --help            show this help message and exit
  --include-hidden-services
                        Consider hidden services as well

Commands:
  call  Call a service
  find  Output a list of available services of a given type
  list  Output a list of available services
  type  Output a service's type

  Call `ros2 service &lt;command&gt; -h` for more detailed usage.
</code></pre>
<p>We can see that both commands have a <code>list</code> command that gives a list of
available services or actions.  If we had multiple nodes running and wanted to
see every service offered calling <code>ros2 node info</code> on each node would very
inefficient, particularly if we had tens, or even hundreds of nodes running. 
In this case it would be much more efficient to use the list commands for the
action and service commands. We can run these commands below and see that we get
roughly the same list of actions and services listed in our single nodes. </p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 service list
/clear
/kill
/reset
/spawn
/turtle1/set_pen
/turtle1/teleport_absolute
/turtle1/teleport_relative
/turtlesim/describe_parameters
/turtlesim/get_parameter_types
/turtlesim/get_parameters
/turtlesim/list_parameters
/turtlesim/set_parameters
/turtlesim/set_parameters_atomically
kscottz@kscottz-ratnest:~$ ros2 action list
/turtle1/rotate_absolute
</code></pre>
<p>Let's begin digging into services. There seem to be quite a few services
listed. Let's take a look at the <code>/spawn</code> service, which will create more
turtles. ROS services and actions use messages similar to those used in topics
to communicate and in fact actions and services are built on top of messages. . We can use the <code>service type</code> subcommand to determine the message type
used by a particular service. We can find specifics of the message by using the
<code>interface show</code> command. Let's see this in practice with the <code>spawn</code> service.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 service type /spawn
turtlesim/srv/Spawn
kscottz@kscottz-ratnest:~$ ros2 interface show turtlesim/srv/Spawn
float32 x
float32 y
float32 theta
string name # Optional.  A unique name will be created and returned if this is empty
---
string name
</code></pre>
<p>We can see from the output above that the spawn message takes three <code>float32</code>
values for its position and orientation as well a &quot;string&quot; for its name. The
<code>---</code> indicate the return value of the services. Unlike topics, services have
a return value, which enables them to do things like perform computations and
calculations.</p>
<p>Let's examine the help for calling a service by running <code>ros2 service call --help</code>.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 service call --help
usage: ros2 service call [-h] [-r N] service_name service_type [values]

Call a service

positional arguments:
  service_name    Name of the ROS service to call to (e.g. '/add_two_ints')
  service_type    Type of the ROS service (e.g. 'std_srvs/srv/Empty')
  values          Values to fill the service request with in YAML format (e.g.
                  &quot;{a: 1, b: 2}&quot;), otherwise the service request will be
                  published with default values

optional arguments:
  -h, --help      show this help message and exit
  -r N, --rate N  Repeat the call at a specific rate in Hz
</code></pre>
<p>The syntax here is very similar to publishing to a topic, but instead of using a
a topic name we use a service name. The service type is just like the topic type
that we used in the past, but instead of using a message type we need a service
type. Finally we give it a value in YAML format. The trick with the YAML is to
encase the string in single quotes.  Let's give it a whirl by creating a turtle
named <code>larry</code> at a position where all values are zero (tab complete is your
friend). </p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 service call /spawn turtlesim/srv/Spawn &quot;{x: 0, y: 0, theta: 0.0, name: 'larry'}&quot;
requester: making request: turtlesim.srv.Spawn_Request(x=0.0, y=0.0, theta=0.0, name='larry')

response:
turtlesim.srv.Spawn_Response(name='larry')
</code></pre>
<p>If everything is working correctly you should now have a turtle named &quot;larry&quot; in
the lower left hand corner of the screen. </p>
<p><img src="./images/larry.png" alt="image" /></p>
<p>Now that you have the basic idea try exploring the other services offered, or
create more turtles at different locations and moving them around. The more you
practice doing this the easier it will get. </p>
<p>Now that we've looked at services we should cover actions. As we mentioned
previously actions differ from services in a few ways and offer a number of
advantages. Services have the following advantages:</p>
<ul>
<li>Actions have a <code>goal</code>. That is to say you send them a goal, and they attempt
to complete it. </li>
<li>Actions can reject goal requests. This prevents them from becoming too busy. </li>
<li>Actions are asynchronous and can perform tasks &quot;while you wait.&quot;</li>
<li>Actions will provide you with &quot;updates&quot;  while you wait, with information about
their progress.</li>
<li>Actions are preemptable, which is a fancy way of saying you can cancel them if
you change your mind. </li>
</ul>
<p>Just like with services we'll first figure out how to call the sole action in
our ROS system by using the <code>action list</code>, <code>action show</code>, and <code>action info</code>
commands. Recall, that when we called <code>ros2 action list</code> we got a single
service. Now that we have &quot;larry&quot; things have changed. Let's take a look.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 action list
/larry/rotate_absolute
/turtle1/rotate_absolute
</code></pre>
<p>Now there are two actions available, one for Larry and one for his friend
&quot;turtle1&quot;! Let's rotate turtle1 to face Larry. First we'll call <code>action info</code>
using <code>/turtle1/rotate_absolute</code> as the input and see what we get. </p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 action info /turtle1/rotate_absolute
Action: /turtle1/rotate_absolute
Action clients: 0
Action servers: 1
    /turtlesim
</code></pre>
<p>Well, that tells us about the client and servers, but it really isn't
helpful. Why don't we look at the <code>action send_goal</code> help and see if we can
figure out how to use it. </p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 action send_goal --help
usage: ros2 action send_goal [-h] [-f] action_name action_type goal

Send an action goal

positional arguments:
  action_name     Name of the ROS action (e.g. '/fibonacci')
  action_type     Type of the ROS action (e.g.
                  'example_interfaces/action/Fibonacci')
  goal            Goal request values in YAML format (e.g. '{order: 10}')

optional arguments:
  -h, --help      show this help message and exit
  -f, --feedback  Echo feedback messages for the goal
</code></pre>
<p>This command needs an action name, an action type, and a goal as YAML. We know
the action name, and we know how to write YAML, so all we need is to determine
the action type. The best way to get the action type is the same way we
published a message. </p>
<p>We see each of our turtles have one service called <code>rotate_absolute</code>.
Let's dig into this action using the info verb. This command has a <code>-t</code>
flag to list the types of messages.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@ade:~$ ros2 action info /moe/rotate_absolute -t
Action: /moe/rotate_absolute
Action clients: 0
Action servers: 1
  /turtlesim [turtlesim/action/RotateAbsolute]
</code></pre>
<p>Interesting, what do these terms mean. The first line lists the action
name. The second line gives the current number of clients for the
action. The <code>Action servers</code> line gives the total number of action
servers for this action. The last line gives the package and message
type for the action.</p>
<p>We can see here that we need to know the action name, the type, and the
values. Now the only problem is figuring out the format of the
action type.</p>
<p>Let's understand the <code>RotateAbsolute</code> action message</p>
<p>The <code>ros2 interface show</code> command can be used to find the type of action
message. Let's take a look.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@kscottz-ratnest:~$ ros2 interface show turtlesim/action/RotateAbsolute
# The desired heading in radians
float32 theta #&lt; --- This section is the GOAL 
---
# The angular displacement in radians to the starting position
float32 delta #&lt; --- This section is the final result, different from the goal.
---
# The remaining rotation in radians
float32 remaining # &lt; --- This is the current state. 
kscottz@kscottz-ratnest:~$ 
</code></pre>
<p>What does this say about rotate absolute?</p>
<ul>
<li>There is a float input, <code>theta</code> the desired heading. This first section is the actual goal.</li>
<li><code>delta</code> -- the angle from the initial heading. This is the value returned when the action completes.</li>
<li><code>remaining</code> -- the remaining radians to move. This is the value  posted by the action while the action is being done.</li>
</ul>
<p>With this information we can create our call to the action server. We'll
use the <code>-f</code> flag to make this a bit clearer. Keep an eye on your turtle! It should move, slowly.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@ade:~$ ros2 action send_goal -f /turtle1/rotate_absolute turtlesim/action/RotateAbsolute {'theta: 1.70'}
Waiting for an action server to become available...
Sending goal:
  theta: 1.7

Feedback:
  remaining: 0.11599969863891602

Goal accepted with ID: 35c40e91590047099ae5bcc3c5151121

Feedback:
 remaining: 0.09999966621398926

Feedback:
 remaining: 0.06799960136413574

Feedback:
 remaining: 0.03599953651428223

Result:
 delta: -0.09600019454956055

Goal finished with status: SUCCEEDED
</code></pre>
<p>If everything worked correctly we should see our turtle has rotated. </p>
<h1><a class="header" href="#ros-parameters" id="ros-parameters">ROS parameters</a></h1>
<p><a href="https://index.ros.org/doc/ros2/Tutorials/Parameters/Understanding-ROS2-Parameters/">The full ROS Param tutorial can be found
here.</a></p>
<p>In ROS, parameters are values that are shared between nodes in the
system (if you are familiar with the <a href="https://en.wikipedia.org/wiki/Blackboard_(design_pattern)">blackboard design
pattern</a> in
software engineering). Parameters are values that any node can query or
write to, another good analogy would be global constants in normal
software programs. Parameters are best used to configure your robot. For
example, if you were building an autonomous vehicle and wanted to cap
the maximum velocity of the vehicle at 100 km/h, you could create a
parameter called &quot;MAX_SPEED&quot; that is visible to all the nodes.</p>
<p>Let's take a look at the high level param program.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@ade:~$ ros2 param --help
Various param related sub-commands

Commands:
  delete  Delete parameter
  get     Get parameter
  list    Output a list of available parameters
  set     Set parameter
  Call `ros2 param &lt;command&gt; -h` for more detailed usage.
</code></pre>
<p>Params used by TurtleSim</p>
<p>Let's see what the docs say and then see what happens when we call
<code>ros2 param list</code></p>
<pre><code class="language-{.sourceCode.bash}">kscottz@ade:~$ ros2 param --help
usage: ros2 param [-h]
optional arguments:
  use_sim_time
/turtlesim:
  background_b
  background_g
  background_r
usage: ros2 param list [-h] [--spin-time SPIN_TIME] [--include-hidden-nodes]

positional arguments:
  node_name             Name of the ROS node
&lt; CLIPPED &gt;

kscottz@ade:~$ ros2 param list
/draw_square:
  use_sim_time
/turtlesim:
  background_b
  background_g
  background_r
  use_sim_time
</code></pre>
<p>Let's try getting/setting parameters</p>
<p>The syntax for getting a parameter is as follows:</p>
<p><code>ros2 param get &lt;node name&gt; &lt;param name&gt;</code></p>
<p>Let's give it a shot.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@ade:~$ ros2 param get /turtlesim background_b
Integer value is: 255
</code></pre>
<p>Let's try setting a parameter. The syntax for that is as follows:</p>
<p><code>ros2 set &lt;node name&gt; &lt;param name&gt; &lt;value&gt;</code></p>
<pre><code class="language-{.sourceCode.bash}">kscottz@ade:~$ ros2 param set /turtlesim background_b 0
Set parameter successful
</code></pre>
<h1><a class="header" href="#ros-bag" id="ros-bag">ROS bag</a></h1>
<ul>
<li>ROS bags are ROS's tool for recording, and replaying data.</li>
<li>ROS bags are kinda like log files that let you store data along with
messages.</li>
<li>ROS systems can generate a lot of data, so you select which topics
you want to bag.</li>
<li>Bags are a great tool for testing and debugging your application as
well.</li>
</ul>
<p>Let's take a look at the base <code>bag</code> verb.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@ade:~$ ros2 bag -h
usage: ros2 bag [-h] Call `ros2 bag &lt;command&gt; -h` for more detailed usage. ...

Various rosbag related sub-commands

Commands:
  info    ros2 bag info
  play    ros2 bag play
  record  ros2 bag record
</code></pre>
<p>Let's try recording our first Bag</p>
<p>First use <code>F2</code> or <code>F3</code> to go to the other terminal. Start the
<code>draw_square</code> demo again to get the default turtle moving.</p>
<p>The command for that is: <code>ros2 run turtlesim draw_square</code></p>
<p>Now let's look at <code>ros2 bag record -h</code></p>
<pre><code class="language-{.sourceCode.bash}">kscottz@ade:~$ ros2 bag record -h
usage: ros2 bag record [-h] [-a] [-o OUTPUT] [-s STORAGE]
                       [-f SERIALIZATION_FORMAT] [--no-discovery]
           [-p POLLING_INTERVAL]
           [topics [topics ...]]
ros2 bag record
positional arguments:
  topics                topics to be recorded
optional arguments:
  -a, --all             recording all topics, required if no topics are listed explicitly.
  -o OUTPUT, --output OUTPUT
                        destination of the bagfile to create, defaults to a
                        timestamped folder in the current directory
  -s STORAGE, --storage STORAGE
                        storage identifier to be used, defaults to &quot;sqlite3&quot;
  -f SERIALIZATION_FORMAT, --serialization-format SERIALIZATION_FORMAT
                        rmw serialization format in which the messages are
                        saved, defaults to the rmw currently in use
</code></pre>
<p>Let's Bag!</p>
<ul>
<li>Let's bag the pose data on the <code>/turtle1/pose topic</code></li>
<li>Save the data to the directory <code>turtle1.bag</code> using the <code>-o</code> flag.</li>
<li>The program will bag until you hit <code>CTRL+C</code>. Give it a good 30
seconds.</li>
</ul>
<p>Here's my example.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@ade:~$ ros2 bag record /turtle1/pose -o turtle1
[INFO] [rosbag2_storage]: Opened database 'turtle1'.
[INFO] [rosbag2_transport]: Listening for topics...
[INFO] [rosbag2_transport]: Subscribed to topic '/turtle1/pose'
[INFO] [rosbag2_transport]: All requested topics are subscribed. Stopping discovery...
^C[INFO] [rclcpp]: signal_handler(signal_value=2)
</code></pre>
<p>Let's inspect our Bag.</p>
<p>You can introspect any bag file using the <code>ros2 bag info</code> command. This
command will list the messages in the bag, the duration of file, and the
number of messages.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@ade:~$ ros2 bag info turtle1
Files:             turtle1.db3
Bag size:          268.4 KiB
Storage id:        sqlite3
Duration:          68.705s
Start:             May  4 2020 16:10:26.556 (1588633826.556)
End                May  4 2020 16:11:35.262 (1588633895.262)
Messages:          4249
Topic information: Topic: /turtle1/pose | Type: turtlesim/msg/Pose | Count: 4249 | Serialization Format: cdr
</code></pre>
<p>Replaying a Bag</p>
<p>Bags are a great tool for debugging and testing. You can treat a ROS bag
like a recording of a running ROS system. When you play a bag file you
can use most of the ros2 cli tools to inspect the recorded topics.</p>
<p>To replay the bag, first use <code>F2/F3</code> and <code>CTRL+C</code> to turn off the main
turtle node and the <code>draw_square</code> node.</p>
<p>Now in a new terminal replay the bag file using the following command:</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@ade:~$ ros2 bag play turtle1
[INFO] [rosbag2_storage]: Opened database 'turtle1'.
</code></pre>
<p>Nothing should happen visibly, but a lot is happening under the hood.
Use <code>F2</code> or <code>F3</code> to go to a second terminal. Just like a running robot,
you should be able to <code>list</code> and <code>echo</code> topics.</p>
<pre><code class="language-{.sourceCode.bash}">kscottz@ade:~ros2 topic list
/parameter_events
/rosout
/turtle1/pose

kscottz@ade:~$ ros2 bag info turtle1
x: 3.8595714569091797
y: 3.6481313705444336
theta: -1.2895503044128418
linear_velocity: 1.0
angular_velocity: 0.0
---
</code></pre>
<h1><a class="header" href="#the-ros-api" id="the-ros-api">The ROS API</a></h1>
<p>ROS comprises many software libraries that provide a wide array of
functionality that is useful when building robot applications. The libraries
you need will depend on the details of your project. In this section we will
introduce two core libraries that you are likely to interact with
frequently when developing with ROS:</p>
<ul>
<li><code>rclpy</code> : Python client library</li>
<li><code>rclcpp</code> : C++ client library</li>
</ul>
<p>A ROS <em>client library</em> provides the data structures, functions, and
syntactic sugar that make it convenient to develop in a particular
programming language. Here we will cover just the Python and C++
libraries because they're the most widely used. But you can find ROS
client libraries for many other languages, from Ada to JavaScript to
Rust, and beyond.</p>
<p><strong>Note:</strong> In this section we aim for a gentle and efficient introduction
to the ROS API. In service of that goal, we will purposefully ignore
and/or violate various conventions and patterns.</p>
<h2><a class="header" href="#publishing-and-subscribing-to-topics-in-python" id="publishing-and-subscribing-to-topics-in-python">Publishing and subscribing to topics in Python</a></h2>
<p>Publishing data with ROS is easy. Here is a complete Python program that
publishes string messages:</p>
<pre><code class="language-{.sourceCode.py}">from time import sleep
import rclpy
from std_msgs.msg import String

rclpy.init()
node = rclpy.create_node('my_publisher')
pub = node.create_publisher(String, 'chatter', 10)
msg = String()
i = 0
while rclpy.ok():
    msg.data = f'Hello World: {i}'
    i += 1
    print(f'Publishing: &quot;{msg.data}&quot;')
    pub.publish(msg)
    sleep(0.5)
</code></pre>
<p>Try it out yourself. (Make sure that in every shell used below you have
sourced your ROS setup file as we discussed earlier; e.g., <code>source /opt/ros/foxy/setup.bash</code>.) Copy the code block above into a file, call
it <code>talker.py</code>, then feed it to your Python3 interpreter:</p>
<pre><code class="language-{.sourceCode.bash}">$ python3 talker.py
</code></pre>
<p>You should see:</p>
<pre><code>Publishing: &quot;Hello world: 0&quot;
Publishing: &quot;Hello world: 1&quot;
Publishing: &quot;Hello world: 2&quot;
</code></pre>
<p>So it prints to console. But is the data going anywhere? We can check
our work using the <code>ros2 topic</code> tool that was introduced earlier. In
another shell (leave your talker running):</p>
<pre><code class="language-{.sourceCode.bash}">$ ros2 topic echo chatter
</code></pre>
<p>You should see (numbers will vary depending on timing between the two
commands):</p>
<pre><code>data: 'Hello world: 13'
---
data: 'Hello world: 14'
---
data: 'Hello world: 15'
</code></pre>
<p>So we have a working talker. Now we can add our own listener to use in
place of <code>ros2 topic</code>. Here is a complete Python program that subscribes
to string messages and prints them to console:</p>
<pre><code class="language-{sourceCode.py}">import rclpy
from std_msgs.msg import String

def cb(msg):
    print(f'I heard: &quot;{msg.data}&quot;')

rclpy.init()
node = rclpy.create_node('my_subscriber')
sub = node.create_subscription(String, 'chatter', cb, 10)
rclpy.spin(node)
</code></pre>
<p>Try it out yourself. Copy the code block above into a file and call it
<code>listener.py</code>. With your talker still running in one shell, start up your
listener in another shell:</p>
<pre><code class="language-{sourceCode.bash}">$ python3 listener.py
</code></pre>
<p>You should see (again, numbers will vary depending on timing):</p>
<pre><code>I heard: &quot;Hello world: 35&quot;
I heard: &quot;Hello world: 36&quot;
I heard: &quot;Hello world: 37&quot;
</code></pre>
<h3><a class="header" href="#digging-into-the-python-code" id="digging-into-the-python-code">Digging into the Python code</a></h3>
<p>Now that we know these programs work, we can dig into their code. Both
programs start with the same preamble:</p>
<pre><code class="language-{sourceCode.py}">import rclpy
from std_msgs.msg import String
</code></pre>
<p>We obviously need to import the <code>rclpy</code> client library, which gives us
much of what we need write ROS applications in Python. But we also need
to specifically import the ROS message type(s) that we will use. In this
case we are using the simple <code>std_msgs/String</code> message, which contains a
single field called <code>data</code>, of type <code>string</code>. If we wanted to use the
<code>sensor_msgs/Image</code> message, which represents camera images, then we
would <code>from sensor_msgs.msg import Image</code>.</p>
<p>After the imports, both programs perform common initialization:</p>
<pre><code class="language-{sourceCode.py}">rclpy.init()
node = rclpy.create_node('my_node_name')
</code></pre>
<p>We initialize the <code>rclpy</code> library and then call into it to create a
<code>Node</code> object, giving it a name. Subsequently we will operate on that
<code>Node</code> object.</p>
<p>In the talker, we use the <code>Node</code> object to create a <code>Publisher</code> object:</p>
<pre><code class="language-{sourceCode.py}">pub = node.create_publisher(String, 'chatter', 10)
</code></pre>
<p>We declare the type of data we will publish (<code>std_msgs/String</code>), the
name of the topic on which we will publish (<code>chatter</code>), and the maximum
number of outbound messages to locally queue up (10). That last
argument comes into play when we are publishing faster than subscribers
are consuming the data.</p>
<p>The equivalent step in the listener is to create a <code>Subscription</code>
object:</p>
<pre><code class="language-{sourceCode.py}">sub = node.create_subscription(String, 'chatter', cb, 10)
</code></pre>
<p>The type (<code>String</code>) and topic name (<code>chatter</code>) arguments have the same meaning
as for the <code>create_publisher()</code> call, and the final argument (10) is
setting an analogous maximum queue size for inbound messages. The key
difference is the <code>cb</code> argument, which refers to this <em>callback</em>
function that we also defined in the listener:</p>
<pre><code class="language-{sourceCode.py}">def cb(msg):
    print(f'I heard: &quot;{msg.data}&quot;')
</code></pre>
<p>That function will be called whenever the listener receives a message,
and the received message will be passed in as an argument. In this case
we simply print the content to console.</p>
<p>With the callback defined and the <code>Subscription</code> created, the rest of
the listener is one line:</p>
<pre><code class="language-{sourceCode.py}">rclpy.spin(node)
</code></pre>
<p>This call hands control over to <code>rclpy</code> to wait for new messages to
arrive (and more generally for events to occur) and invoke our callback.</p>
<p>Back in the talker, we create a simple loop to use our <code>Publisher</code>:</p>
<pre><code class="language-{sourceCode.py}">msg = String()
i = 0
while rclpy.ok():
    msg.data = f'Hello World: {i}'
    i += 1
    print(f'Publishing: &quot;{msg.data}&quot;')
    pub.publish(msg)
    sleep(0.5)
</code></pre>
<p>These steps are clear enough: we create a message object and then on
each iteration of the loop, we update the message content and publish
it, sleeping briefly between iterations.</p>
<h2><a class="header" href="#publishing-and-subscribing-to-topics-in-c" id="publishing-and-subscribing-to-topics-in-c">Publishing and subscribing to topics in C++</a></h2>
<p>Now we will write the same talker and listener pair, this time in C++.</p>
<p>Here is a complete C++ program that publishes string messages:</p>
<pre><code class="language-{sourceCode.cpp}">#include &lt;unistd.h&gt;
#include &lt;iostream&gt;
#include &quot;rclcpp/rclcpp.hpp&quot;
#include &quot;std_msgs/msg/string.hpp&quot;

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  auto node = rclcpp::Node::make_shared(&quot;minimal_publisher&quot;);
  auto pub = node-&gt;create_publisher&lt;std_msgs::msg::String&gt;(&quot;chatter&quot;, 10);
  std_msgs::msg::String message;
  auto i = 0;
  while (rclcpp::ok()) {
    message.data = &quot;Hello world: &quot; + std::to_string(i++);
    std::cout &lt;&lt; &quot;Publishing: &quot; &lt;&lt; message.data &lt;&lt; std::endl;
    pub-&gt;publish(message);
    usleep(500000);
  }
  return 0;
}
</code></pre>
<p>Of course, as for all C++, we need to compile this program. Managing the
compilation arguments for C++ is cumbersome, so we use CMake to help.
Here is a complete CMake code that allows us to build the talker
example:</p>
<pre><code>cmake_minimum_required(VERSION 3.5)
project(talker_listener)

find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)

add_executable(talker talker.cpp)
target_include_directories(talker PRIVATE ${rclcpp_INCLUDE_DIRS} ${std_msgs_INCLUDE_DIRS})
target_link_libraries(talker ${rclcpp_LIBRARIES} ${std_msgs_LIBRARIES})
</code></pre>
<p>Try it out yourself. Copy the C++ code into a file called <code>talker.cpp</code>
and the CMake code into a file called <code>CMakeLists.txt</code>. Have them
side-by-side in a directory and then invoke <code>cmake</code> followed by <code>make</code>:</p>
<pre><code class="language-{sourceCode.bash}">$ cmake .
$ make
</code></pre>
<p>You should end up with a compiled executable called <code>talker</code>. Run it:</p>
<pre><code class="language-{sourceCode.bash}">$ ./talker
</code></pre>
<p>You should see:</p>
<pre><code>Publishing: &quot;Hello world: 0&quot;
Publishing: &quot;Hello world: 1&quot;
Publishing: &quot;Hello world: 2&quot;
</code></pre>
<p>Keep the talker running and another shell try <code>ros2 topic</code> to listen
in:</p>
<pre><code class="language-{.sourceCode.bash}">$ ros2 topic echo chatter
</code></pre>
<p>You should see (numbers will vary depending on timing between the two
commands):</p>
<pre><code>data: 'Hello world: 13'
---
data: 'Hello world: 14'
---
data: 'Hello world: 15'
</code></pre>
<p>Now we can write our own listener to use in place of <code>ros2 topic</code>. Here
is a complete C++ program that subscribes to string messages and prints
them to console:</p>
<pre><code class="language-{sourceCode.cpp}">#include &quot;rclcpp/rclcpp.hpp&quot;
#include &quot;std_msgs/msg/string.hpp&quot;

void cb(const std_msgs::msg::String::SharedPtr msg)
{
  std::cout &lt;&lt; &quot;I heard: &quot; &lt;&lt; msg-&gt;data &lt;&lt; std::endl;
}

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  auto node = rclcpp::Node::make_shared(&quot;my_subscriber&quot;);
  auto sub = node-&gt;create_subscription&lt;std_msgs::msg::String&gt;(&quot;chatter&quot;, 10, cb);
  rclcpp::spin(node);
  return 0;
}
</code></pre>
<p>Copy the code block into a file called <code>talker.cpp</code>. To arrange for it
to be compiled, we also need to add some corresponding CMake code to the
bottom of our <code>CMakeLists.txt</code> file from earlier:</p>
<pre><code>add_executable(listener listener.cpp)
target_include_directories(listener PRIVATE ${rclcpp_INCLUDE_DIRS} ${std_msgs_INCLUDE_DIRS})
target_link_libraries(listener ${rclcpp_LIBRARIES} ${std_msgs_LIBRARIES})
</code></pre>
<p>Configure and build again:</p>
<pre><code class="language-{sourceCode.bash}">$ cmake .
$ make
</code></pre>
<p>Now you should have also have a <code>listener</code> executable. With your talker
still running in one shell, start up your listener in another shell:</p>
<pre><code class="language-{sourceCode.bash}">$ ./listener
</code></pre>
<p>You should see (again, numbers will vary depending on timing):</p>
<pre><code>I heard: &quot;Hello world: 35&quot;
I heard: &quot;Hello world: 36&quot;
I heard: &quot;Hello world: 37&quot;
</code></pre>
<h3><a class="header" href="#digging-into-the-c-code" id="digging-into-the-c-code">Digging into the C++ code</a></h3>
<p>Now that we know these programs work, we can dig into their code. Both
programs start with the same preamble:</p>
<pre><code class="language-{sourceCode.cpp}">#include &quot;rclcpp/rclcpp.hpp&quot;
#include &quot;std_msgs/msg/string.hpp&quot;
</code></pre>
<p>We obviously need to include the <code>rclcpp</code> client library, which gives us
much of what we need write ROS applications in C++. But we also need to
specifically import the ROS message type(s) that we will use. In this
case we are using the simple <code>std_msgs/String</code> message, which contains a
single field called <code>data</code>, of type <code>string</code>. If we wanted to use the
<code>sensor_msgs/Image</code> message, which represents camera images, then we
would <code>#include &quot;sensor_msgs/msg/image.hpp&quot;</code>.</p>
<p>After the imports, both programs perform common initialization:</p>
<pre><code class="language-{sourceCode.cpp}">  rclcpp::init(argc, argv);
  auto node = rclcpp::Node::make_shared(&quot;my_node_name&quot;);
</code></pre>
<p>We initialize the <code>rclcpp</code> library and then call into it to create a
<code>Node</code> object, giving it a name. Subsequently we will operate on that
<code>Node</code> object.</p>
<p>In the talker, we use the <code>Node</code> object to create a <code>Publisher</code> object:</p>
<pre><code class="language-{sourceCode.cpp}">  auto pub = node-&gt;create_publisher&lt;std_msgs::msg::String&gt;(&quot;chatter&quot;, 10);
</code></pre>
<p>We declare via template the type of data we will publish (<code>std_msgs/String</code>), the
name of the topic on which we will publish (<code>chatter</code>), and the maximum
number of outbound messages to locally queue up (10). That last
argument comes into play when we are publishing faster than subscribers
are consuming the data.</p>
<p>The equivalent step in the listener is to create a <code>Subscription</code>
object:</p>
<pre><code class="language-{sourceCode.cpp}">  auto sub = node-&gt;create_subscription&lt;std_msgs::msg::String&gt;(&quot;chatter&quot;, 10, cb);
</code></pre>
<p>The type (<code>String</code>) and topic name (<code>chatter</code>) arguments have the same meaning
as for the <code>create_publisher()</code> call, and the numerical argument (10) is
setting an analogous maximum queue size for inbound messages. The key
difference is the <code>cb</code> argument, which refers to this <em>callback</em>
function that we also defined in the listener:</p>
<pre><code class="language-{sourceCode.cpp}">void cb(const std_msgs::msg::String::SharedPtr msg)
{
  std::cout &lt;&lt; &quot;I heard: &quot; &lt;&lt; msg-&gt;data &lt;&lt; std::endl;
}
</code></pre>
<p>That function will be called whenever the listener receives a message,
and the received message will be passed in as an argument. In this case
we simply print the content to console.</p>
<p>With the callback defined and the <code>Subscription</code> created, the rest of
the listener is one line:</p>
<pre><code class="language-{sourceCode.cpp}">  rclcpp::spin(node);
</code></pre>
<p>This call hands control over to <code>rclcpp</code> to wait for new messages to
arrive (and more generally for events to occur) and invoke our callback.</p>
<p>Back in the talker, we create a simple loop to use our <code>Publisher</code>:</p>
<pre><code class="language-{sourceCode.cpp}">  std_msgs::msg::String message;
  auto i = 0;
  while (rclcpp::ok()) {
    message.data = &quot;Hello world: &quot; + std::to_string(i++);
    std::cout &lt;&lt; &quot;Publishing: &quot; &lt;&lt; message.data &lt;&lt; std::endl;
    pub-&gt;publish(message);
    usleep(500000);
  }
</code></pre>
<p>These steps are clear enough: we create a message object and then on
each iteration of the loop, we update the message content and publish
it, sleeping briefly between iterations.</p>
<h2><a class="header" href="#where-to-go-from-here" id="where-to-go-from-here">Where to go from here</a></h2>
<p>That was a very brief introduction and we only covered topics, not
services, actions, parameters, or the many other facets of ROS. Luckily,
the online <a href="https://index.ros.org/doc/ros2/Tutorials">ROS tutorials</a> are
an excellent resource for learning about the rest of ROS. We
specifically recommend the <a href="https://index.ros.org/doc/ros2/Tutorials/#beginner-client-libraries">Beginner: Client
Libraries</a>
collection as a natural next step after reading this chapter.</p>
<h2><a class="header" href="#regarding-the-shortcuts-we-took" id="regarding-the-shortcuts-we-took">Regarding the shortcuts we took</a></h2>
<p>In this section we have presented the simplest, shortest example ROS
programs that we could come up with. Such programs are easy to
understand and learn from, as they do not have unnecessary structure or
decoration. But in exchange such programs are not easily extensible,
composable, or maintainable.</p>
<p>The techniques that we used in the example code in this section are
useful for prototyping and experimentation (an important aspect of any
good robotics project!), but we do not recommend them for serious work.
As you go through the <a href="https://index.ros.org/doc/ros2/Tutorials">ROS
tutorials</a> and start reading
existing ROS code, you will learn about a number of concepts, patterns,
and conventions, such as:</p>
<ul>
<li>organizing your code into <em>packages</em>;</li>
<li>organizing your packages into a <em>workspace</em>;</li>
<li>managing <em>dependencies</em> among packages;</li>
<li>using the <code>colcon</code> tool to build code in multiple packages in dependency order;</li>
<li>using the <code>ament</code> module in your <code>CMakeLists.txt</code> files;</li>
<li>structuring your code to allow run-time control of how nodes maps to processes; and</li>
<li>using the client libraries' console-logging routines for output to screen and elsewhere.</li>
</ul>
<p>These techniques will serve you well when you start building your own ROS
applications, especially when you want to share your code with others, whether
on your team or out in the world.</p>
<h1><a class="header" href="#traffic-editor-1" id="traffic-editor-1">Traffic Editor</a></h1>
<p>In this section, we shall describe the traffic-editor GUI and simulation tools.</p>
<h2><a class="header" href="#introduction-and-objectives" id="introduction-and-objectives">Introduction and Objectives</a></h2>
<p>Traffic management of heterogeneous robot fleets is non-trivial. One of the
challenges with coordinated management arises from varying semantics in
information models used across fleets. Representations of waypoints, lanes,
charging/docking stations, restricted zones, infrastructure  systems such as
doors &amp; lifts among others are subject to vendor's discretion. However,
standardized conventions that convey the capabilities and intentions of fleets
in a shared facility are quintessential for planning. Multi-agent participants
in other modes of transportation such as roadways collectively adhere to a set
of rules and conventions which minimize chaos. More importantly, they allow for
a new participant to readily integrate into the system by following the
prescribed rules. Existing agents can accommodate the new participant as its
behavior is apparent. Traffic conventions for multi-robot systems do not exist.
The objective of the <code>traffic_editor</code> is to fill this gap by expressing the
intentions of various fleets in a standardized, vendor neutral manner through a
graphical interface. Collated traffic information from different fleets can then
be exported for planning and control. A secondary objective and benefit of the
<code>traffic_editor</code> is to facilitate generation of 3D simulations worlds which
accurately reflect physical environments.</p>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>The <code>traffic_editor</code> <a href="https://github.com/osrf/traffic_editor">repository</a> is home to the <code>traffic_editor</code> GUI and tools to auto-generate simulation worlds from GUI output. The GUI is an easy to use interface which can be used to create and annotate 2D floor plans with robot traffic along with building infrastructure information. In the case there are existing floor plans of the environment, the <code>traffic_editor</code> is able to import those images for faster layout and floor generation.</p>
<p>The <code>traffic_editor</code> GUI projects are stored as <code>yaml</code> files with
<code>.project.yaml</code> file extensions. The template of a project file is seen below.
The structure essentially breaks a project into <code>.building.yaml</code> files that may
represent various buildings that make up a given site. Populating the <code>filename</code>
tag with the appropriate <code>.building.yaml</code> file will set the editor to load and
apply any annotations to this file.</p>
<pre><code class="language-yaml">building:
  filename: &quot;&quot;
name: &quot;&quot;
traffic_maps:
  {}
version: 1
</code></pre>
<p>Each <code>.building.yaml</code> file encompasses several attributes for each level in
the site as annotated by the user. A detailed description of the various
options are discussed in the subsequent section.</p>
<pre><code class="language-yaml">levels:
  L1:
    doors:
      - []
    drawing:
      filename:
    fiducials:
    elevation: 0
    flattened_x_offset: 0
    flattened_y_offset: 0
    floors:
      - parameters: {}
        vertices: []
    lanes:
      - []
    layers:
      {}
    measurements:
      - []

    models:
      -{}
    vertices:
      {}
    walls:
      {}
lifts:
  {}
name: building

</code></pre>
<h2><a class="header" href="#gui-layout" id="gui-layout">GUI Layout</a></h2>
<p>The layout of the <code>traffic_editor</code> comprises of a <code>Main Toolbar</code>, a <code>Working Area</code>
and a <code>Sidebar</code> as seen in the figure below.</p>
<p><img src="images/traffic_editor/layout.png" alt="" /></p>
<p>The editor operates in three modes as selectable from the <code>Edit mode</code> dropdown
list in the <code>Main Toolbar</code> or using shortkeys:</p>
<ul>
<li><strong>Building (Ctrl + B):</strong> to annotate <em>walls</em>, floors (<em>polygons</em>), <em>doors</em>,
<em>measurements</em> to set the scale of the drawing, <em>fiducials</em> to align levels
for multi-level simulations and environment assets to add virtual models to your simulated environment.</li>
<li><strong>Traffic (Ctrl + T):</strong> to annotate traffic lanes of various robots on each level</li>
<li><strong>Scenario (Ctrl + E):</strong> to define special regions of interest on a level. In
larger facilities robot traffic may be limited to certain areas only. Hence,
it may be more meaningful to generate simulation worlds of these special
regions alone which can be specified in this mode.</li>
</ul>
<p>Each mode has a unique set of tools while the following are common:</p>
<table><thead><tr><th align="center">Icon</th><th align="center">Name</th><th align="center">Shortkey</th><th align="center">Function</th></tr></thead><tbody>
<tr><td align="center"><img src="images/traffic_editor/icons/select.svg" alt="" /></td><td align="center">Select</td><td align="center"><code>Esc</code></td><td align="center">Select an entity in the <code>Working Area</code></td></tr>
<tr><td align="center"><img src="images/traffic_editor/icons/move.svg" alt="" /></td><td align="center">Move</td><td align="center"><code>m</code></td><td align="center">Move an entity in the <code>Working Area</code></td></tr>
<tr><td align="center"><img src="images/traffic_editor/icons/rotate.svg" alt="" /></td><td align="center">Rotate</td><td align="center"><code>r</code></td><td align="center">Rotate an entity in the <code>Working Area</code></td></tr>
</tbody></table>
<p>The <code>SideBar</code> contains multiple tabs with various functionalities:</p>
<ul>
<li><strong>levels:</strong> to add a new level to the building. This can be done from scratch of by importing a floor plan image file</li>
<li><strong>layers:</strong> to overlap other images such as lidar maps over the level</li>
<li><strong>lifts:</strong> to configure and add lifts to the building</li>
<li><strong>traffic:</strong> to add navigation graphs to the level which are a collection of
lanes occupiable by a fleet of robots. Each graph corresponds to a single fleet
operating in the facility.</li>
<li><strong>scenarios:</strong> to configure scenarios for simulation</li>
</ul>
<p>The <code>Working Area</code> is where the levels along with their annotations are
rendered. The user is able to zoom via the <code>Mouse Scroll</code> and pan the view by
holding the <code>Scroll Button</code> and moving the mouse cursor.</p>
<h2><a class="header" href="#annotation-guide" id="annotation-guide">Annotation Guide</a></h2>
<p>The objective of this section is to walk through the process of annotating
facilities while highlighting the capabilities of the <code>traffic_editor</code> GUI.</p>
<p>To create a new <code>traffic_editor</code> project, setup a working directory as shown
below with empty <code>.project.yaml</code> and <code>.building.yaml</code> files.</p>
<pre><code>maps/
├── tutorial.project.yaml
└── tutorial.building.yaml
</code></pre>
<p>Next launch the traffic editor from a terminal window
(source workspace if <code>traffic_editor</code> is built from source).</p>
<pre><code class="language-bash">traffic-editor tutorial.project.yaml
</code></pre>
<p>To configure the project to work with the <code>tutorial.building.yaml</code> file, locate
the path to this file from the dialog box that opens from from clicking <code>Edit -&gt; Project Properties</code>. The project can be assigned a name from the same box.
Saving (<code>Ctrl + S</code>) the project will write the configuration to the
<code>tutorial.project.yaml</code> file while populating the <code>tutorial.building.yaml</code> file
with a basic template. Additional <code>.building.yaml</code> files may be created for
other building in the site. The project configuration can be updated to
reference the new file accordingly.</p>
<h3><a class="header" href="#adding-a-level" id="adding-a-level">Adding a level</a></h3>
<p>A new level in the building can be added by clicking the <code>Add</code> button in the
<code>levels</code> tab of the <code>Sidebar</code>. The operation will open a dialog box where the
<code>name</code>, <code>elevation</code> (in meters) and path to a 2D <code>drawing</code> file (<code>.png</code>) can be
specified. In most use cases, the floor plan for the level is used as the
drawing. If unspecified, the user may explicitly enter dimensions of the level
in the fields provided.</p>
<p><img src="images/traffic_editor/add_level.png" alt="" /></p>
<p>In the figure above, a new level <code>L1</code> at <code>0m</code> elevation and a floor plan has
been added as reflected in the <code>levels</code> tab. A default scale fo <code>1px = 5cm</code> is
applied. The actual scale can be set by adding a measurement. Any offsets
applied to align levels will be reflected in the <code>X</code> and <code>Y</code> columns. Saving the
project will update the <code>tutorial.building.yaml</code> files as seen below.</p>
<pre><code class="language-yaml">
levels:
  L1:
    drawing:
      filename: office.png
    elevation: 0
    flattened_x_offset: 0
    flattened_y_offset: 0
    layers:
      {}
lifts:
  {}
name: building
</code></pre>
<h3><a class="header" href="#adding-a-vertex" id="adding-a-vertex">Adding a vertex</a></h3>
<table><thead><tr><th align="center">Icon</th><th align="center">Shortkey</th></tr></thead><tbody>
<tr><td align="center"><img src="images/traffic_editor/icons/vertex.svg" alt="" /></td><td align="center"><code>v</code></td></tr>
</tbody></table>
<p>A vertex is a fundamental component of multiple annotations. Walls,
measurements, doors, floor polygons and traffic lanes are created from two or
more vertices. To create a vertex, click on the vertex icon in the <code>Main Toolbar</code> and anywhere on the canvas. The default attributes of a vertex are its
coordinates along with an empty name field. Additional attributes may be added
by clicking the <code>Add</code> button in the figure. Short descriptions of these are
presented below.</p>
<ul>
<li><strong>is_parking_spot:</strong> if true and if the waypoint is part of a traffic lane,
the <code>rmf_fleet_adapter</code> will treat this as a <em>holding point</em> during path
planning, i.e., the robot is allowed to wait at this waypoint for an indefinite
period of time.</li>
<li><strong>is_charger:</strong> if true and if the waypoint is part of a traffic lane, the
<code>rmf_fleet_adapter</code> will treat this as a charging station.</li>
<li><strong>dock_name:</strong> if specified and if the waypoint is part of a traffic lane, the
<code>rmf_fleet_adapter</code> will issue an <code>rmf_fleet_msgs::ModeRequest</code> message with
<code>MODE_DOCKING</code> and <code>task_id</code> equal to the specified name to the robot as it
approaches this waypoint.</li>
<li><strong>workcell_name [deprecated]:</strong> This attribute was previously used by the
<code>rmf_fleet_adapter</code> to issue an <code>rmf_dispenser_msgs::DispenerRequest</code> message
with <code>target_guid</code> equal to the name specified when a robot reached this
waypoint. In the latest version of <code>rmf_core</code> the workcell name is passed via
the <code>rmf_task_msgs::Delivery</code> message. See Chapter <a href="simulation.html">Simulation</a>
for more details.</li>
<li><strong>spawn_robot_type:</strong> the name of the robot model to spawn at this waypoint in
simulation. The value must match the model's folder name in the assets
repository. More details on the robot model and plugin required for simulation
can be found in <a href="simulation.html">Simulation</a></li>
<li><strong>spawn_robot_name:</strong> a unique identifier for the robot spawned at this
waypoint. The <code>rmf_fleet_msgs::RobotState</code> message published by this robot
will have <code>name</code> field equal to this value.</li>
</ul>
<p><img src="images/traffic_editor/add_vertex.png" alt="" /></p>
<p>Each vertex is stored in the <code>tutorial.building.yaml</code> file as a list of
x-coordinate, y-coordinate, elevation, vertex_name and a set of additional
parameters.</p>
<pre><code class="language-yaml">  vertices:  
    - [1364.76, 1336.717, 0, magni1_charger, {is_charger: [4, true], is_parking_spot: [4, true], spawn_robot_name: [1, magni1], spawn_robot_type: [1, Magni]}]
</code></pre>
<h3><a class="header" href="#adding-a-measurement" id="adding-a-measurement">Adding a Measurement</a></h3>
<table><thead><tr><th align="center">Icon</th></tr></thead><tbody>
<tr><td align="center"><img src="images/traffic_editor/icons/measurement.svg" alt="" /></td></tr>
</tbody></table>
<p>Adding a measurement sets the scale of the imported 2D drawing which is
essential for simulation accuracy. Scalebars or reference dimensions in the
floor plan aid with the process. With the editor in <em>Building</em> mode, select the
<em>Add Measurement</em> tool and click on two points with known dimension. A pink line is
rendered on the map with two vertices at its ends at the selected points. Note:
A measurement line may be drawn by clicking on existing vertices. In this
scenario, no additional vertices are created at its ends.</p>
<p>Selecting the line populates various parameters in the Properties window of the
<code>Sidebar</code>. Setting the <code>distance</code> parameter to the physical distance between the
points (in meters) will then update the <code>Scale</code> for the level. Save the project
and reload to see the changes reflected.</p>
<p><img src="images/traffic_editor/add_measurement.png" alt="" /></p>
<p>The above process adds two <code>vertices</code> and a <code>measurement</code> field to the
<code>tutorial.building.yaml</code> file as seen below. For the measurement field, the
first two elements represent the indices of vertices representing the ends of
the line. The <code>distance</code> value is stored in a sub-list of parameters.</p>
<pre><code class="language-yaml">levels:
  L1:
    drawing:
      filename: office.png
    elevation: 0
    flattened_x_offset: 0
    flattened_y_offset: 0
    layers:
      {}
    measurements:
      - [1, 0, {distance: [3, 8.409]}]
    vertices:
      - [2951.728, 368.353, 0, &quot;&quot;]
      - [2808.142, 1348.9, 0, &quot;&quot;]

lifts:
  {}
name: building
</code></pre>
<h3><a class="header" href="#adding-a-wall" id="adding-a-wall">Adding a wall</a></h3>
<table><thead><tr><th align="center">Icon</th><th align="center">Shortkey</th></tr></thead><tbody>
<tr><td align="center"><img src="images/traffic_editor/icons/wall.svg" alt="" /></td><td align="center"><code>w</code></td></tr>
</tbody></table>
<p>To annotate walls in the map, select the <em>Add Wall</em> icon from the <code>Main Toolbar</code>
and click on consecutive vertices that represent the corners of the wall. The
selection process is continuous and can be exited by pressing the <code>Esc</code> key.
Blue lines between vertices are rendered on the map which represent the drawn
walls. If the corner vertices are not present, they will automatically be
created when using this tool. Meshes of the annotated walls are automatically
generated during 3D world generating using <code>building_map_generator</code>. By default
the walls are of thickness of 10cm and height 2.5m. These attributes may be
modified <a href="https://github.com/osrf/traffic_editor/blob/3fa2486ad5ab51973c95fdf74511bb7196bb255b/building_map_tools/building_map/level.py#L42">here</a></p>
<p><img src="images/traffic_editor/add_wall.png" alt="" /></p>
<p>Walls are stored in the <code>tutorial.building.yaml</code> file as a list with indices of
start and end vertices of the wall segment along with an empty parameter set.</p>
<pre><code class="language-yaml">    walls:
      - [3, 4, {}]
      - [4, 5, {}]
      - [5, 6, {}]
      - [6, 7, {}]
      - [6, 8, {}]
      - [8, 9, {}]
</code></pre>
<h3><a class="header" href="#adding-a-floor" id="adding-a-floor">Adding a floor</a></h3>
<table><thead><tr><th align="center">Icon</th></tr></thead><tbody>
<tr><td align="center"><img src="images/traffic_editor/icons/floor.svg" alt="" /></td></tr>
</tbody></table>
<p>Flooring is essential for simulations as it provides a ground plane for the
robots to travel over. Floors are annotated using the <em>Add floor polygon</em> tool
from the <code>Main Toolbar</code> in <em>Building</em> edit mode. To define a floor, select
consecutive vertices to create a polygon that accurately represents the flooring
area as seen below. These vertices will need to be added manually prior to this
step. Once created, save the project and reload. Selecting the defined floor
highlights its texture attributes. The default list of textures available is
found <a href="https://github.com/osrf/traffic_editor/tree/master/building_map_tools/building_map_generator/textures">here</a></p>
<p><img src="images/traffic_editor/add_floor.png" alt="" /></p>
<p>It may of interest in certain scenarios to have floors with cavities, for
example, to represent elevator shafts. The <em>Add hole polygon</em> tool may be used
for this purpose. Additionally the shape of a drawn polygon (floor or hole) may
be modified using the <em>Edit polygon</em> tool. Clicking on the tool after selecting
an existing polygon enables the user to modify vertices of the polygon.</p>
<p>Each polygon is stored in the <code>tutorial.building.yaml</code> file in the format below.</p>
<pre><code class="language-yaml">    floors:
      - parameters: {texture_name: [1, blue_linoleum], texture_rotation: [3, 0], texture_scale: [3, 1]}
        vertices: [11, 10, 14, 15, 13, 12]
</code></pre>
<h3><a class="header" href="#adding-a-door" id="adding-a-door">Adding a door</a></h3>
<table><thead><tr><th align="center">Icon</th></tr></thead><tbody>
<tr><td align="center"><img src="images/traffic_editor/icons/door.svg" alt="" /></td></tr>
</tbody></table>
<p>A door between two vertices can be added in <em>Building</em> edit mode by selecting
the <em>Add door</em> tool from the <code>Main Toolbar</code>, and clicking on vertices
representing the ends of the door. Selecting an annotated door highlights its
properties as seen in the figure below. Presently, four door <code>types</code> are
supported: &quot;hinged&quot;, &quot;double_hinged&quot;, &quot;sliding&quot; and &quot;double_sliding&quot;. The
<code>motion_degrees</code> parameter specifies the range of motion in the case of hinged
doors while the <code>motion_direction</code> dictates the direction of swing. In order for
the door to work in simulation, a <code>name</code> must be given to the door.</p>
<p><img src="images/traffic_editor/add_door.png" alt="" /></p>
<p>Doors are stored in the <code>tutorial.building.yaml</code> file as a list with indices of
start and end vertices of the along with the set of parameters that describes the door.</p>
<pre><code class="language-yaml"> doors:
      - [24, 25, {motion_axis: [1, start], motion_degrees: [3, 90], motion_direction: [2, 1], name: [1, D001], type: [1, double_sliding]}]
</code></pre>
<h3><a class="header" href="#adding-a-traffic-lane" id="adding-a-traffic-lane">Adding a traffic lane</a></h3>
<p>One of the most important tools in the <code>traffic_editor</code> GUI is the <em>Add lane</em>
tool available in the <em>Traffic</em> edit mode. The allowable motions of each fleet
operating in the facility is conveyed through its respective Graph which
consists of waypoints and connecting lanes. In this approach, we assume that
robots travel along effectively straight-line paths between waypoints. While this may
be perceived as an oversimplification of paths taken by robots that are capable
of autonomous navigation, in practice the assumption holds fairly well given
that these robots mostly travel along corridors or hallways and seldom in
unconstrained open spaces.</p>
<p>The <code>traffic</code> tab in the <code>Sidebar</code> has a default of nine Graphs for nine
different fleets. To annotate lanes for a graph, say Graph 0, select the Graph
from the <code>traffic</code> tab and click the <em>Add lane</em> tool. Lanes for this graph can
be drawn by clicking vertices to be connected. If a vertex is not present, it
will automatically be added. Properties may be assigned to each vertex as
described in the preceding section. To issue tasks to waypoints that require the
robot to terminate at any waypoint, a name must be assigned to the waypoint. </p>
<p><img src="images/traffic_editor/add_lane.png" alt="" /></p>
<p>Each Graph has a unique color for its lanes and their visibility may be
toggled using the checkbox in the <code>traffic</code> tab. A lane that is defined between
two waypoints may be configured with these additional properties</p>
<ul>
<li><strong>bidirectional:</strong> if <code>true</code>, the <code>rmf_fleet_adapter</code> will plan routes for its
robot assuming the lanes can be traversed in both directions. Lanes that are
not bidirectional have arrows indicating their directionality (indigo lanes in
figure above).</li>
<li><strong>graph_idx</strong>: the Graph number a lane corresponds to.</li>
<li><strong>orientation</strong>: constrain the lane to make the robot travel in <code>forward</code> or <code>backward</code> orientation.</li>
</ul>
<p>While lifts that move between levels are now supported in the <code>traffic_editor</code>,
the <strong>demo_mock_floor_name</strong> and <strong>demo_mock_lift_name</strong> properties were
originally engineered to showcase shared lift access in a single floor
demonstration environment with a &quot;mock&quot; lift that receives lift commands and
transmits lift states but does not actually move between any different floors in
a building. However, as there may be interest such functionality for testing
single-floor hardware setups that seek to emulate multi-floor scenarios, these
properties were retained.</p>
<ul>
<li><strong>demo_mock_floor_name</strong>: name of the floor that the robot is on while
traversing the lane</li>
<li><strong>demo_mock_lift_name</strong>: name of the lift that is being entered or exited
while the robot traverses the lane</li>
</ul>
<p>To further explain these properties, consider this representation of a
navigation graph where numbers are waypoints and letters are lanes:</p>
<pre><code>1 &lt;---a---&gt; 2 &lt;---b---&gt; 3

Waypoint 1 is on floor L1
Waypoint 2 is inside the &quot;lift&quot; named LIFT001
Waypoint 3 is on floor L3
The properties of edge &quot;a&quot; are:
    bidirectional: true
    demo_mock_floor_name: L1
    demo_mock_lift_name: LIFT001
The properties of edge &quot;b&quot; are:
    bidirectional: true
    demo_mock_floor_name: L3
    demo_mock_lift_name: LIFT001
</code></pre>
<p>If the robot is to travel from waypoint 1 to waypoint 3, the <code>rmf_fleet_adapter</code>
will request for the &quot;mock lift&quot; to arrive at L1 when the robot approaches
waypoint 1. With confirmation of the &quot;lift&quot; at L1 and its doors in &quot;open&quot; state,
the robot will be instructed to move into the &quot;lift&quot; to waypoint 2. Once the
&quot;lift&quot; indicates that it has reached L3, the robot will exit along lane b toward
waypoint 3.</p>
<p>Note: when annotating graphs, it is highly recommended to follow an ascending
sequence of graph indices without skipping intermediate numbers. Drawn lanes can
only be interacted with if their associated Graph is first selected in the
<code>traffic</code> tab.</p>
<p>The annotated Graphs are eventually exported as <code>navigation graphs</code> using the
<code>building_map_generator</code> which are then used by respective <code>rmf_fleet_adapters</code>
for path planning. </p>
<p>Lanes are stored in the following format in <code>tutorial.building.yaml</code>. The data structure is a list with first two elements representing the indices of the two vertices of the lane and a set of parameters with configured properties.</p>
<pre><code class="language-yaml">    lanes:
      - [32, 33, {bidirectional: [4, true], demo_mock_floor_name: [1, &quot;&quot;], demo_mock_lift_name: [1, &quot;&quot;], graph_idx: [2, 2], orientation: [1, forward]}]
</code></pre>
<h3><a class="header" href="#deriving-coordinate-space-transforms" id="deriving-coordinate-space-transforms">Deriving coordinate-space transforms</a></h3>
<p>The coordinate system used in the GUI when annotating waypoints and lanes, RMF
coordinate system, has its origin at the top left corner of the floor plan and
with X &amp; Y Axes along the positive horizontal and positive vertical directions
respectively. However, maps generated by robots may have origin elsewhere and
further be oriented and scaled differently. It is critical to derive the correct
transform between coordinate frames in <code>traffic_editor</code> maps and robot maps as
<code>rmf_fleet_adapters</code> expect all robots to publish their locations in the RMF
coordinate system while the <code>rmf_fleet_adapters</code> also issue path requests in the same frame.</p>
<p>To derive such transforms, the <code>traffic_editor</code> GUI allows users to overlay
robot maps on a floor plan and, apply scale, translation and rotation
transformations such that the two maps align correctly. The user can then
apply the same transformations to convert between robot map and RMF coordinates
when programming interfaces for their robot. </p>
<p>The robot map can be imported by clicking the <code>Add</code> button from the <code>layers</code> tab
in the <code>Sidebar</code>. A dialog box will then prompt the user to upload the robot map
image. The same box contains fields for setting the scale for the image along
with applying translations and rotation. Through visual feedback, the user can
determine appropriate values for these fields. As seen in the image below,
importing the robot generated map into the GUI has it located and oriented
differently than the floor plan. With the right transformation values, the two
maps can be made to overlap.</p>
<p><img src="images/traffic_editor/coordinate_transform.png" alt="" /></p>
<h3><a class="header" href="#adding-fiducials" id="adding-fiducials">Adding fiducials</a></h3>
<table><thead><tr><th align="center">Icon</th></tr></thead><tbody>
<tr><td align="center"><img src="images/traffic_editor/icons/fiducial.svg" alt="" /></td></tr>
</tbody></table>
<p>For maps with multiple levels, fiducials provide a means to scale and align
different levels with respect to a reference level. This is crucial for ensuring
dimensional accuracy of annotations across different levels and aligning the
same for simulation. Fiducials are reference markers placed at locations which
are expected to be vertically aligned between two or more levels. For example,
structural columns may run through multiple floors and their locations are often
indicated on floor plans. With two or more pairs of corresponding markers between a level and a reference level, a geometric transformation (translation, rotation and scale) may be derived between the two levels. This transformation can then be applied to all the vertices and models in the newly defined level.</p>
<p>To begin, add two or more non-collinear fiducials to the reference level with
unique <code>name</code> attributes using the <em>Add fiducial</em> tool (left image in figure
below). In the newly created level, add the same number of fiducials at
locations that are expected to be vertically aligned with matching names as the
reference level (right image in figure below). Saving and reloading the project
computes the transformation between the levels which is evident from the Scale
and X-Y offsets for the new level as seen in the <code>levels</code> tab. This level is
now ready to be annotated.</p>
<p><img src="images/traffic_editor/add_fiducial.png" alt="" /></p>
<p>For each level, fiducials are stored in a list of their X &amp; Y coordinates along with their name. </p>
<pre><code class="language-yaml">    fiducials:
      - [936.809, 1323.141, F1]
      - [1622.999, 1379.32, F2]
      - [2762.637, 346.69, F3]
</code></pre>
<h3><a class="header" href="#adding-a-lift" id="adding-a-lift">Adding a lift</a></h3>
<p>Lifts are integral resources that are shared between humans and robot fleets in
multi-level facilities. To add a lift to a building, click the <code>Add</code> button in
the <code>lifts</code> tab in the <code>Sidebar</code>. A dialog box with various configurable
properties will load. It is essential to specify the Name, Reference level and
the X&amp;Y coordinates (pixel units) of its cabin center. A yaw (radians) may
further be added to orient the lift as desired. The width and depth of the cabin
(meters) can also be customized. Lifts can be designed to have multiple cabin
doors which may open at more than one level. To add a cabin door, click the
<code>Add</code> button in the box below the cabin image. Each cabin door requires a name along with positional and orientational information. Here, the X&amp;Y coordinates are relative to the cabin center.</p>
<p><img src="images/traffic_editor/add_lift.png" alt="" /></p>
<p>The configured lift is stored in the <code>tutorial.building.yaml</code> file as described below.</p>
<pre><code class="language-yaml">lifts:
  LF001:
    depth: 2
    doors:
      door1:
        door_type: 2
        motion_axis_orientation: 1.57
        width: 1
        x: 1
        y: 0
      door2:
        door_type: 2
        motion_axis_orientation: 1.57
        width: 1
        x: -1
        y: 0
    level_doors:
      L1: [door1]
      L2: [door2]
    reference_floor_name: L1
    width: 2
    x: 827
    y: 357.7
    yaw: 1.09
</code></pre>
<h3><a class="header" href="#adding-environment-assets" id="adding-environment-assets">Adding environment assets</a></h3>
<p>Levels may be annotated with thumbnails of models available for simulation using the <em>Add model</em> tool in <em>Building</em> edit mode. Selecting this tool opens a dialog box with a list of model names and matching thumbnails which can be imported to the map. Once on the map, their positions and orientations can be adjusted using the <em>Move</em> and <em>Rotate</em> tools. Instructions on expanding the list of thumbnails for other models is found <a href="https://github.com/osrf/traffic_editor/tree/master/traffic_editor/thumbnail_generator">here</a></p>
<p><img src="images/traffic_editor/add_model.png" alt="" /></p>
<h3><a class="header" href="#adding-a-scenario" id="adding-a-scenario">Adding a scenario</a></h3>
<p>[ in progress]</p>
<h3><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h3>
<p>This chapter covered various capabilities of the <code>traffic_editor</code> which are useful for annotating maps of facilities while adhering to a standardized set of semantics. Examples of other traffic editor projects can be found in the <a href="https://github.com/osrf/rmf_demos">rmf_demos</a> repository. Running physics based simulations with RMF in the annotated sites is described in the <a href="simulation.html">Simulation</a> chapter.</p>
<h1><a class="header" href="#simulation" id="simulation">Simulation</a></h1>
<p>This chapter will describe how to generate building models from the
<code>traffic-editor</code> files and simulate fleets of robots in them.</p>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>Simulation environments for testing robotic solutions offer immense value across
various stages of R&amp;D and deployment. More notably, simulations provide the
following benefits.</p>
<ul>
<li>
<p><strong>Time and resource saving:</strong> While testing with hardware is indispensible,
the process can slow the pace of development with additional setup time, robot
downtime and reset periods between trials. As the number of participants
scale, so do costs associated with purchasing hardware and consumables for
testing. This is especially true with solutions such as RMF which aim to
integrate several mobile/stationary robots together with building systems such as doors
and lifts. Simulations provide a potentially cost-effective and time-saving alternative
for evaluating the behavior of robot systems at scale. More importantly,
simulations can help answer questions prior to deployment such as how many
participants can be supported or how the existing behavior would change with
the introduction of a new fleet, both of which can inform purchasing decisions
for facility owners.</p>
</li>
<li>
<p><strong>Robust testing:</strong> Robots in simulation neither run out of battery nor incur costs when they happen to unfortunately crash into something. Scenarios
can be tested for hours at a stretch, at faster speeds, to fine tune
algorithms and verify their robustness. One consideration about the appropriate amount of scenario testing to run is a decision that depends on how much compute power you want to avail for the simulation. With the introduction of cloud simulation, this limit is then a trade off of cost and speed as well. As scenarios in simulation are
repeatable, fixes for undesirable bugs encountered can be readily validated.
Reaction of the system to edge cases which are rare but have severe
consequences can also be studied through simulation. Data logged from hardware
trials can be used to recreate the scenario in simulation which may be further
helpful for debugging. Lastly, long running simulations can instill confidence
in facility owners prior to deployment.</p>
</li>
</ul>
<p>Physics-based simulators such as <code>Gazebo</code>, carry the benefit of easily
interfacing with ROS2 nodes through wrappers provided by <code>gazebo_ros_pkgs</code>.
Gazebo plugins can be developed that accurately emulate the behavior of robots,
sensors and infrastructure systems which enhance the overall fidelity of
simulations. It is worth emphasizing here that the exact same code used to run the simulations
will also be run on the physical system as well without any changes.</p>
<p>However, despite these compelling benefits, simulations are sparingly employed
by developers and system integrators citing complexity over generating
environments and configuring them with appropriate plugins. In a recent publication &quot;<em>A Study on the Challenges of Using Robotics Simulators for Testing</em>,&quot; by Afsoon Afzal, Deborah S. Katz, Claire Le Goues and Christopher S. Timperley they noted the main reasons participants gave for not using simulation for a particular project and summarized their findings as follows:</p>
<table><thead><tr><th>Reason for not using simulation</th><th>#</th><th>%</th></tr></thead><tbody>
<tr><td>Lack of time or resources</td><td>15</td><td>53.57%</td></tr>
<tr><td>Not realistic/accurate enough</td><td>15</td><td>53.57%</td></tr>
<tr><td>Lack of expertise or knowledge on how to use software-based simulation</td><td>6</td><td>21.43%</td></tr>
<tr><td>There was no simulator for the robot</td><td>4</td><td>14.29%</td></tr>
<tr><td>Not applicable</td><td>4</td><td>14.29%</td></tr>
<tr><td>Too much time or compute resources</td><td>2</td><td>7.14%</td></tr>
<tr><td>Nobody suggested it</td><td>0</td><td>0.00%</td></tr>
<tr><td>Other</td><td>2</td><td>7.14%</td></tr>
</tbody></table>
<p>The RMF project also
aims to address these hurdles by simplifying the process of setting up
simulation environments for multi-fleet traffic control as we will explain further throughout this section.</p>
<h2><a class="header" href="#building-map-generator" id="building-map-generator">Building Map Generator</a></h2>
<p>The <code>traffic_editor</code> as discussed previously is a tool to annotate building
floor plans with fleet specific traffic information in a vendor neutral manner.
This includes waypoints of interest, traffic lanes and shared resources such as
doorways and lifts. It can also be used to markup the walls and floors and add
thumbnails of artifacts in the environment. The ability to auto-generate a 3D
world using this annotated map is of significant value towards simplifying the
creation and management of simulations. To this end, the <code>building_map_tools</code>
package in <code>traffic_editor</code> contains an executable <code>building_map_generator</code>. The
executable operates in two modes 1) To generate a Gazebo/Ignition compliant
<code>.world</code> file and 2) Export the fleet specific traffic information in the form
of navigation graphs which are utilized by <code>fleet_adapters</code> for planning.</p>
<p><img src="images/building_map_generator.png" alt="" /></p>
<p>To auto-generate a Gazebo simulation world, the executable takes in the command arugment &quot;gazebo&quot; along with others described below.</p>
<pre><code class="language-bash">usage: building_map_generator gazebo [-h] [-o [OPTIONS [OPTIONS ...]]] [-n]
                                     [-m MODEL_PATH] [-c CACHE]
                                     INPUT OUTPUT_WORLD OUTPUT_MODEL_DIR

positional arguments:
  INPUT                 Input building.yaml file to process
  OUTPUT_WORLD          Name of the .world file to output
  OUTPUT_MODEL_DIR      Path to output the map model files

optional arguments:
  -h, --help            show this help message and exit
  -o [OPTIONS [OPTIONS ...]], --options [OPTIONS [OPTIONS ...]]
                        Generator options
  -n, --no_download     Do not download missing models from Fuel
  -m MODEL_PATH, --model_path MODEL_PATH
                        Gazebo model path to check for models
  -c CACHE, --cache CACHE
                        Path to pit_crew model cache
</code></pre>
<p>The script parses the <code>.building.yaml</code> file and generates meshes for the
flooring and walls for each level which are combined into a <code>model.sdf</code> file in
the <code>OUTPUT_MODEL_DIR/</code> directory. The <code>model.sdf</code> files for each level are
imported into the <code>.world</code> with filepath <code>OUTPUT_WORLD</code>. Model sub-elements for
various static objects annotated in the <code>traffic_editor</code> are included in the
<code>.world</code> as seen in the snippet below. Similar blocks for annotated robots are
generated. It is the responsibility of the user to append the environment
variable <code>$GAZEBO_MODEL_PATH</code> with the relevant paths to the models prior to
loading the <code>.world</code> file in Gazebo. This process can be simplified through ROS2
launch files and will be discussed in later sections.</p>
<pre><code class="language-xml">&lt;include&gt;
  &lt;name&gt;OfficeChairBlack_6&lt;/name&gt;
  &lt;uri&gt;model://OfficeChairBlack&lt;/uri&gt;
  &lt;pose&gt;4.26201267190027 -7.489812761393875 0 0 0 1.1212&lt;/pose&gt;
  &lt;static&gt;True&lt;/static&gt;
&lt;/include&gt;
</code></pre>
<p>The parser also includes sdf elements for other dynamic assets such as doors and
lifts. Their mechanisms are discussed in the ensuing section. An <code>Ignition</code>
compatible world can be generated by using the &quot;command&quot; argument &quot;ignition&quot;.</p>
<p>Reconfiguring simulation environments becomes as trivial as editing the
annotations on the 2D drawing and re-running the <code>building_map_generator</code>. This
is exceedingly useful to quickly evaluate traffic flow as the spatial
configuration in the facility changes.</p>
<p>To generate navigation graphs for fleet adapters, the <code>building_map_generator</code> is executed with <code>command</code> argument &quot;nav&quot;. The navigation graph is generated as a <code>.yaml</code> file and is parsed during launch by the corresponding fleet adapter.</p>
<pre><code class="language-bash">usage: building_map_generator nav [-h] INPUT OUTPUT_DIR

positional arguments:
  INPUT       Input building.yaml file to process
  OUTPUT_DIR  Path to output the nav .yaml files

</code></pre>
<h2><a class="header" href="#rmf-assets-and-plugins" id="rmf-assets-and-plugins">RMF Assets and Plugins</a></h2>
<p>Assets play a pivotal role in recreating environments in simulation. Projects such as RMF, SubT and others have allowed developers to create and open source 3D models of robots, mechanical infrastructure systems and scene objects. They are available for download <a href="https://app.ignitionrobotics.org/OpenRobotics/fuel/collections/">here</a>.
Beyond imparting visual accuracy, assets may be dynamic and interface with rmf
core systems through the aid of plugins.</p>
<p>To simulate the behavior of hardware such as robot models and infrastructure
systems, several Gazebo plugins have been architected. These plugins are derivates of the <a href="http://osrf-distributions.s3.amazonaws.com/gazebo/api/dev/classgazebo_1_1ModelPlugin.html">ModelPlugin</a> class and tie in standard ROS2 and rmf_core messages to provide necessary functionality. The following sections briefly describe some of these plugins.</p>
<h4><a class="header" href="#robots" id="robots">Robots</a></h4>
<p>As highlighted earlier, several robot models (SESTO, MiR100, Magni, Hospi) have been
open sourced for use in simulation. For these models to emulate the behavior of
their physical counterparts which have been integrated with RMF, they need to 1)
interface with <code>rmf_fleet_adapters</code> and 2) navigate to locations in the
simulated world. These functionalities, for a &quot;<em>full control</em>&quot; robot type, are
achieved through the <code>slotcar</code> <a href="https://github.com/osrf/traffic_editor/blob/master/building_gazebo_plugins/src/slotcar.cpp">plugin</a>.
The plugin subscribes to <code>/robot_path_requests</code> and <code>/robot_mode_requests</code>
topics and responds to relevant <code>PathRequest</code> and <code>ModeRequest</code> messages
published by its <code>rmf_fleet_adapter</code>. The plugin also publishes the robot's
state to the <code>/robot_state</code> topic.</p>
<p>To navigate the robot through waypoints in a <code>PathRequest</code> message, a simple
&quot;rail-like&quot; navigation algorithm is utilized which accelerates and decelerates
the robot along a straight line from its current position to the next waypoint.
The plugin relies on these fundamental assumptions</p>
<ul>
<li>The robot model is a two-wheel differential drive robot</li>
<li>The left and right wheel joints are named  <code>joint_tire_left</code> and <code>joint_tire_right</code> respectively</li>
</ul>
<p>Other parameters, majority of which are kinematic properties of the robot are inferred from sdf parameters.</p>
<pre><code class="language-xml">&lt;plugin name=&quot;slotcar&quot; filename=&quot;libslotcar.so&quot;&gt;
  &lt;nominal_drive_speed&gt;0.5&lt;/nominal_drive_speed&gt;
  &lt;nominal_drive_acceleration&gt;0.25&lt;/nominal_drive_acceleration&gt;
  &lt;max_drive_acceleration&gt;0.75&lt;/max_drive_acceleration&gt;
  &lt;nominal_turn_speed&gt;0.6&lt;/nominal_turn_speed&gt;
  &lt;nominal_turn_acceleration&gt;1.5&lt;/nominal_turn_acceleration&gt;
  &lt;max_turn_acceleration&gt;2.0&lt;/max_turn_acceleration&gt;
  &lt;tire_radius&gt;0.1&lt;/tire_radius&gt;
  &lt;base_width&gt;0.3206&lt;/base_width&gt;
  &lt;stop_distance&gt;0.75&lt;/stop_distance&gt;
  &lt;stop_radius&gt;0.75&lt;/stop_radius&gt;
&lt;/plugin&gt;
</code></pre>
<p>During simulation, it is assumed that the robot's path is free of static
obstacles but the plugin contains logic to pause the robot's motion if an
obstacle is detected in its path. While it is possible to deploy a sensor based
navigation stack, the approach is avoided to minimize the computational load on
the system from running a navigation stack for each robot in the simulation.
Given the focus on traffic management of heterogeneous fleets and not robot
navigation, the <code>slotcar</code> plugin provides an efficient means to simulate the
interaction between rmf core systems and robots.</p>
<p>The <code>slotcar</code> plugin is meant to serve as a generalized solution. Vendors are
encouraged to develop and distribute plugins that represent the
capabilities of their robot and the level of integration with RMF more accurately.</p>
<h4><a class="header" href="#doors" id="doors">Doors</a></h4>
<p>Unlike robot models whose geometries are fixed and hence can be directly
included in the generated <code>.world</code> file, doors are custom defined in
<code>traffic_editor</code> and have their own generation pipeline. As seen in the figure
below, an annotated door has several properties which include the location of
its ends, the type of door (hinged, double_hinged, sliding, double_sliding) and
its range of motion (for hinged doors).</p>
<p><img src="images/door_traffic_editor.png" alt="Figure X" /></p>
<p>The <code>building_map_generator gazebo</code> script parses a <code>.building.yaml</code> file for
any doors and automatically generates an sdf sub-element with links and joints
required for the door along with a configured plugin. The sdf sub-element
generated for the door in the figure above is presented below.</p>
<pre><code class="language-xml">&lt;model name=&quot;coe_door&quot;&gt;
  &lt;pose&gt;8.077686357313898 -5.898342045416362 0.0 0 0 1.1560010438234292&lt;/pose&gt;
  &lt;plugin filename=&quot;libdoor.so&quot; name=&quot;door&quot;&gt;
    &lt;v_max_door&gt;0.5&lt;/v_max_door&gt;
    &lt;a_max_door&gt;0.3&lt;/a_max_door&gt;
    &lt;a_nom_door&gt;0.15&lt;/a_nom_door&gt;
    &lt;dx_min_door&gt;0.01&lt;/dx_min_door&gt;
    &lt;f_max_door&gt;500.0&lt;/f_max_door&gt;
    &lt;door left_joint_name=&quot;left_joint&quot; name=&quot;coe_door&quot; right_joint_name=&quot;empty_joint&quot; type=&quot;SwingDoor&quot; /&gt;
  &lt;/plugin&gt;
  &lt;link name=&quot;left&quot;&gt;
    &lt;pose&gt;0 0 1.11 0 0 0&lt;/pose&gt;
    &lt;visual name=&quot;left&quot;&gt;
      &lt;material&gt;
        &lt;ambient&gt;120 60 0 0.6&lt;/ambient&gt;
        &lt;diffuse&gt;120 60 0 0.6&lt;/diffuse&gt;
      &lt;/material&gt;
      &lt;geometry&gt;
        &lt;box&gt;
          &lt;size&gt;0.8766026166317483 0.03 2.2&lt;/size&gt;
        &lt;/box&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
    &lt;collision name=&quot;left&quot;&gt;
      &lt;surface&gt;
        &lt;contact&gt;
          &lt;collide_bitmask&gt;0x02&lt;/collide_bitmask&gt;
        &lt;/contact&gt;
      &lt;/surface&gt;
      &lt;geometry&gt;
        &lt;box&gt;
          &lt;size&gt;0.8766026166317483 0.03 2.2&lt;/size&gt;
        &lt;/box&gt;
      &lt;/geometry&gt;
    &lt;/collision&gt;
    &lt;inertial&gt;
      &lt;mass&gt;50.0&lt;/mass&gt;
      &lt;inertia&gt;
        &lt;ixx&gt;20.17041666666667&lt;/ixx&gt;
        &lt;iyy&gt;23.36846728119012&lt;/iyy&gt;
        &lt;izz&gt;3.20555061452345&lt;/izz&gt;
      &lt;/inertia&gt;
    &lt;/inertial&gt;
  &lt;/link&gt;
  &lt;joint name=&quot;left_joint&quot; type=&quot;revolute&quot;&gt;
    &lt;parent&gt;world&lt;/parent&gt;
    &lt;child&gt;left&lt;/child&gt;
    &lt;axis&gt;
      &lt;xyz&gt;0 0 1&lt;/xyz&gt;
      &lt;limit&gt;
        &lt;lower&gt;-1.57&lt;/lower&gt;
        &lt;upper&gt;0&lt;/upper&gt;
      &lt;/limit&gt;
    &lt;/axis&gt;
    &lt;pose&gt;0.44330130831587417 0 0 0 0 0&lt;/pose&gt;
  &lt;/joint&gt;
&lt;/model&gt;
</code></pre>
<p>The door <a href="https://github.com/osrf/traffic_editor/blob/master/building_gazebo_plugins/src/door.cpp">plugin</a> responds to <code>DoorRequest</code> messages with <code>door_name</code> matching its <code>model name</code> sdf tag. These messages are published over the <code>/door_requests</code> topic. The plugin is agnostic of the type of door defined and relies on the <code>left_joint_name</code> and <code>right_joint_name</code> parameters to determine which joints to actuate during open and close motions. During these motions, the joints are commanded to their appropriate limits which are specified in the parent element. The joint motions adhere to kinematic constraints specified by sdf parameters while following acceleration and deceleration profiles similar to the <code>slotcar</code>.</p>
<p>To avoid situations where one robot requests a door to close on another robot, a <code>door_supervisor</code> <a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/src/door_supervisor/main.cpp">node</a> is deployed in practice. The node publishes to <code>/door_requests</code> and subscribes to <code>/adapter_door_requests</code> which the fleet adapters publish to when their robot requires access through a door. The <code>door_supervisor</code> keeps track of requests from all the fleet adapters in the system and relays the request to the door adapters while avoiding aforementioned conflicts.</p>
<h4><a class="header" href="#lifts" id="lifts">Lifts</a></h4>
<p>The ability to test lift integration is crucial as these systems are often the operational bottlenecks in facilities given their shared usage by both humans and multi robot fleets. As with annotated doors, lifts can be customized in a number of ways in the <code>traffic_editor</code> gui including the dimension &amp; orientation of the cabin and mapping cabin doors to building levels.</p>
<p>TODO: update gazebo image
<img src="images/lift_traffic_editor.png" alt="" /></p>
<p>The <code>building_map_generator gazebo</code> script parses the <code>.building.yaml</code> file for lifts definitions and auto-generates the sdf elements for the cabin, cabin doors as well as lift shaft doors. A prismatic joint is defined at the base of the cabin which is actuated by the lift plugin to move the cabin between different levels. While the cabin doors are part of the cabin structure, the shaft doors are fixed to building. Both sets of doors open/close simultaneously at a given level and are controlled by the lift plugin itself. These doors are created using the same method as other doors in the building and include the door plugin as well. The <code>building_map_generator</code> also appends a lift [plugin](todo add link) element with required parameters to the lift's model sdf block.</p>
<pre><code class="language-xml">&lt;plugin filename=&quot;liblift.so&quot; name=&quot;lift&quot;&gt;
  &lt;lift_name&gt;Lift1&lt;/lift_name&gt;
  &lt;floor elevation=&quot;0.0&quot; name=&quot;L1&quot;&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door1&quot; shaft_door=&quot;ShaftDoor_Lift1_L1_door1&quot; /&gt;
  &lt;/floor&gt;
  &lt;floor elevation=&quot;10.0&quot; name=&quot;L2&quot;&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door1&quot; shaft_door=&quot;ShaftDoor_Lift1_L2_door1&quot; /&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door2&quot; shaft_door=&quot;ShaftDoor_Lift1_L2_door2&quot; /&gt;
  &lt;/floor&gt;
  &lt;floor elevation=&quot;20.0&quot; name=&quot;L3&quot;&gt;
    &lt;door_pair cabin_door=&quot;CabinDoor_Lift1_door1&quot; shaft_door=&quot;ShaftDoor_Lift1_L3_door1&quot; /&gt;
  &lt;/floor&gt;
  &lt;reference_floor&gt;L1&lt;/reference_floor&gt;
  &lt;v_max_cabin&gt;2.0&lt;/v_max_cabin&gt;
  &lt;a_max_cabin&gt;1.2&lt;/a_max_cabin&gt;
  &lt;a_nom_cabin&gt;1.0&lt;/a_nom_cabin&gt;
  &lt;dx_min_cabin&gt;0.001&lt;/dx_min_cabin&gt;
  &lt;f_max_cabin&gt;25323.0&lt;/f_max_cabin&gt;
  &lt;cabin_joint_name&gt;cabin_joint&lt;/cabin_joint_name&gt;
&lt;/plugin&gt;
</code></pre>
<p>The plugin subscribes to <code>/lift_requests</code> topic and responds to <code>LiftRequest</code> messages with <code>lift_name</code> matching its <code>model name</code> sdf tag. The displacement between the cabin's current elevation and that of the <code>destination_floor</code> is computed and a suitable velocity is applied to the cabin joint. Prior to any motion, the cabin doors are closed and only opened at the <code>destination_floor</code> if specified in the LiftRequest message. As the cabin and shaft doors are configured with the <code>door</code> plugin, they are commanded through <code>DoorRequest</code> messages published by the <code>lift</code> plugin.
Analogous to the <code>door_supervisor</code>, a <code>lift_supervisor</code> <a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/src/lift_supervisor/main.cpp">node</a> is started in practice to manage requests from different robot fleets.</p>
<h4><a class="header" href="#workcells" id="workcells">Workcells</a></h4>
<p>Robots performing deliveries within facilities is a common use case and hence a <code>Delivery</code> task is configured into the <code>rmf_fleet_adapters</code>. In a delivery task, a payload is loaded onto the robot at one location and unloaded at another. The loading and unloading of the payload may be automated by a robot/workcell in a facility. To integrate these systems (generalized as &quot;dispensers&quot;) with RMF core systems, a set of dispenser messages are <a href="https://github.com/osrf/rmf_core/tree/master/rmf_dispenser_msgs/msg">defined</a>. When the robot reaches the loading station, the <code>rmf_fleet_adapter</code> publishes a <code>DispenserRequest</code> message which the dispenser receives and begins processing. When the dispensing is successful, the dispenser is required to publish a <code>DispenserResult</code> message with <code>SUCCESS</code> status. The <code>rmf_fleet_adapter</code> then instructs the robot to proceed to the unloading station where a similar set of messages are exchanged with the workcell unloading the payload.</p>
<p>To replicate this delivery behavior in simulation, the <code>TeleportDispenser</code> and <code>TeleportIngestor</code> <a href="https://github.com/osrf/rmf_demos/tree/master/rmf_gazebo_plugins/src">plugins</a> are designed. These plugins are loaded into <a href="https://github.com/osrf/rmf_demos/tree/master/rmf_demo_assets/models">3D models</a> the same names.
To setup a payload loading station:</p>
<ul>
<li>Assign a <code>workcell_name</code> attribute to the waypoint (see figure below)</li>
<li>Add a <code>TeleportDispenser</code> model beside the waypoint with <code>name</code> matching the <code>workcell_name</code></li>
<li>Add the payload model beside the <code>TeleportDispenser</code> model (Coke can in image below)</li>
</ul>
<p>To setup a payload unloading station:</p>
<ul>
<li>Assign a <code>workcell_name</code> attribute to the waypoint (see figure below)</li>
<li>Add a <code>TeleportIngestor</code> model beside the waypoint with <code>name</code> matching the <code>workcell_name</code></li>
</ul>
<p>When a <code>DispenserRequest</code> message is published with <code>target_guid</code> matching the name of the <code>TeleportDispenser</code> model, the plugin will teleport the payload onto the nearest robot model. Conversely, when the <code>target_guid</code> matches the name of the <code>TeleportIngestor</code> model, the <code>TeleportIngestor</code> plugin will teleport the payload on the robot to its location in the world. The combinations of these plugins allow for delivery requests to be simulation. In the future, this mechanism will be replaced by actual workcells or robot arms but the underlying message exchanges will remain the same.</p>
<p><img src="images/dispensers.png" alt="" /></p>
<h2><a class="header" href="#creating-simulations-and-running-scenarios" id="creating-simulations-and-running-scenarios">Creating Simulations and Running Scenarios</a></h2>
<p>The section aims to provide an overview of the various components in the <code>rmf_demos</code> <a href="https://github.com/osrf/rmf_demos">repository</a> which may serve as a reference for setting up other simulations and assigning tasks to robots. Here, we will focus on the <code>office</code> world.</p>
<h4><a class="header" href="#map-package" id="map-package">Map package</a></h4>
<p>The <code>rmf_demo_maps</code> package houses annotated <code>traffic_editor</code> files which will be used for the 3D world generation. Opening the <code>office.project.yaml</code> file in <code>traffic_editor</code> reveals a single level floorplan that has walls, floors, scale measurements, doors, lanes and models annotated. All the robot lanes are set to <code>bidirectional</code> with <code>graph_idx</code> equal to &quot;0&quot;. The latter signifies that all the lanes belong to the same fleet. In the <code>airport</code> world, we have two sets of graphs with indices &quot;0&quot; and &quot;1&quot; which reflect laneways occupiable by two fleets respectively. The figures below highlight special attributes assigned to certain waypoints to indicate robot spawn locations as well as disperser workcells.</p>
<p><img src="images/rmf_demo_maps.png" alt="" /></p>
<p>To export a 3D world file along with the navigation graphs, the <code>building_map_generator</code> script is used. The <code>CMakeLists.txt</code> file of this package is configured to automatically run the generator scripts when the package is built. The outputs are installed to the <code>share/</code> directory for the package. This allows for the generated files to be easily located and used by other packages in the demo.</p>
<pre><code class="language-cmake">foreach(path ${traffic_editor_paths})

  # Get the output world name
  string(REPLACE &quot;.&quot; &quot;;&quot; list1 ${path})
  list(GET list1 0 name)
  string(REPLACE &quot;/&quot; &quot;;&quot; list2 ${name})
  list(GET list2 -1 world_name)

  set(map_path ${path})
  set(output_world_name ${world_name})
  set(output_dir ${CMAKE_CURRENT_BINARY_DIR}/maps/${output_world_name})
  set(output_world_path ${output_dir}/${output_world_name}.world)
  set(output_model_dir ${output_dir}/models)

  # first, generate the world
  add_custom_command(
    OUTPUT ${output_world_path}
    COMMAND ros2 run building_map_tools building_map_generator gazebo ${map_path} ${output_world_path} ${output_model_dir}
    DEPENDS ${map_path}
  )

  add_custom_target(generate_${output_world_name} ALL
    DEPENDS ${output_world_path}
  )

  # now, generate the nav graphs
  set(output_nav_graphs_dir ${output_dir}/nav_graphs/)
  set(output_nav_graphs_phony ${output_nav_graphs_dir}/phony)
  add_custom_command(
    OUTPUT ${output_nav_graphs_phony}
    COMMAND ros2 run building_map_tools building_map_generator nav ${map_path} ${output_nav_graphs_dir}
    DEPENDS ${map_path}
  )

  add_custom_target(generate_${output_world_name}_nav_graphs ALL
    DEPENDS ${output_nav_graphs_phony}
  )

  install(
    DIRECTORY ${output_dir}
    DESTINATION share/${PROJECT_NAME}/maps
  )

endforeach()

</code></pre>
<h4><a class="header" href="#launch-files" id="launch-files">Launch Files</a></h4>
<p>The <code>demos</code> package includes all the essential launch files required to bring up the simulation world and start various RMF services. The office simulation is launched using the <code>office.launch.xml</code> file. First, a <code>common.launch.xml</code> file is loaded and this starts</p>
<ul>
<li>The <code>rmf_traffic_schedule</code> node responsible for maintaining the database of robot trajectories and monitoring traffic for conflicts. If a conflict is detected, notifications are sent to relevant fleet adapters which begin the negotiation process to find an optimal resolution.</li>
<li>The <code>building_map_server</code> which publishes a <code>BuildingMap</code> message used by UIs for visualization. The executable takes in the path to the relevant <code>.building.yaml</code> file as an argument. The <code>office.building.yaml</code> file installed by the <code>rmf_demo_maps</code> package is located using the <code>find-pkg-share</code> substitution command and is stored in the <code>config_file</code> argument.</li>
<li>The <code>rmf_schedule_visualizer</code> which is an RViz based UI to visualize the traffic lanes, actual positions of the robots, expected trajectory of robots as reflected in the <code>rmf_traffic_schedule</code> and states of building systems such as door and lifts.</li>
<li>The <code>door_supervisor</code> and <code>lift_supervisor</code> nodes to manage requests submitted by fleet adapter and UIs.</li>
</ul>
<pre><code class="language-xml">&lt;!-- Common launch --&gt;
&lt;include file=&quot;$(find-pkg-share demos)/common.launch.xml&quot;&gt;
  &lt;arg name=&quot;use_sim_time&quot; value=&quot;true&quot;/&gt;
  &lt;arg name=&quot;viz_config_file&quot; value =&quot;$(find-pkg-share demos)/include/office/office.rviz&quot;/&gt;
  &lt;arg name=&quot;config_file&quot; value=&quot;$(find-pkg-share rmf_demo_maps)/office/office.building.yaml&quot;/&gt;
&lt;/include&gt;
</code></pre>
<p>The next set of commands in <code>office.launch.xml</code> load the <code>office.world</code> in <code>Gazebo</code> after updating the relevant environment variables with paths to the models, plugins and resources directories.</p>
<pre><code class="language-xml">  &lt;group&gt;
    &lt;let name=&quot;world_path&quot; value=&quot;$(find-pkg-share rmf_demo_maps)/maps/office/office.world&quot; /&gt;
    &lt;let name=&quot;model_path&quot; value=&quot;$(find-pkg-share rmf_demo_maps)/maps/office/models:$(find-pkg-share rmf_demo_assets)/models:/usr/share/gazebo-9/models&quot; /&gt;
    &lt;let name=&quot;resource_path&quot; value=&quot;$(find-pkg-share rmf_demo_assets):/usr/share/gazebo-9&quot; /&gt;
    &lt;let name=&quot;plugin_path&quot; value=&quot;$(find-pkg-prefix rmf_gazebo_plugins)/lib:$(find-pkg-prefix building_gazebo_plugins)/lib&quot; /&gt;

    &lt;executable cmd=&quot;gzserver --verbose -s libgazebo_ros_factory.so -s libgazebo_ros_init.so $(var world_path)&quot; output=&quot;both&quot;&gt;
      &lt;env name=&quot;GAZEBO_MODEL_PATH&quot; value=&quot;$(var model_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_RESOURCE_PATH&quot; value=&quot;$(var resource_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_PLUGIN_PATH&quot; value=&quot;$(var plugin_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_MODEL_DATABASE_URI&quot; value=&quot;&quot; /&gt;
    &lt;/executable&gt;
    &lt;executable cmd=&quot;gzclient --verbose $(var world_path)&quot; output=&quot;both&quot;&gt;
      &lt;env name=&quot;GAZEBO_MODEL_PATH&quot; value=&quot;$(var model_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_RESOURCE_PATH&quot; value=&quot;$(var resource_path)&quot; /&gt;
      &lt;env name=&quot;GAZEBO_PLUGIN_PATH&quot; value=&quot;$(var plugin_path)&quot; /&gt;
    &lt;/executable&gt;
  &lt;/group&gt;
</code></pre>
<p>Lastly, instances of the &quot;full control&quot; <code>rmf_fleet_adapter</code> are launched for each robot type annotated in the map. The navigation graphs for each fleet as generated by the <code>building_map_generator</code> script is passed via the <code>nav_graph_file</code> argument. For the office map, a single fleet of <code>Magni</code> robots is defined. Hence, a single <code>magni_adapter.launch.xml</code> file configured with the kinematic properties of this robot type along with spatial thresholds used for planning, is launched. Along with the fleet adapter, a <code>robot_state_aggregator</code> node is started. This node aggregates <code>RobotState</code> messages with <code>RobotState.name</code> containing the <code>robot_prefix</code> argument and publishes the aggregate to <code>/fleet_states</code> with <code>FleetState.name</code> specified by the <code>fleet_name</code> argument.</p>
<pre><code class="language-xml">&lt;group&gt;
  &lt;let name=&quot;fleet_name&quot; value=&quot;magni&quot;/&gt;
  &lt;include file=&quot;$(find-pkg-share demos)/include/adapters/magni_adapter.launch.xml&quot;&gt;
    &lt;arg name=&quot;fleet_name&quot; value=&quot;$(var fleet_name)&quot;/&gt;
    &lt;arg name=&quot;use_sim_time&quot; value=&quot;$(var use_sim_time)&quot;/&gt;
    &lt;arg name=&quot;nav_graph_file&quot; value=&quot;$(find-pkg-share rmf_demo_maps)/maps/office/nav_graphs/0.yaml&quot; /&gt;
  &lt;/include&gt;
  &lt;include file=&quot;$(find-pkg-share rmf_fleet_adapter)/robot_state_aggregator.launch.xml&quot;&gt;
    &lt;arg name=&quot;robot_prefix&quot; value=&quot;magni&quot;/&gt;
    &lt;arg name=&quot;fleet_name&quot; value=&quot;$(var fleet_name)&quot;/&gt;
    &lt;arg name=&quot;use_sim_time&quot; value=&quot;true&quot;/&gt;
  &lt;/include&gt;
&lt;/group&gt;
</code></pre>
<p>When testing RMF with hardware, the same launch files can be used with noted exception of not starting <code>Gazebo</code>. More information on running demos with hardware can be found <a href="hardware.html">here</a>.</p>
<h4><a class="header" href="#task-requests" id="task-requests">Task Requests</a></h4>
<p>With the office world launched, robots may be issued tasks to carry out. At present, the rmf_fleet_adapters are designed to fulfil two classes of tasks: 1) <code>Loop</code> requests where a robot is requested to loop between two waypoints and 2) <code>Delivery</code> requests which requires a robot to pick up a payload from a dispenser and drop it off at an unloading station. The <code>rmf_fleet_adapters</code> listen for <code>Loop</code> and <code>Delivery</code> request <a href="https://github.com/osrf/rmf_core/tree/master/rmf_task_msgs/msg">messages</a> published over <code>/loop_requests</code> and <code>delivery_requests</code> topics respectively and assign the task to an available robot in their fleet.</p>
<p>Note: the <code>perform_deliveries</code> parameter in the fleet adapter launch file must be set <code>true</code> to enable the given fleet to perform delivery requests. In the current version it is advised to have only one fleet of robots capable of fulfilling delivery requests as a &quot;task allocator&quot; is yet to be implemented.</p>
<p>The <code>rmf_demo_tasks</code> package is created with two executables, <code>request_loop.py</code> and <code>request_delivery.py</code>, which populate and publish <code>Loop</code> and <code>Delivery</code> messages with supplied arguments. Their usages are shown below. The <code>ROBOT_TYPE</code> argument in both cases should match the <code>FleetState.name</code> of the fleet to be assigned the task. For <code>request_loop</code> the <code>START</code> and <code>FINISH</code> arguments should contain valid waypoint names from the navigation graph while <code>NUM</code> specifies the number of loops between these waypoints. For <code>request_delivery</code>, the <code>PICKUP</code> and <code>DROPOFF</code> arguments must be valid waypoint names with <code>workcell_name</code> fields specified in the <code>traffic_editor</code>.</p>
<pre><code class="language-bash">ros2 run rmf_demo_tasks request_loop -h
usage: request_loop [-h] [-s START] [-f FINISH] [-n NUM] [-i TASK_ID]
                    [-r ROBOT_TYPE]

ros2 run rmf_demo_tasks request_delivery -h
usage: request_delivery [-h] [-p PICKUP] [-d DROPOFF] [-i TASK_ID]
                        [-r ROBOT_TYPE]
</code></pre>
<p>As an alternative, UIs may be developed to send out these requests. More information can be found in the <a href="ui.html">UI</a> chapter. The <code>rmf_demos</code> repository contains a <code>rmf_rviz_plugin</code> package which defines a custom Panel that can be used to send the above commands from RViz. A snapshot of the same is seen below.</p>
<p><img src="images/rmf_panel.png" alt="" /></p>
<h1><a class="header" href="#rmf-core-overview" id="rmf-core-overview">RMF Core Overview</a></h1>
<p>RMF is an umbrella term for a wide range of open specifications and software
tools that aim to ease the integration and interoperability of robotic systems,
building infrastructure, and user interfaces. <a href="https://github.com/osrf/rmf_core"><code>rmf_core</code></a>
is an implementation of some of the core scheduling and traffic management systems.</p>
<p>Avoiding mobile robot traffic conflicts is a key functionality of <code>rmf_core</code>.
There are two levels to traffic deconfliction: (1) prevention, and (2)
resolution.</p>
<h3><a class="header" href="#prevention" id="prevention">Prevention</a></h3>
<p>Whenever possible, it would be good to prevent traffic conflicts
from happening in the first place. To facilitate this, we have implemented a
platform agnostic Traffic Schedule Database. The traffic schedule is a living
database whose contents will change over time to reflect delays, cancelations,
or route changes. All fleet managers that are integrated into an RMF deployment must
report the expected itineraries of their vehicles to the traffic schedule. With
the information available on the schedule, compliant fleet managers can plan
routes for their vehicles that avoid conflicts with any other vehicles, no
matter which fleet they belong to. <code>rmf_traffic</code> provides a
<a href="https://github.com/osrf/rmf_core/blob/master/rmf_traffic/include/rmf_traffic/agv/Planner.hpp"><code>Planner</code></a>
class to help facilitate this for vehicles that behave like standard AGVs which
rigidly follow routes along a pre-determined grid. In the future
we intend to provide a similar utility for AMRs that can perform ad hoc motion
planning around unanticipated obstacles.</p>
<h3><a class="header" href="#negotiation" id="negotiation">Negotiation</a></h3>
<p>It is not always possible to perfectly prevent traffic conflicts.
Mobile robots may experience delays because of unanticipated obstacles in their
environment, or the predicted schedule may be flawed for any number of reasons.
In cases where a conflict does arise, <code>rmf_traffic</code> has a Negotiation scheme.
When the Traffic Schedule Database detects an upcoming conflict between two or
more schedule participants, it will send a conflict notice out to the relevant
fleet managers, and a negotiation between the fleet managers will begin. Each
fleet manager will submit its preferred itineraries, and each will respond with
itineraries that can accommodate the others. A third-party judge (deployed by
the system integrator) will choose the set of proposals that is considered
preferable and notify the fleet managers about which itineraries they should
follow.</p>
<p>There may be situations where a sudden, urgent task needs to take place
(e.g. a response to an emergency), and the current traffic schedule does not
accommodate it in a timely manner. In such a situation, a traffic participant
may intentionally post a traffic conflict onto the schedule and force a
negotiation to take place. The negotiation can be forced to choose an itinerary
arrangement that favors the emergency task by implementing the third-party
judge to always favor the high-priority participant.</p>
<h2><a class="header" href="#traffic-schedule" id="traffic-schedule">Traffic Schedule</a></h2>
<p>The traffic schedule is a centralized database of all the intended robot traffic
trajectories in a facility. Note that it's the intended trajectories, so it is
looking into the future. The job of the schedule is to identify conflicts in
the intentions of the different robot fleets and notify the fleets when a
conflict is identified. Upon receiving the notification, the fleets will begin
a traffic negotiation, as described above.</p>
<h2><a class="header" href="#fleet-adapters" id="fleet-adapters">Fleet Adapters</a></h2>
<p>Each robot fleet that participates in an RMF deployment is expected to have a
fleet adapter that connects its fleet-specific API to the interfaces
of the core RMF traffic scheduling and negotiation system. The fleet adapter is
also responsible for handling communication between the fleet and the various
standardized smart infrastructure interfaces, e.g. to open doors, summon lifts,
and wake up dispensers.</p>
<p>Different robot fleets have different features and capabilities, dependent on
how they were designed and developed. The traffic scheduling and negotiation system
makes no a-priori assumptions about what the capabilities of the fleets will be.
However, to minimize the duplication of integration effort, we have identified 4
different broad categories of control that we expect to encounter among various
real-world fleet managers.</p>
<ul>
<li>
<p><strong>Full Control</strong> <em>(API available)</em> - RMF is provided with live status updates and full control over the paths that each individual mobile robot uses when navigating through the environment. This control level provides the highest overall efficiency and compliance with RMF, which allows RMF to minimize stoppages and deal with unexpected scenarios gracefully.</p>
</li>
<li>
<p><strong>Traffic Light</strong> <em>(API not available yet)</em> - RMF is given the status as well as pause/resume control over each mobile robot, which is useful for deconflicting traffic schedules especially when sharing resources like corridors, lifts and doors.</p>
</li>
<li>
<p><strong>Read Only</strong> <em>(Preliminary API available)</em> - RMF is not given any control over the mobile robots but is provided with regular status updates. This will allow other mobile robot fleets with higher control levels to avoid conflicts with this fleet. <em>Note that any shared space is allowed to have a maximum of just one &quot;Read Only&quot; fleet in operation. Having none is ideal!</em></p>
</li>
<li>
<p><strong>No Interface</strong> <em>(Not compatible)</em> - Without any interface to the fleet, other fleets cannot coordinate with it through RMF, and will likely result in deadlocks when sharing the same navigable environment or resource. This level will not function with an RMF-enabled environment.</p>
</li>
</ul>
<p>In short, the more collaborative a fleet is with RMF, the more harmoniously all of the fleets and systems are able to operate together. Note again that there can only ever be one &quot;Read Only&quot; fleet in a shared space, as any two or more of such fleets will make avoiding deadlock or resource conflict nearly impossible.</p>
<p>Currently we provide a reusable C++ API (as well as Python bindings) for integrating the <strong>Full Control</strong> category of fleet. A preliminary ROS2-message API is available for the <strong>Read Only</strong> category, but that API will be deprecated in favor of a C++ API (with Python bindings available) in a future release. The <strong>Traffic Light</strong> control category is compatible with the core RMF scheduling system, but we have not yet implemented a reusable API for it. To implement a <strong>Traffic Light</strong> fleet adapter, a system integrator would have to use the core traffic schedule and negotiation APIs directly, as well as implement the integration with the various infrastructure APIs (e.g. doors, lifts, and dispensers).</p>
<p>The API for the <strong>Full Control</strong> category is described in the <a href="./integration_fleets.html">Mobile Robot Fleets</a> section, and the <strong>Read Only</strong> category is described in the <a href="./integration_read-only.html">Read Only Fleets</a> section.</p>
<h1><a class="header" href="#frequently-asked-questions" id="frequently-asked-questions">Frequently Asked Questions</a></h1>
<h3><a class="header" href="#why-is-this-traffic-management-system-so-complicated" id="why-is-this-traffic-management-system-so-complicated">Why is this traffic management system so complicated?</a></h3>
<p>RMF has a number of system design constraints that create unique challenges for
traffic management. The core goal of RMF is to facilitate system integration
for heterogeneous mobile robot fleets that may be provided by different vendors
and may have different technical capabilities.</p>
<p>Vendors tend to want to keep their computing systems independent from other
vendors. Since vendors are often responsible for ensuring uptime and
reliability on their computing infrastructure, they may view it as an
unacceptable liability to share computing resources with another vendor. This
means that the traffic management system must be able to function while being
distributed across different machines on a network.</p>
<p>Different robot platforms may have different capabilities. Many valuable AGV
platforms that are currently deployed are not able to change their itineraries
dynamically. Some AGV platforms can change course when instructed to, as long
as they stick to a predefined navigation graph. Some AMR platforms can
dynamically navigate themselves around unanticipated obstacles in their
environment. Since RMF is meant to be an enabling technology, it is important
that we design a system that can maximize the utility of all these different
types of systems without placing detrimental constraints on any of them.</p>
<p>These considerations led to the current design of distributed conflict
prevention and distributed schedule negotiation. There is plenty of space
within the design to create simpler and more efficient subsets for categories
of mobile robots that fit certain sets of requirements, but these optimizations
can be added later, building on top of the existing completely generalized
framework.</p>
<h3><a class="header" href="#who-opens-and-closes-doors-and-operates-the-lifts-the-robot-or-rmf-or-both" id="who-opens-and-closes-doors-and-operates-the-lifts-the-robot-or-rmf-or-both">Who opens and closes doors and operates the lifts? The robot or RMF? Or both?</a></h3>
<p>The responsibility of knowing when a door needs to be opened and then sending
the command to open it belongs to the &quot;fleet adapter&quot;. The basic design is:</p>
<ul>
<li>The fleet adapter keeps track of the robot's progress</li>
<li>When the robot needs to go through a door, the fleet adapter will recognize this</li>
<li>The fleet adapter will send a signal to the door to open</li>
<li>Once the door is open, the fleet adapter will command the robot to proceed</li>
<li>Once the robot is through the door, the fleet adapter will command the robot wait until the door is closed</li>
<li>The fleet adapter will command the door to close</li>
<li>Once the door is closed, the fleet adapter will command the robot to proceed</li>
</ul>
<p>The way a fleet adapter knows about the doors is by parsing the navigation
graph that is provided to it. The navigation graph is a required parameter for
the <code>full_control</code> type of fleet adapter. <code>rmf_demos</code> shows an example of
providing a navigation graph to the fleet adapter.</p>
<p>The recommended way to construct a navigation graph is to use the
<code>traffic-editor</code> tool. The <code>rmf_demos</code> repos shows some examples of
<code>traffic-editor</code> project files.</p>
<p>However, it's entirely possible to construct your own navigation graphs. They
use a very simple yaml format.</p>
<h3><a class="header" href="#are-lifts-supported" id="are-lifts-supported">Are lifts supported?</a></h3>
<p>Proper lift support (meaning, specifying an actual lift that can move between
floors, and exporting that information into the navigation graph) is not
something that has been developed yet due to time constraints and the need to
prioritize certain features over others.</p>
<p>However, for testing and demonstration purposes, there are two special
navigation graph edge properties that can allow a RMF fleet adapter to emulate
lift usage. This is meant for demo scenarios where a &quot;mock lift&quot; has been
created that receives lift commands and transmits lift states but does not
actually move between any different floors in a building. For example, tape
on the floor of a lab to indicate the &quot;lift cabin&quot; box, to allow development
and testing without occupying the actual building lift.</p>
<p>These properties were initially included for demonstration purposes, but they
are proving useful enough that we might make them officially supported
properties. Due to the cost and scarcity of &quot;real&quot; lifts, there seems to be
broad interest in having single-floor hardware test setups that emulate
multi-floor scenarios.</p>
<p>The edge properties are:</p>
<ul>
<li><code>demo_mock_floor_name</code>: The name of the floor that the robot is on while traversing the edge</li>
<li><code>demo_mock_lift_name</code>: The name of the lift that is being entered or exited while the robot traverses the edge</li>
</ul>
<p>The idea is that if you have a single floor demonstration environment but want
to demonstrate interaction with a lift, then you can set up a mock &quot;lift&quot; and
imagine that each side of the &quot;lift&quot; opens to a different floor, and the robot
is only allowed to enter/exit that side of the &quot;lift&quot; when the &quot;lift&quot; believes
it is on that floor. This emulates lift cabins with two sets of doors.</p>
<p>To make this idea more concrete, imagine you have a single-floor hardware
testing area, and a box is drawn on the ground with an LED display next to it
that reads off pretend floor names. The mock lift will transmit lift state
messages that match up with whatever floor the LED is displaying. There is also
some indication of whether the lift doors are open or closed. You can further
imagine that entering or exiting from west side of the &quot;lift&quot; is only allowed
when the lift believes it is on floor L1 whereas entering or exiting the &quot;lift&quot;
from the east side is only allowed when it believes it is on floor L3.</p>
<p>In that setup, for a robot to &quot;correctly&quot; navigate from a waypoint on L1 to a
waypoint on L3, the robot needs to:</p>
<ul>
<li>Approach the &quot;lift&quot; from the west side</li>
<li>Call the &quot;lift&quot; down to L1</li>
<li>Wait until the lift state has it on floor L1 with the doors open</li>
<li>Move into the &quot;lift&quot; (i.e. the box drawn on the ground) and request that it &quot;moves&quot; to L3</li>
<li>Wait until the &quot;lift&quot; indicates that it has reached L3 and that its doors are open</li>
<li>Exit the &quot;lift&quot; on the east side</li>
</ul>
<p>A rough ASCII diagram would look like this (numbers are waypoints and letters
are edges):</p>
<p><code>1 &lt;---a---&gt; 2 &lt;---b---&gt; 3</code></p>
<ul>
<li>Waypoint 1 is on floor L1</li>
<li>Waypoint 2 is inside the &quot;lift&quot; named LIFT001</li>
<li>Waypoint 3 is on floor L3</li>
<li>The properties of edge a are:
<ul>
<li>bidirectional: true</li>
<li>demo_mock_floor_name: L1</li>
<li>demo_mock_lift_name: LIFT001</li>
</ul>
</li>
<li>The properties of edge b are:
<ul>
<li>bidirectional: true</li>
<li>demo_mock_floor_name: L3</li>
<li>demo_mock_lift_name: LIFT001</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#if-multiple-fleets-can-do-the-same-task-which-one-is-one-chosen" id="if-multiple-fleets-can-do-the-same-task-which-one-is-one-chosen">If multiple fleets can do the same task, which one is one chosen?</a></h3>
<p>It's not implemented yet, but there's a design worked out for a bidding system
where a task request will be converted to a bid request. The bid request will
be sent to each fleet adapter, and each fleet adapter that can perform the task
will report its best estimate for how soon it would be able to have the task
finished. The fleet adapter that offers the lowest bid will be assigned the
task.</p>
<p>The API and implementation for this is on the backburner right now as we
finalize some of the more critical components.</p>
<h3><a class="header" href="#can-some-robots-have-priority-over-other-robots" id="can-some-robots-have-priority-over-other-robots">Can some robots have priority over other robots?</a></h3>
<p>The negotiation system concept does support prioritization for which robot will
accommodate the other robot(s). Any arbitrary metric or weighting system can be
used when resolving a negotiation. But in the current implementation that we
are using, we are treating all vehicles as equal and choosing the resolution
that minimizes the net delay across all the robots, without any prioritization
or weighting.</p>
<p>Since this codebase is open source, you can easily fork the code and modify it
to use any prioritization system that you'd like. Specifically, replace
<code>rmf_traffic::schedule::QuickestFinishEvaluator()</code> your own
<code>Negotiation::Evaluator</code> class that behaves in whatever way you would like.</p>
<h3><a class="header" href="#what-distance-is-maintained-between-two-robots" id="what-distance-is-maintained-between-two-robots">What distance is maintained between two robots?</a></h3>
<p>This is configurable. There are two relevant parameters: <code>footprint_radius</code> and
<code>vicinity_radius</code>. The <code>footprint_radius</code> represents an estimate of the
vehicle's physical footprint. The <code>vicinity_radius</code> represents an estimate of
the region which the robot needs other vehicles to stay clear of. A &quot;schedule
conflict&quot; is defined as an instance where one vehicle's &quot;footprint&quot; is
scheduled to enter another vehicle's &quot;vicinity&quot;. The job of the negotiation
system is to come up with a fix to the schedule that keeps all vehicles'
&quot;footprints&quot; out of all other vehicles' &quot;vicinities&quot;.</p>
<h1><a class="header" href="#soss" id="soss">SOSS</a></h1>
<p>The system-of-systems synthesizer (SOSS) is a tool which provides protocol
translation between different subsystems. Currently, ROS 2, ROS 1, and
Websockets are supported. Such composite systems can be called The ROS-SOSS.</p>
<!-- # Requirements -->
<!-- robot, door, lift, workcell, etc. integration with RMF

    I have a door door
    I have an elevator / I have a lift arrow_up_down
    I have a workcell robot mechanical_arm
    I have a loose mobile robot and would like to use FreeFleet (F5)
        robot runs ROS 1
        robot runs ROS 2
        robot runs something that I wrote
        robot runs something somebody else wrote and I can't change
    I have some mobile robots with their own fleet manager(s)
        it has a REST API or some other formal API (XMLRPC)
        it has some other communication mechanism (SQL database, etc.) -->
<h1><a class="header" href="#integration" id="integration">Integration</a></h1>
<p>In this chapter, we will describe the integration requirements and basic steps to have hardware working with RMF. These include <a href="integration.html#mobile-robots">mobile robots</a>, <a href="integration.html#doors">doors</a>, <a href="integration.html#elevators">elevators</a> and <a href="integration.html#workcells">workcells</a>. In each section, we will go through how to build the necessary ROS 2 packages and interfaces that are used by <code>rmf_core</code>, as well as possible scenarios where such interactions occur.</p>
<p>In general, all the interactions can be summed up with this system architecture diagram,</p>
<img src="https://raw.githubusercontent.com/osrf/rmf_core/master/docs/rmf_core_integration_diagram.png">
<p>RMF uses ROS 2 messages and topic interfaces. Hence, in most cases we use components called Adapters to bridge between the hardware interfaces and RMF with some exception for robot fleets which also have fleet drivers as part of the process. Robot fleets will be further elaborated in the next few sections.</p>
<h1><a class="header" href="#route-map-data-requirements-for-integration-with-rmf" id="route-map-data-requirements-for-integration-with-rmf">Route Map data requirements for integration with RMF</a></h1>
<h2><a class="header" href="#motivation-1" id="motivation-1">Motivation</a></h2>
<p>RMF uses robot route maps to predict the navigation paths of robots working in the environment. RMF generates path predictions for all active robots in the environment which can be used to proactively avoid conflicts between the various robot path plans. This is often referred to as &quot;traffic management&quot; in RMF. Along with the traffic management, RMF can help enable multi-fleet visualization to building/robot operations staff, improve scheduling of resources (such as lifts and corridors), reduce robot deadlock and more.</p>
<p>Robot route maps in large buildings are complex and may evolve over time in response to customer requests and building renovations. As a result, RMF works best when scripts can automatically import robot route maps, and re-import them in the future after changes are made.</p>
<h2><a class="header" href="#minimum-map-information-required" id="minimum-map-information-required">Minimum Map Information Required</a></h2>
<ul>
<li>list of waypoints or nodes
<ul>
<li>name of waypoint</li>
<li>level name (B1, L1, L2, etc.)</li>
<li>(x, y) location in meters within the level</li>
<li>any special properties or flags, such as:
<ul>
<li>is this a dropoff/pickup parking point?</li>
<li>is this a charger?</li>
<li>is this a safe parking spot during an emergency alarm?</li>
</ul>
</li>
</ul>
</li>
<li>list of edges or &quot;travel lanes&quot; between nodes
<ul>
<li>(start, end) waypoint names</li>
<li>two-way or one-way traffic?
<ul>
<li>if one-way, identify direction of travel</li>
</ul>
</li>
<li>any other information, such as speed limit along this segment</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#format-requirements" id="format-requirements">Format requirements</a></h2>
<p>We can write import scripts to handle virtually any &quot;open&quot; file format that contains the required information. This includes, in order of preference:</p>
<ul>
<li>YAML</li>
<li>XML</li>
<li>plain text (space or comma-separated ASCII, etc.)</li>
<li>DXF</li>
<li>DWG</li>
<li>SVG</li>
</ul>
<h4><a class="header" href="#remark" id="remark">Remark</a></h4>
<p>If the map data is provided in textual form, screenshots are helpful for &quot;sanity-checking&quot; the coordinate system and alignment with building features.</p>
<h2><a class="header" href="#traffic-editor-2" id="traffic-editor-2">Traffic Editor</a></h2>
<p>If the robot route map does not exist yet, then the <a href="./traffic-editor.html">traffic editor tool</a> can be used to help create one. The traffic editor tool will also export the route map in an RMF-friendly format.</p>
<h1><a class="header" href="#mobile-robot-fleet-integration" id="mobile-robot-fleet-integration">Mobile Robot Fleet Integration</a></h1>
<p>Here we will cover integrating a mobile robot fleet that offers the <strong>Full Control</strong> category of fleet adapter. This means we assume the mobile robot fleet manager allows us to specify explicit paths for the robot to follow, and that the path can be interrupted at any time and replaced with a new path. Furthermore, each robot's position will be updated live as the robots are moving.</p>
<h2><a class="header" href="#route-map" id="route-map">Route Map</a></h2>
<p>Before such a fleet can be integrated, you will need to procure or produce a route map as described in the <a href="./integration_nav-maps.html">previous section</a>. The fleet adapter uses the route map to plan out feasible routes for the vehicles under its control, taking into account the schedules of all other vehicles. It will also use the route map to decide out how to negotiate with other fleet adapters when a scheduling conflict arises. The adapter will only consider moving the robots along routes that are specified on the route map, so it is important that the route coverage is comprehensive. At the same time, if there are extraneous waypoints on the route map, the adapter might spend more time considering all the possibilities than what should really needed, so it is a good idea to have a balance of comprehensiveness and leanness.</p>
<h2><a class="header" href="#c-api" id="c-api">C++ API</a></h2>
<p>The C++ API for full-control automated guided vehicle (AGV) fleets can be found in the <a href="https://github.com/osrf/rmf_core/tree/master/rmf_fleet_adapter/include/rmf_fleet_adapter/agv"><code>rmf_fleet_adapter</code></a> package of the <code>rmf_core</code> repo. The API consists of four critical classes:</p>
<ul>
<li><a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/Adapter.hpp"><code>Adapter</code></a> - Initializes and maintains communication with the other core RMF systems. Use this to register one or more fleets and receive a <code>FleetUpdateHandle</code> for each fleet.</li>
<li><a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/FleetUpdateHandle.hpp"><code>FleetUpdateHandle</code></a> - Allows you to configure a fleet by adding robots and specifying settings for the fleet (e.g. specifying what types of deliveries the fleet can perform). New robots can be added to the fleet at any time.</li>
<li><a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/RobotUpdateHandle.hpp"><code>RobotUpdateHandle</code></a> - Use this to update the position of a robot and to notify the adapter if the robot's progress gets interrupted.</li>
<li><a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/RobotCommandHandle.hpp"><code>RobotCommandHandle</code></a> - This is a pure abstract interface class. The functions of this class must be implemented to call upon the API of the specific fleet manager that is being adapted.</li>
</ul>
<p>The basic workflow of developing a fleet adapter is the following:</p>
<ol>
<li>Create an application that links to the <code>rmf_fleet_adapter</code> library.</li>
<li>Have the application read in runtime parameters in whatever way is desired (e.g. command line arguments, configuration file, ROS parameters, REST API calls, environment variables, etc).</li>
<li>Construct a route graph for each fleet that this application is providing the adapter for (a single adapter application can service any number of fleets), and/or parse the route graph from a yaml file using the <a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/include/rmf_fleet_adapter/agv/parse_graph.hpp"><code>rmf_fleet_adapter::agv::parse_graph</code></a> utility.</li>
<li>Instantiate an <code>rmf_fleet_adapter::agv::Adapter</code> using <code>Adapter::make(~)</code> or <code>Adapter::init_and_make(~)</code>.</li>
<li>Add the fleets that the application will be responsible for adapting, and save the <code>rmf_fleet_adapter::agv::FleetUpdateHandlePtr</code> instances that are passed back.</li>
<li>Implement the <code>RobotCommandHandle</code> class for the fleet manager API that is being adapted.</li>
<li>Add the robots that the adapter is responsible for controlling. The robots can be added based on the startup configuration, or they can be dynamically added during runtime as they are discovered over the fleet manager API (or both).
<ul>
<li>When adding a robot, you will need to create a new instance of the custom <code>RobotCommandHandle</code> that you implemented.</li>
<li>You will also need to provide a callback that will be triggered when the adapter is finished registering the robot. This callback will provide you with a new <code>RobotUpdateHandle</code> for your robot. It is imperative to save this update handle so you can use it to update the robot's position over time.</li>
</ul>
</li>
<li>As new information arrives from the fleet manager API, use the collection of <code>RobotUpdateHandle</code>s to keep the adapter up-to-date on the robots' positions.</li>
</ol>
<p>An example of a functioning fleet adapter application can be found in the <a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_adapter/src/full_control/main.cpp"><code>full_control</code> backwards-compatability adapter</a>. This is a fleet adapter whose fleet-side API is the &quot;Fleet Driver API&quot;, which is a deprecated prototype API for the RMF <strong>Full Control</strong> category of fleet adapters. This fleet adapter exists temporarily to maintain backwards compatibility with the old &quot;Fleet Driver&quot; implementations and to serve as an example of how to implement a fleet adapter using the new C++ API.</p>
<h2><a class="header" href="#python-bindings" id="python-bindings">Python Bindings</a></h2>
<p>You may also choose to use Python to implement your fleet adapter. You can find Python bindings for the C++ API in <a href="https://github.com/osrf/rmf_fleet_adapter_python">this repo</a>. The Python bindings literally just port the C++ API into Python so that you can develop your fleet adapter using Python instead of C++. The above API and workflow are exactly the same, just in Python instead. This should be very useful for fleets that use REST APIs, because you'll have access to tools like <a href="https://swagger.io/tools/open-source/getting-started/">Swagger</a> which can help you generate client code for the fleet's REST API server.</p>
<h1><a class="header" href="#free-fleet-1" id="free-fleet-1">Free Fleet</a></h1>
<p>In the event that the user wishes to integrate a standalone mobile robot which doesn't come with its own fleet management system, the open source fleet management system <code>free_fleet</code> could be used.</p>
<p>The <code>free_fleet</code> system is split into a client and a server. The client is to be run on each of these standalone mobile robots alongside their navigation software and is intended to have direct control over the mobile robot while at the same time monitor its status and report back to the server. The client's base implementation is designed to allow interaction with different configurations of mobile robots yet report to the same server. This way, users are able to use <code>free_fleet</code> to manage a heterogenrous fleet of robots, each using different distributions of ROS, versions of ROS, navigation software, or onboard communication protocols.</p>
<p>The server is run on a central computer and consolidates the incoming status updates from each client to be either visualized using a UI, or relayed upstream to RMF. The server also relays commands from the user via the UI or from RMF down to the clients to be executed. Each server can work with multiple clients at a time, hence it serves the role of a fleet management system. The server can be implemented and used as its own fleet management system or work with larger systems like RMF, bridging the gap between each mobile robot's API and RMF's API and interface.</p>
<p>The communication between the <code>free_fleet</code> server and <code>free_fleet</code> clients is implemented using <code>CycloneDDS</code>, therefore we are not concerned if the mobile robot or central computer is running different versions of ROS.</p>
<p>In this section, we will address 4 different approaches of using <code>free_fleet</code> to integrate with RMF, specifically the navigation stack used by the robot. Each approach maintains a similar systems architecture, which is illustrated in the simple block diagram below, but there are specific examples depending on the software choice for the navigation stack used by the robot developer.</p>
<img src="images/free_fleet_block_diagram.png">
<h2><a class="header" href="#ros-1-navigation-stack" id="ros-1-navigation-stack">ROS 1 Navigation Stack</a></h2>
<p>An implementation of a <code>free_fleet</code> client that works with a ROS 1 navigation stack can be found in the <a href="https://github.com/osrf/free_fleet">repository</a>. The implementation expects the transforms of the mobile robot to be fully defined, the mobile robot to accept navigation commands via the <code>move_base</code> action library, as well as publishing its battery status published using the <code>sensor_msgs/BatteryState</code> message.</p>
<p>After following the build instructions on the README on the mobile robot, the user can launch the client as part of their launch script while at the same time define the necessary parameters using <code>rosparam</code>. Below is a small snippet example of how a client can be launched, with its paramters defined,</p>
<pre><code class="language-xml">&lt;node name=&quot;free_fleet_client_node&quot;
    pkg=&quot;free_fleet_client_ros1&quot;
    type=&quot;free_fleet_client_ros1&quot; output=&quot;screen&quot;&gt;

  &lt;!-- These parameters will be used to identify the mobile robots --&gt;
  &lt;param name=&quot;fleet_name&quot; type=&quot;string&quot; value=&quot;example_fleet&quot;/&gt;
  &lt;param name=&quot;robot_name&quot; type=&quot;string&quot; value=&quot;example_bot&quot;/&gt;
  &lt;param name=&quot;robot_model&quot; type=&quot;string&quot; value=&quot;Turtlebot3&quot;/&gt;

  &lt;!-- These are the topics required to get battery and level information --&gt;
  &lt;param name=&quot;battery_state_topic&quot; type=&quot;string&quot; value=&quot;example_bot/battery_state&quot;/&gt;
  &lt;param name=&quot;level_name_topic&quot; type=&quot;string&quot; value=&quot;example_bot/level_name&quot;/&gt;

  &lt;!-- These frames will be used to update the mobile robot's location --&gt;
  &lt;param name=&quot;map_frame&quot; type=&quot;string&quot; value=&quot;example_bot/map&quot;/&gt;
  &lt;param name=&quot;robot_frame&quot; type=&quot;string&quot; value=&quot;example_bot/base_footprint&quot;/&gt;

  &lt;!-- The name of the move_base server for actions --&gt;
  &lt;param name=&quot;move_base_server_name&quot; type=&quot;string&quot; value=&quot;example_bot/move_base&quot;/&gt;

  &lt;!-- These are DDS configurations used between Free Fleet clients and servers --&gt;
  &lt;param name=&quot;dds_domain&quot; type=&quot;int&quot; value=&quot;42&quot;/&gt;
  &lt;param name=&quot;dds_state_topic&quot; type=&quot;string&quot; value=&quot;robot_state&quot;/&gt;
  &lt;param name=&quot;dds_mode_request_topic&quot; type=&quot;string&quot; value=&quot;mode_request&quot;/&gt;
  &lt;param name=&quot;dds_path_request_topic&quot; type=&quot;string&quot; value=&quot;path_request&quot;/&gt;
  &lt;param name=&quot;dds_destination_request_topic&quot; type=&quot;string&quot; value=&quot;destination_request&quot;/&gt;

  &lt;!-- This decides how long the client should wait for a valid transform and action server before failing --&gt;
  &lt;param name=&quot;wait_timeout&quot; type=&quot;double&quot; value=&quot;10&quot;/&gt;

  &lt;!-- These define the frequency at which the client checks for commands and
  publishes the robot state to the server --&gt;
  &lt;param name=&quot;update_frequency&quot; type=&quot;double&quot; value=&quot;10.0&quot;/&gt;
  &lt;param name=&quot;publish_frequency&quot; type=&quot;double&quot; value=&quot;1.0&quot;/&gt;

  &lt;!-- The client will only pass on navigation commands if the destination or first waypoint
  of the path is within this distance away, otherwise it will ignore the command --&gt;
  &lt;param name=&quot;max_dist_to_first_waypoint&quot; type=&quot;double&quot; value=&quot;10.0&quot;/&gt;

&lt;/node&gt;
</code></pre>
<p>The running <code>free_fleet</code> client will communicate with the nodes running on the robot via ROS 1, while publishing its state and subscribing to requests over DDS with the <code>free_fleet</code> Server.</p>
<p>The current implementation of the <code>free_fleet</code> server is implemented with ROS 2 and communicates with RMF using the aforementioned ROS 2 message and topic interfaces of an RMF fleet adapter. The ROS 2 build instructions can also be found on the same repository. Similar to the client, a simple ROS2 wrapper has been implemented, and it can be started using a <code>.launch.xml</code> file like so,</p>
<pre><code class="language-xml">&lt;node pkg=&quot;free_fleet_server_ros2&quot;
    exec=&quot;free_fleet_server_ros2&quot;
    name=&quot;free_fleet_server_node&quot;
    node-name=&quot;free_fleet_server_node&quot;
    output=&quot;both&quot;&gt;

  &lt;!-- Fleet name will be used to identify robots --&gt;
  &lt;param name=&quot;fleet_name&quot; value=&quot;example_fleet&quot;/&gt;

  &lt;!-- These are the ROS2 topic names that will be used to communicate with RMF --&gt;
  &lt;param name=&quot;fleet_state_topic&quot; value=&quot;fleet_states&quot;/&gt;
  &lt;param name=&quot;mode_request_topic&quot; value=&quot;robot_mode_requests&quot;/&gt;
  &lt;param name=&quot;path_request_topic&quot; value=&quot;robot_path_requests&quot;/&gt;
  &lt;param name=&quot;destination_request_topic&quot; value=&quot;robot_destination_requests&quot;/&gt;

  &lt;!-- These are the DDS specific configurations used to communicate with the clients --&gt;
  &lt;param name=&quot;dds_domain&quot; value=&quot;42&quot;/&gt;
  &lt;param name=&quot;dds_robot_state_topic&quot; value=&quot;robot_state&quot;/&gt;
  &lt;param name=&quot;dds_mode_request_topic&quot; value=&quot;mode_request&quot;/&gt;
  &lt;param name=&quot;dds_path_request_topic&quot; value=&quot;path_request&quot;/&gt;
  &lt;param name=&quot;dds_destination_request_topic&quot; value=&quot;destination_request&quot;/&gt;

  &lt;!-- This determines the frequency it checks for incoming state and request messages,
  as well as how often it publishes its fleet state to RMF --&gt;
  &lt;param name=&quot;update_state_frequency&quot; value=&quot;20.0&quot;/&gt;
  &lt;param name=&quot;publish_state_frequency&quot; value=&quot;2.0&quot;/&gt;

  &lt;!-- These transformations are required when the frame of the robot fleet is
  different from that of RMF globally. In order to transform a pose from the RMF
  frame to the free fleet robot frame, it is first scaled, rotated, then
  translated using these parameters --&gt;
  &lt;param name=&quot;scale&quot; value=&quot;0.928&quot;/&gt;
  &lt;param name=&quot;rotation&quot; value=&quot;-0.013&quot;/&gt;
  &lt;param name=&quot;translation_x&quot; value=&quot;-4.117&quot;/&gt;
  &lt;param name=&quot;translation_y&quot; value=&quot;27.26&quot;/&gt;

&lt;/node&gt;
</code></pre>
<p>Furthermore, an example of this configuration can be found in the repository as well, under the packages <code>ff_examples_ros1</code> and <code>ff_exmaples_ros2</code>. This example launches the example simulation from <code>ROBOTIS</code>, shown <a href="https://emanual.robotis.com/docs/en/platform/turtlebot3/simulation/#ros-1-simulation">here</a>, which has a small simulated world with 3 Turtlebot3 mobile robots, each running its own ROS 1 navigation stack.</p>
<p>After successful builds for both ROS 1 and ROS 2 workspaces, the simulation can be launched following <a href="https://github.com/osrf/free_fleet#turtlebot3-simulation">these instructions</a>, which also includes a ROS 2 <code>free_fleet</code> server, publishing fleet state messages and accepting mode and navigation requests over ROS 2 messages and topics.</p>
<h2><a class="header" href="#ros-2-navigation-stack" id="ros-2-navigation-stack">ROS 2 Navigation Stack</a></h2>
<p>An implementation for a robot using ROS 2 would be similar to a ROS 1 navigation stack described earlier. At this time, the ROS 2 <code>free_fleet</code> client is still under development. This section will be updated once the refactoring, implementation and testing has been completed.</p>
<p>The same ready <code>free_fleet</code> server implementation in the repository will work in this scenario, as the interfaces provided by the fleet adapters are still the same ROS 2 messages and topics.</p>
<p>If required in the meantime, users can implement their own <code>free_fleet</code> client, by working with the <code>free_fleet</code> library that contains the base implementation and API for the DDS communication. This will be further elaborated in the next section <a href="integration_free-fleet.html#custom-navigation-stack">Custom Navigation Stack</a>.</p>
<h2><a class="header" href="#developer-navigation-stack" id="developer-navigation-stack">Developer Navigation Stack</a></h2>
<p>In this implementation, it is assumed that the software running on the mobile robot was written by the robot developers themselves (or their immediate subcontractors) and the developers fully understand and have access to their robot's internal control software, API's and interfaces. This level of understanding and access will be necessary for implementing your own <code>free_fleet</code> client wrapper. The block diagram below illustrate this configuration.</p>
<img src="images/free_fleet_custom_config.png">
<p>Once the developer's <code>free_fleet</code> client is fully functional, it will be a simple task of launching the same ROS 2 <code>free_fleet</code> server as mentioned earlier in this section to work with the fleet adapters through ROS 2 messages and topics.</p>
<h1><a class="header" href="#read-only-fleet-integration" id="read-only-fleet-integration">Read-only Fleet Integration</a></h1>
<p>In this section, we will cover the prototype API for integrating the <strong>Read Only</strong> category of mobile robot fleets. This means we assume the mobile robot fleet manager only allows RMF to see updates about where its robots are located and where they intend to go, but it does not offer any control over where the robots are going or how they can move around. This type of adapter is primarily aimed at legacy systems that were developed before RMF and did not anticipate the possibility of a third-party being able to command the robots.</p>
<h2><a class="header" href="#fleet-driver-api" id="fleet-driver-api">Fleet Driver API</a></h2>
<p>The Fleet Driver API was an experimental API developed in the early stages of the RMF research project. It can still be used for a read-only fleet adapter implementation until an officially supported C++ API comes out to replace it.</p>
<p>The Fleet Driver API uses ROS2 messages from the <a href="https://github.com/osrf/rmf_core/tree/master/rmf_fleet_msgs"><code>rmf_fleet_msgs</code></a> package. To use this API, you will want to write a ROS2 application (using either rclcpp or rclpy) which we will refer to as the <em>Fleet Driver</em>. The job of the Fleet Driver is to transmit <a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_msgs/msg/FleetState.msg"><code>rmf_fleet_msgs/FleetState</code></a> messages out to the <code>&quot;fleet_states&quot;</code> topic.</p>
<p>Inside the <code>FleetState</code> message is the <code>name</code> field. Be sure to fill in the correct name for your fleet state. There is also a collection of <a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_msgs/msg/RobotState.msg"><code>rmf_fleet_msgs/RobotState</code></a> messages. For integrating a read-only fleet with RMF, the most crucial fields of the <code>RobotState</code> message are:</p>
<ul>
<li><code>name</code> - The name of the robot whose state is being specified.</li>
<li><code>location</code> - The current location of the robot.</li>
<li><code>path</code> - The sequence of locations that the robot will be traveling through.</li>
</ul>
<p>Inside the <a href="https://github.com/osrf/rmf_core/blob/master/rmf_fleet_msgs/msg/Location.msg"><code>rmf_fleet_msgs/Location</code></a> message, the <code>t</code> field (which represents time) is generally ignored by the read-only fleet adapter. We assume that it is too cumbersome for your Fleet Driver to make timing predictions, so we have the read-only fleet adapter make the predictions for you based on the traits of the vehicle.</p>
<h2><a class="header" href="#configuring-the-read-only-fleet-adapter" id="configuring-the-read-only-fleet-adapter">Configuring the Read Only Fleet Adapter</a></h2>
<p>For the prototype read-only integration, there are two applications that need to be launched:</p>
<ol>
<li>The Fleet Driver mentioned above which you write specifically for your fleet's custom API</li>
<li>The <code>read_only</code> fleet adapter which must be launched through ROS2</li>
</ol>
<p>To launch the fleet adapter, you will need to use <code>ros2 launch</code> and include <code>rmf_fleet_adapter/fleet_adapter.launch.xml</code> file with the required parameters filled in. An example of this using the XML front-end of ros2 launch <a href="https://github.com/osrf/rmf_demos/blob/master/demos/launch/include/adapters/caddy_adapter.launch.xml">can be found in <code>rmf_demos</code></a>, copied below:</p>
<pre><code>&lt;?xml version='1.0' ?&gt;

&lt;launch&gt;

  &lt;arg name=&quot;fleet_name&quot; default=&quot;caddy&quot; description=&quot;Name of this fleet of caddy robots&quot;/&gt;

  &lt;group&gt;
    &lt;include file=&quot;$(find-pkg-share rmf_fleet_adapter)/fleet_adapter.launch.xml&quot;&gt;

      &lt;!-- The name and control type of the fleet --&gt;
      &lt;arg name=&quot;fleet_name&quot; value=&quot;$(var fleet_name)&quot;/&gt;
      &lt;arg name=&quot;control_type&quot; value=&quot;read_only&quot;/&gt;

      &lt;!-- The nominal linear and angular velocity of the caddy --&gt;
      &lt;arg name=&quot;linear_velocity&quot; value=&quot;1.0&quot;/&gt;
      &lt;arg name=&quot;angular_velocity&quot; value=&quot;0.6&quot;/&gt;

      &lt;!-- The nominal linear and angular acceleration of the caddy --&gt;
      &lt;arg name=&quot;linear_acceleration&quot; value=&quot;0.7&quot;/&gt;
      &lt;arg name=&quot;angular_acceleration&quot; value=&quot;1.5&quot;/&gt;

      &lt;!-- The radius of the circular footprint of the caddy --&gt;
      &lt;arg name=&quot;footprint_radius&quot; value=&quot;1.5&quot;/&gt;
      &lt;!-- Other robots are not allowed within this radius --&gt;
      &lt;arg name=&quot;vicinity_radius&quot; value=&quot;5.0&quot;/&gt;

      &lt;arg name=&quot;delay_threshold&quot; value=&quot;1.0&quot;/&gt;

    &lt;/include&gt;
  &lt;/group&gt;
</code></pre>
<p>The critical parameters are:</p>
<ul>
<li><code>fleet_name</code>: This must match the <code>name</code> value that the Fleet Driver gives to its <code>FleetState</code> messages.</li>
<li><code>control_type</code>: This must be <code>&quot;read_only&quot;</code>.</li>
<li><code>linear_velocity</code>, <code>angular_velocity</code>, <code>linear_acceleration</code>, and <code>angular_acceleration</code>: These are estimates of the kinematic properties of the vehicles. For the sake of effective scheduling, it is preferable to overestimate these values than underestimate them, so it is best to think of these parameters as upper bounds for the values.</li>
<li><code>footprint_radius</code>: The radius of physical space that the vehicle occupies. This should cover the maximum extent of the physical footprint.</li>
<li><code>vicinity_radius</code>: The radius around the robot in which other robots are forbidden to physically enter. It is assumed that another robot entering this radius will interfere with the ability of this robot to operate.</li>
</ul>
<p>When the launch file and Fleet Driver application are both ready, you can launch them side-by-side and the integration of the read-only fleet adapter will be complete.</p>
<h2><a class="header" href="#doors-1" id="doors-1">Doors</a></h2>
<h3><a class="header" href="#map-requirements" id="map-requirements">Map requirements</a></h3>
<p>Before a door can be properly integrated, be sure to draw up the door locations with the correct door names on the navigation graph using <code>traffic_editor</code>. The instructions to do so can be found in Chapter 3. Traffic Editor.</p>
<h3><a class="header" href="#integration-1" id="integration-1">Integration</a></h3>
<p>Door integration is required when integrating RMF into a new environment. For hopefully obvious reasons, only automated doors can be integrated with RMF though it may be possible to trigger an alert to a designated human to open a manual door but this is not recommended. An automated door can be defined as an electronically powered door that is remotely controllable, either using a remote trigger or has been outfitted with a computing unit capable of commanding the door to open and close when needed, using certain interfaces.</p>
<p>Doors can be integrated with RMF using a ROS 2 door node and a door adapter, which we sometimes refer to as a door supervisor. The block diagram below displays the relationship and communication modes between each component.</p>
<img src="images/doors_block_diagram.png">
<p>The door node will have to be implemented based on the make and model of the door that is being integrated in order to address the specific API of the door controller module. The communication protocol will also be dependent on the door and controller model, which might be some form of <code>REST</code>, <code>RPCXML</code>, etc. The door node is in charge of publishing its state and receiving commands over ROS 2, using the messages and topics listed below.</p>
<table><thead><tr><th>Message Types</th><th>ROS2 Topic</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rmf_door_msgs/DoorState</code></td><td><code>/door_states</code></td><td>State of the door published by the door node</td></tr>
<tr><td><code>rmf_door_msgs/DoorRequest</code></td><td><code>/door_requests</code></td><td>Direct requests subscribed by the door node and published by the door adapter</td></tr>
<tr><td><code>rmf_door_msgs/DoorRequest</code></td><td><code>/adapter_door_requests</code></td><td>Requests to be sent to the door adapter/supervisor to request safe operation of doors</td></tr>
</tbody></table>
<p>The door adapter stands in between the rest of the RMF core systems, fleet adapters, and the door node, and acts like a state supervisor ensuring that the doors are not acting on requests that might obstruct an ongoing mobile robot task or accidentally closing on it. It keeps track of the door state from the door node, and receives requests from the <code>adapter_door_requests</code> topic which are published by either fleet adapters or other parts of the RMF core system. Only when the door adapter deems that a request is safe enough to be performed, it will instruct the door node using a request. It should also be noted that direct requests sent to the door node, without going through the door adapter will be negated by the door adapter, to return it to its prior state in order to prevent disruptions during operations with mobile robots.</p>
<h1><a class="header" href="#lifts-aka-elevators" id="lifts-aka-elevators">Lifts (a.k.a. Elevators)</a></h1>
<h2><a class="header" href="#map-requirements-1" id="map-requirements-1">Map requirements</a></h2>
<p>Before a lift can be properly integrated, be sure to draw up the lift locations with the correct lift names and levels on the navigation graph using <code>traffic_editor</code>. The instructions to do so can be found in Chapter 3. Traffic Editor.</p>
<h2><a class="header" href="#integration-2" id="integration-2">Integration</a></h2>
<p>Elevator integration will allow RMF to work over multiple levels, resolving conflicts and managing shared resources on a larger scale. Similar to door integration, the basic requirement is that the lift controller accepts commands using a prescribed protocol, <code>OPC</code> is one such example.</p>
<p>The elevators will be integrated in a similar fashion as doors as well, relying on a lift node and a lift adapter. The following block diagram shows how each component works with each other.</p>
<img src="images/lifts_block_diagram.png">
<p>The lift node will act as a driver to work with the lift controller. An example of a lift node can be found in this <a href="https://github.com/sharp-rmf/kone_lift_controller">repository</a>. The node will publish its state and receive lift requests over ROS 2, using the messages and topics listed below.</p>
<table><thead><tr><th>Message Types</th><th>ROS2 Topic</th><th>Description</th></tr></thead><tbody>
<tr><td><code>rmf_lift_msgs/LiftState</code></td><td><code>/lift_states</code></td><td>State of the lift published by the lift node</td></tr>
<tr><td><code>rmf_lift_msgs/LiftRequest</code></td><td><code>/lift_requests</code></td><td>Direct requests subscribed by the lift node and published by the lift adapter</td></tr>
<tr><td><code>rmf_lift_msgs/LiftRequest</code></td><td><code>/adapter_lift_requests</code></td><td>Requests to be sent to the lift adapter/supervisor to request safe operation of lifts</td></tr>
</tbody></table>
<p>A lift adapter subscribes to <code>lift_states</code> while keeping track of the internal and desired state of the lift in order to prevent it from performing any actions that might interrupt mobile robot or normal operations. The lift adapter performs this task by receiving lift requests from the fleet adapters and the RMF core systems and only relaying the instructions to the lift node if it is deemed appropriate. Any requests sent directly to the lift node, without going through the lift adapter, will also be negated by the lift adapter, to prevent unwanted disruption to mobile robot fleet operations.</p>
<h2><a class="header" href="#workcells-1" id="workcells-1">Workcells</a></h2>
<p>Work in progress.</p>
<h1><a class="header" href="#ui" id="ui">UI</a></h1>
<h2><a class="header" href="#introduction-1" id="introduction-1">Introduction</a></h2>
<p>We have looked at how we can integrate new hardware into RMF, now we will look at how we can write end user applications which integrate into RMF. We will briefly go through the requirements of an RMF UI application and provide a tutorial to write a React Webapp that interfaces with RMF.</p>
<h2><a class="header" href="#overview-1" id="overview-1">Overview</a></h2>
<p>The most common way to write a UI application is to make use of a UI framework. There are many available UI frameworks, the following are some of the popular frameworks for reference:</p>
<ul>
<li>Multi-Paradigm
<ul>
<li>Qt</li>
<li>React native</li>
<li>Xamarin</li>
<li>Flutter</li>
</ul>
</li>
<li>Web
<ul>
<li>React</li>
<li>Angular</li>
<li>Vue</li>
</ul>
</li>
<li>Desktop
<ul>
<li>wxWidgets</li>
<li>Gtk</li>
<li>WPF (Windows only)</li>
</ul>
</li>
</ul>
<p>Each framework has pros and cons and we do not feel there is a &quot;best&quot; framework for all use cases. That being said, some frameworks are more suitable to integrate with RMF due to their specific underlying technologies. To understand why, let's take a brief overview at how an RMF UI application would work.</p>
<h2><a class="header" href="#how-does-an-rmf-ui-application-work" id="how-does-an-rmf-ui-application-work">How does an RMF UI Application Work?</a></h2>
<p>Imagine a simple UI application with a label that shows the current status of a door and a button that opens/closes the door. Recall that in the door adapter, we publish door states and subscribe to door requests. Here we are doing the reverse; subscribing to door states and publishing door requests. We will be listening to door states coming in from RMF and updating our display to match, and we will also be sending door requests when the user clicks the open or close button.</p>
<p>We need to use a libray to help us do that. In the hardware adapter examples we are using the <code>rclcpp</code> library, but <code>rclcpp</code> isn't the only way to use ROS 2. Here are some libraries that also work well</p>
<ul>
<li>Direct
<ul>
<li>rcl (C)</li>
<li>rclcpp (C++)</li>
<li>rclpy (python)</li>
<li>rclnodejs (nodejs)</li>
</ul>
</li>
<li>Indirect
<ul>
<li>soss (websocket)</li>
<li>rosbridge (websocket)</li>
</ul>
</li>
</ul>
<p>A &quot;direct&quot; library is able to send and receive ROS2 messages directly from the application, in contrast, an indirect library uses a middleman service to forward ROS2 messages. In general, the &quot;direct&quot; approach is more preferable but sometimes it is not possible on the target platform. In these cases, the indirect approach can be used.</p>
<div style="border: 1px; border-style: solid; padding: 1em">
<b>Note</b>: This is not an exhaustive list, you can find many third-party projects that aims to bring the ROS2 ecosystem to more platforms, the <code>ros2-dotnet</code> project for example, provides C# bindings for ROS2. You can also write your own bindings and middlewares!
</div>
<p>At the end of the day, writing a RMF UI application isn't much different from writing any other UI application, the only difference being that we will be sending/receiving ROS2 in response to user input and updating the state.</p>
<h1><a class="header" href="#tutorial-react-webapp" id="tutorial-react-webapp">Tutorial: React WebApp</a></h1>
<p>In this section, we will go through an example of creating a React-based webapp to monitor door states and send door open/close requests. The tutorial will focus on the aspects of communicating with RMF, basic knowledge of React and TypeScript is needed.</p>
<p>Note that this isn't the only way to create a RMF UI application, as mentioned before, you can use any UI toolkit, the only requirement is to be able to send/receive ROS2 messages.</p>
<p>The code for this tutorial is available at <a href="https://github.com/osrf/ros2multirobotbook/tree/master/src/react-app-tutorial">https://github.com/osrf/ros2multirobotbook/tree/master/src/react-app-tutorial</a>.</p>
<h2><a class="header" href="#requirements" id="requirements">Requirements</a></h2>
<ul>
<li>nodejs &gt;= 10</li>
<li>rmf_core (<a href="https://github.com/osrf/rmf_core">https://github.com/osrf/rmf_core</a>)</li>
<li>soss (<a href="https://github.com/osrf/soss">https://github.com/osrf/soss</a>)</li>
<li>romi-soss-ros2 (<a href="https://github.com/osrf/romi-soss-ros2">https://github.com/osrf/romi-soss-ros2</a>)</li>
<li>rmf_demos (<a href="https://github.com/osrf/rmf_demos">https://github.com/osrf/rmf_demos</a>)</li>
</ul>
<p>We will not go through the process of setting up the dependencies, instructions to set them up can be easily found on the web or from their project homepages.</p>
<h2><a class="header" href="#setting-up" id="setting-up">Setting Up</a></h2>
<p>We will be using an example from rmf_demo as the RMF deployment that we will be interacting with. This is a good time to test if your installation of <code>rmf_demo</code> is working properly, start the demo with the following command</p>
<pre><code>ros2 launch demos office.launch.xml
</code></pre>
<p>Next let's test if soss is working. In order to run soss, you need to provide it with a configuration file, you can use <a href="ui-resources/soss.yaml">this</a> template as a start. You would need a certificate for soss, refer to various tutorials online to generate one, if you are using a self-signed cert, also make sure your browser is set to accept it for websocket connections. Add the path of your cert and key to the soss config and try starting soss with</p>
<pre><code>soss &lt;path_to_config&gt;
</code></pre>
<p>Once the environment is set up, we can then proceed to set up our actual app. First, create a React workspace with:</p>
<pre><code>npx create-react-app react-app-tutorial --template typescript
</code></pre>
<p>Go inside the newly created <code>react-app-tutorial</code> directory and run the follow command to install all the javascript dependencies we will be using</p>
<pre><code>npm install @osrf/romi-js-core-interfaces @osrf/romi-js-soss-transport jsonwebtoken @types/jsonwebtoken
</code></pre>
<p>These libraries are not strictly required but they contain helpful functions to use <code>soss</code> and to communicate with RMF. If you are building a JavaScript-based RMF app, it is recommended to make use of them, we will see later how they simplify the communicaton to RMF.</p>
<div style="border: 1px; border-style: solid; padding: 1em">
<b>Note</b>: Other than <code>@osrf/romi-js-soss-transport</code>, there is also <code>@osrf/romi-js-rclnodejs-transport</code> which is able to send ROS2 messages directly, however it does not work on the browser. It is preferred if you are writing a nodejs based desktop application using something like electron, or you are writing a server based application like a REST API provider.
</div>
<h2><a class="header" href="#door-component" id="door-component">Door Component</a></h2>
<p>First of all, let's start things simple by creating a component to show a door's state along with open and close buttons. Create a new file called <code>Door.tsx</code> in <code>react-app-tutorial/src</code> directory and copy the below snippet into it.</p>
<p>Door.tsx:</p>
<pre><code class="language-js">import React from 'react';

export interface DoorProps {
  name: string;
  state: string;
  onOpenClick?(e: React.MouseEvent): void;
  onCloseClick?(e: React.MouseEvent): void;
}

export const Door = (props: DoorProps) =&gt; {
  const { name, state, onOpenClick, onCloseClick } = props;
  return (
    &lt;div&gt;
      Door: {name}
      &lt;br /&gt;
      State: {state}
      &lt;br /&gt;
      &lt;button onClick={(e) =&gt; onOpenClick &amp;&amp; onOpenClick(e)}&gt;Open&lt;/button&gt;
      &lt;button onClick={(e) =&gt; onCloseClick &amp;&amp; onCloseClick(e)}&gt;Close&lt;/button&gt;
      &lt;br /&gt;
      &lt;br /&gt;
    &lt;/div&gt;
  );
};

export default Door;
</code></pre>
<p>Nothing much is happening here yet, we are simply rendering the door name, its state an open and a close button.</p>
<p>Let's test things out by running it, replace <code>App.tsx</code> with this</p>
<pre><code class="language-js">import React from 'react';
import Door from './Door';

function App() {
  return &lt;Door name=&quot;example_door&quot; state=&quot;Closed&quot; /&gt;;
}

export default App;
</code></pre>
<p>and start it with <code>npm start</code>, you should see something like this</p>
<p><img src="ui-resources/door.png" alt="Door" /></p>
<p>Great! we now have a base to start implementing the rest of the app.</p>
<h2><a class="header" href="#obtain-list-of-doors" id="obtain-list-of-doors">Obtain List of Doors</a></h2>
<p>Previously we made a simple door component and tested rendering it with hardcoded values, obviusly this won't work in a proper app, here we will look at how we can obtain the list of actual doors from RMF.</p>
<p>Start of by adding a React state to track the list of doors</p>
<pre><code class="language-js">const [doors, setDoors] = React.useState&lt;RomiCore.Door[]&gt;([]);
</code></pre>
<p>RMF has a <code>get_building_map</code> service that we can use to get the list of doors, lifts, levels among many other data, in order to make use of the service we need to do a ROS2 service call, since there isn't ROS2 support on the browser, we will be using an &quot;indirect&quot; approach with <code>soss</code>. A websocket connection is made to soss which will then act as a middleman and pass our messages to the ROS2 network.</p>
<p>An easy way to use soss is with the <code>@osrf/romi-js-soss-transport</code> package, so let's do it now. Add a react effect hook to your <code>App</code> component</p>
<pre><code class="language-js">  React.useEffect(() =&gt; {
    (async () =&gt; {
      const token = jwt.sign({ user: 'example-user' }, 'rmf', { algorithm: 'HS256' });
      const transport = await SossTransport.connect('example', 'wss://localhost:50001', token);
    })();
  }, []);
</code></pre>
<p>we will need to import <code>SossTransport</code> so add this to the top of the file</p>
<pre><code class="language-js">import { SossTransport } from '@osrf/romi-js-soss-transport';
</code></pre>
<p>This performs a websocket connection to the soss server, <code>example</code> is the ROS2 node name that we will be using and we are connecting to a soss server at <code>wss://localhost:50001</code>. The server uses a JWT token signed with a secret specified in the soss config, the example config is using <code>rmf</code>, if you changed the secret, be sure to change it here as well.</p>
<div style="border: 1px; border-style: solid; padding: 1em">
<b>Note</b>: This example is only for convenience, you should never reveal the secret to the client. Usually the client would connect to an authentication server which will verify that it is a valid request and return a signed token.
</div>
<p>Now that we have a connection to soss, we can call the <code>get_building_map</code> service, add this to the react effect</p>
<pre><code class="language-js">const buildingMap = (await transport.call(RomiCore.getBuildingMap, {})).building_map;
setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));
</code></pre>
<p>it uses <code>RomiCore</code> so add this to your imports</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
</code></pre>
<p>This downloads and parses the building map from RMF. <code>romi-js</code> simplifies a ROS2 service call with the async <code>call</code> method. If you are familiar with <code>rclnodejs</code>, this is roughly equivalent to</p>
<pre><code class="language-js">const client = node.createClient(
  'building_map_msgs/srv/GetBuildingMap',
  'get_building_map'
);
client.sendRequest({}, response =&gt; {
  const buildingMap = response.building_map;
  setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));
});
</code></pre>
<p>Notice that we need to provide it with type of the message (<code>building_map_msgs/srv/GetBuildingMap</code>) and the name of the service (<code>get_building_map</code>), but how do we find out what is the service name and type? We could read the RMF manual or query the ROS2 system while RMF is running, another way is with the help of <code>RomiCore</code>, it provides a list of known RMF services and messages so you don't have to go through the trouble of finding them yourself.</p>
<p>In this statement here, we are using <code>RomiCore</code> to call the <code>get_building_map</code> service without needing to know the service name and types</p>
<pre><code class="language-js">transport.call(RomiCore.getBuildingMap, {})
</code></pre>
<p>Now that we have a list of <code>RomiCore.Door</code>, let's make things simpler by updating <code>Door.tsx</code> to take that in as a prop, while we are at it, let's also have it take in a <code>RomiCore.DoorState</code> as a prop since we will be using it later.</p>
<p>Door.tsx:</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import React from 'react';

export interface DoorProps {
  door: RomiCore.Door;
  doorState?: RomiCore.DoorState;
  onOpenClick?(e: React.MouseEvent): void;
  onCloseClick?(e: React.MouseEvent): void;
}

export const Door = (props: DoorProps) =&gt; {
  const { door, doorState, onOpenClick, onCloseClick } = props;
  return (
    &lt;div&gt;
      Door: {door.name}
      &lt;br /&gt;
      State: {doorState ? doorState.current_mode.value : 'Unknown'}
      &lt;br /&gt;
      &lt;button onClick={(e) =&gt; onOpenClick &amp;&amp; onOpenClick(e)}&gt;Open&lt;/button&gt;
      &lt;button onClick={(e) =&gt; onCloseClick &amp;&amp; onCloseClick(e)}&gt;Close&lt;/button&gt;
      &lt;br /&gt;
      &lt;br /&gt;
    &lt;/div&gt;
  );
};

export default Door;
</code></pre>
<p>Now we can test it by passing the doors as props, your <code>App</code> component should now look like this</p>
<p>App.tsx:</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import { SossTransport } from '@osrf/romi-js-soss-transport';
import * as jwt from 'jsonwebtoken';
import React from 'react';
import Door from './Door';

function App() {
  const [doors, setDoors] = React.useState&lt;RomiCore.Door[]&gt;([]);

  React.useEffect(() =&gt; {
    (async () =&gt; {
      const token = jwt.sign({ user: 'example-user' }, 'rmf', { algorithm: 'HS256' });
      const transport = await SossTransport.connect('example', 'wss://localhost:50001', token);
      const buildingMap = (await transport.call(RomiCore.getBuildingMap, {})).building_map;
      setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));
    })();
  }, []);

  return (
    &lt;React.Fragment&gt;
      {doors.map((door) =&gt; (
        &lt;Door door={door} /&gt;
      ))}
    &lt;/React.Fragment&gt;
  );
}

export default App;
</code></pre>
<p>Don't worry about the door state for now. If everything goes well, you should see 3 doors that are in the building</p>
<p><img src="ui-resources/building-map-doors.png" alt="Doors" /></p>
<h2><a class="header" href="#listening-for-door-states" id="listening-for-door-states">Listening for Door States</a></h2>
<p>Previously we managed to render the list of doors in the RMF system but the building map doesn't tells us the door states so we will now fix it here. First, let's add a react state to track the door states</p>
<pre><code class="language-js">const [doorStates, setDoorStates] = React.useState&lt;Record&lt;string, RomiCore.DoorState&gt;&gt;({});
</code></pre>
<p>The door states can be obtained by subscribing to the <code>door_states</code> topic, update your effect to add this</p>
<pre><code class="language-js">transport.subscribe(RomiCore.doorStates, (doorState) =&gt;
  setDoorStates((prev) =&gt; ({ ...prev, [doorState.door_name]: doorState })),
);
</code></pre>
<p>This performs a ROS2 subscription to the <code>RomiCore.doorStates</code> topic, similar to the service call we did earlier, <code>romi-js</code> abstracts away the ROS2 topic name and provides type information. The callback will be fired each time a new door state message comes in and in the callback, we simply update the <code>doorStates</code> state.</p>
<p>Now just pass the door state to the door component:</p>
<pre><code class="language-js">&lt;Door door={door} doorState={doorStates[door.name]} /&gt;
</code></pre>
<p>the end result of your <code>App.tsx</code> should look like this</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import { SossTransport } from '@osrf/romi-js-soss-transport';
import * as jwt from 'jsonwebtoken';
import React from 'react';
import Door from './Door';

function App() {
  const [doors, setDoors] = React.useState&lt;RomiCore.Door[]&gt;([]);
  const [doorStates, setDoorStates] = React.useState&lt;Record&lt;string, RomiCore.DoorState&gt;&gt;({});

  React.useEffect(() =&gt; {
    (async () =&gt; {
      const token = jwt.sign({ user: 'example-user' }, 'rmf', { algorithm: 'HS256' });
      const transport = await SossTransport.connect('example', 'wss://localhost:50001', token);
      const buildingMap = (await transport.call(RomiCore.getBuildingMap, {})).building_map;
      setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));

      transport.subscribe(RomiCore.doorStates, (doorState) =&gt;
        setDoorStates((prev) =&gt; ({ ...prev, [doorState.door_name]: doorState })),
      );
    })();
  }, []);

  return (
    &lt;React.Fragment&gt;
      {doors.map((door) =&gt; (
        &lt;Door door={door} doorState={doorStates[door.name]} /&gt;
      ))}
    &lt;/React.Fragment&gt;
  );
}

export default App;
</code></pre>
<p>And just like that we now have the door states!</p>
<p><img src="ui-resources/with-door-states-number.png" alt="with door states" /></p>
<p>But wait... the door states are numbers like <code>1</code> and <code>2</code>, this is because RMF uses a constant to represent door states, we could run a simple function to convert these constants into string</p>
<pre><code class="language-js">function doorModeString(doorMode: RomiCore.DoorMode): string {
  switch (doorMode.value) {
    case 2:
      return 'Open';
    case 0:
      return 'Closed';
    case 1:
      return 'Moving';
    default:
      return 'Unknown';
  }
}
</code></pre>
<p>but how do we know <code>2</code> means &quot;Open&quot; etc? We can find out by reading the RMF manual or inspecting the ROS2 message definitions, but we can do better with <code>RomiCore</code>, it provides the list of constants in a more readable form</p>
<pre><code class="language-js">function doorModeString(doorMode: RomiCore.DoorMode): string {
  switch (doorMode.value) {
    case RomiCore.DoorMode.MODE_OPEN:
      return 'Open';
    case RomiCore.DoorMode.MODE_CLOSED:
      return 'Closed';
    case RomiCore.DoorMode.MODE_MOVING:
      return 'Moving';
    default:
      return 'Unknown';
  }
}
</code></pre>
<p>With this it's obvious what each constant represents so we don't have to refer to anything else to find its meaning.</p>
<p>Go ahead and add this to your <code>Door.tsx</code>, it should look like this now</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import React from 'react';

export interface DoorProps {
  door: RomiCore.Door;
  doorState?: RomiCore.DoorState;
  onOpenClick?(e: React.MouseEvent): void;
  onCloseClick?(e: React.MouseEvent): void;
}

export const Door = (props: DoorProps) =&gt; {
  const { door, doorState, onOpenClick, onCloseClick } = props;
  const modeString = doorState ? doorModeString(doorState.current_mode) : 'Unknown';
  return (
    &lt;div&gt;
      Door: {door.name}
      &lt;br /&gt;
      State: {modeString}
      &lt;br /&gt;
      &lt;button onClick={(e) =&gt; onOpenClick &amp;&amp; onOpenClick(e)}&gt;Open&lt;/button&gt;
      &lt;button onClick={(e) =&gt; onCloseClick &amp;&amp; onCloseClick(e)}&gt;Close&lt;/button&gt;
      &lt;br /&gt;
      &lt;br /&gt;
    &lt;/div&gt;
  );
};

function doorModeString(doorMode: RomiCore.DoorMode): string {
  switch (doorMode.value) {
    case RomiCore.DoorMode.MODE_OPEN:
      return 'Open';
    case RomiCore.DoorMode.MODE_CLOSED:
      return 'Closed';
    case RomiCore.DoorMode.MODE_MOVING:
      return 'Moving';
    default:
      return 'Unknown';
  }
}

export default Door;
</code></pre>
<p>Great! Now we have readable door states instead of cryptic numbers.</p>
<p><img src="ui-resources/with-door-states.png" alt="with door states" /></p>
<h2><a class="header" href="#sending-door-requests" id="sending-door-requests">Sending Door Requests</a></h2>
<p>As you may have expected by now, all we have to do here is to send door requests to RMF.</p>
<p>First, create a publisher, add this to the start of the render function.</p>
<pre><code class="language-js">const doorRequestPub = React.useRef&lt;RomiCore.Publisher&lt;RomiCore.DoorRequest&gt; | null&gt;(null);
</code></pre>
<p>Then add this helper function:</p>
<pre><code class="language-js">const requestDoor = (door: RomiCore.Door, mode: number) =&gt; {
  if (doorRequestPub.current) {
    const request: RomiCore.DoorRequest = {
      door_name: door.name,
      request_time: RomiCore.toRosTime(new Date()),
      requested_mode: { value: mode },
      requester_id: 'example-request',
    };
    doorRequestPub.current.publish(request);
  }
};
</code></pre>
<p>It takes in a <code>RomiCore.Door</code> and a number, representing the desired mode, and crafts a <code>RomiCore.DoorRequest</code> message and sends it using the publisher. Normally you would have to consult the RMF manual or the ROS2 definitions to know exactly what you need to send. Again, <code>RomiCore</code> provides the typing information to make it easier to fill in the required fields.</p>
<p>Finally, add this to the props passed to the door component:</p>
<pre><code class="language-js">onOpenClick={() =&gt; requestDoor(door, RomiCore.DoorMode.MODE_OPEN)}
onCloseClick={() =&gt; requestDoor(door, RomiCore.DoorMode.MODE_CLOSED)}
</code></pre>
<p>Your final <code>App.tsx</code> should look like this:</p>
<pre><code class="language-js">import * as RomiCore from '@osrf/romi-js-core-interfaces';
import { SossTransport } from '@osrf/romi-js-soss-transport';
import * as jwt from 'jsonwebtoken';
import React from 'react';
import Door from './Door';

function App() {
  const [doors, setDoors] = React.useState&lt;RomiCore.Door[]&gt;([]);
  const [doorStates, setDoorStates] = React.useState&lt;Record&lt;string, RomiCore.DoorState&gt;&gt;({});
  const doorRequestPub = React.useRef&lt;RomiCore.Publisher&lt;RomiCore.DoorRequest&gt; | null&gt;(null);

  React.useEffect(() =&gt; {
    (async () =&gt; {
      const token = jwt.sign({ user: 'example-user' }, 'rmf', { algorithm: 'HS256' });
      const transport = await SossTransport.connect('example', 'wss://localhost:50001', token);
      const buildingMap = (await transport.call(RomiCore.getBuildingMap, {})).building_map;
      setDoors(buildingMap.levels.flatMap((level) =&gt; level.doors));

      transport.subscribe(RomiCore.doorStates, (doorState) =&gt;
        setDoorStates((prev) =&gt; ({ ...prev, [doorState.door_name]: doorState })),
      );

      doorRequestPub.current = transport.createPublisher(RomiCore.adapterDoorRequests);
    })();
  }, []);

  const requestDoor = (door: RomiCore.Door, mode: number) =&gt; {
    if (doorRequestPub.current) {
      const request: RomiCore.DoorRequest = {
        door_name: door.name,
        request_time: RomiCore.toRosTime(new Date()),
        requested_mode: { value: mode },
        requester_id: 'example-request',
      };
      doorRequestPub.current.publish(request);
    }
  };

  return (
    &lt;React.Fragment&gt;
      {doors.map((door) =&gt; (
        &lt;Door
          door={door}
          doorState={doorStates[door.name]}
          onOpenClick={() =&gt; requestDoor(door, RomiCore.DoorMode.MODE_OPEN)}
          onCloseClick={() =&gt; requestDoor(door, RomiCore.DoorMode.MODE_CLOSED)}
        /&gt;
      ))}
    &lt;/React.Fragment&gt;
  );
}

export default App;
</code></pre>
<p>Try clicking on the open and close buttons now, you should see the door state being updated, you can also see the door opening/closing in gazebo. Congratulations! You have just written a simple RMF UI application! Obviously the design leaves much to be desired as we didn't do any CSS styling but that is outside the scope of this tutorial.</p>
<p>Extending this to provide more features like lift control, fleet states etc follows the same principle. All the available topics and services exposed by RMF are available in <code>RomiCore</code> and you can find more detailed information by reading the rest of the manual. This also extends to writing UI applications for other platforms and frameworks; at the core you are really just publishing and subscribing to ROS2 messages so you can apply the same principles to other languages and frameworks.</p>
<h2><a class="header" href="#conclusion-1" id="conclusion-1">Conclusion</a></h2>
<p>We have just created a minimal RMF UI application that reports the door state and allows a user to control the door. For simplicity, there aren't many features included but this tutorial should provide the basic knowledge of how to create an RMF UI application not only in React but also in any framework that you like!</p>
<p>If you would like more examples of a React RMF application, you can take a look at the official <a href="https://github.com/osrf/romi-dashboard">RoMi dashboard</a>.</p>
<h2><a class="header" href="#extra-extending-romi-js" id="extra-extending-romi-js">Extra: Extending romi-js</a></h2>
<p>Throughout the tutorial, we are using <code>romi-js</code> to simplify the communication to RMF. As you might have noticed <code>romi-js</code> is actually a collection of packages, this design makes it possible to easily extend it with new topics, services and even transports.</p>
<h3><a class="header" href="#adding-topics-and-services" id="adding-topics-and-services">Adding Topics and Services</a></h3>
<p>Adding topics and services are very simple, a topic and service are defined by the interfaces:</p>
<pre><code class="language-js">export interface RomiTopic&lt;Message&gt; {
  readonly validate: (msg: any) =&gt; Message;
  readonly type: string;
  readonly topic: string;
  readonly options?: Options;
}

export interface RomiService&lt;Request, Response&gt; {
  readonly validateRequest: (msg: any) =&gt; Request;
  readonly validateResponse: (msg: any) =&gt; Response;
  readonly type: string;
  readonly service: string;
  readonly options?: Options;
}
</code></pre>
<p>If you are familiar with ROS 2, the <code>type</code> field specifies the message type that the topic or service expects while <code>topic</code>/<code>service</code> are the topic and service names, respectively. Sometimes a topic or service is expected to use a different QoS option; for example a topic that does not only publish when the state changes and expects late subscriptions to make use of transient local QoS to receive the latest state. The <code>options</code> specify the &quot;default&quot; QoS options that should be used. In this way, users do not have to refer to the usage instructions to correctly publish and subscribe to the topic.</p>
<p>The <code>validate*</code> methods are used by the transport to convert an abitary object to the expected type of the topic or service. It should check if the object has the correct fields and that the fields are of the correct types. To ensure compatibility with different transports, these methods should be able to convert number arrays to typed arrays and vice versa.</p>
<p>We can create custom topics or services by implementing these interfaces, they can then be passed to the transport's various methods.</p>
<pre><code class="language-js">export const myTopic: RomiTopic&lt;MyMessage&gt; = {
  validate: validateMyMessage(msg), // some function that valides MyMessage
  type: 'my_messages/msg/MyMessage',
  topic: 'my_topic',
};
</code></pre>
<h3><a class="header" href="#adding-transport" id="adding-transport">Adding Transport</a></h3>
<p>A <code>Transport</code> in <code>romi-js</code> is a class with the interface:</p>
<pre><code class="language-js">export interface Subscription {
  unsubscribe(): void;
}

export interface Publisher&lt;Message&gt; {
  publish(msg: Message): void;
}

export interface Service&lt;Request, Response&gt; {
  start(handler: (req: Request) =&gt; Promise&lt;Response&gt; | Response): void;
  stop(): void;
}

export interface Transport extends TransportEvents {
  readonly name: string;

  createPublisher&lt;Message extends unknown&gt;(
    topic: RomiTopic&lt;Message&gt;,
    options?: Options,
  ): Publisher&lt;Message&gt;;

  subscribe&lt;Message extends unknown&gt;(
    topic: RomiTopic&lt;Message&gt;,
    cb: SubscriptionCb&lt;Message&gt;,
    options?: Options,
  ): Subscription;

  call&lt;Request extends unknown, Response extends unknown&gt;(
    service: RomiService&lt;Request, Response&gt;,
    req: Request,
  ): Promise&lt;Response&gt;;

  createService&lt;Request extends unknown, Response extends unknown&gt;(
    service: RomiService&lt;Request, Response&gt;,
  ): Service&lt;Request, Response&gt;;

  destroy(): void;
}
</code></pre>
<p>There isn't a general guide on how the interface should be implemented since the details would be different for each transport. One thing to note is that it might be tempting to return a type derived from <code>any</code> (e.g. <code>Publisher&lt;any&gt;</code>) to pass the typescript checks but doing so is not recommended. You should call the <code>validate*</code> methods in the topic or service to convert something into a type of <code>Message</code>.</p>
<p>To ensure compatibilities with different topics and services, transports must deserialize the data to a plain old data object. It can use either number arrays or typed arrays, the <code>validate*</code> methods should support converting them to the expected types.</p>
<h1><a class="header" href="#security" id="security">Security</a></h1>
<p>This chapter describes how to use DDS Security tools to provide authentication,
encryption, and access control to a RoMi-H system.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
